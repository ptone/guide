{% extends "templates/_base.html" %}

{% block file_metadata %}
  <meta name="title" content="Extras" />
  <meta name="status" content="Still being written" />
{% endblock file_metadata %}

{% block content %}

<section id="s:shell">
  <h2>The Bash Shell</h2>

  <section id="s:shell:permissions">
    <h3>File Permissions</h3>
    <p class="fixme">write about file permissions</p>
  </section>

</section>

<section id="s:python">
  <h2>Python</h2>

<section id="s:nestloop">
  <h2>Nesting Loops</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Trace the execution of a nested loop.</li>
      <li>Give examples of the kinds of problems that nested loops should be used to solve.</li>
      <li>Construct nested loops with independent ranges.</li>
      <li>Construct nested loops in which the range of the inner loop depends on the state of the outer loop, and give an example showing when this is useful.</li>
    </ul>
  </div>

  <p>
    Going back to Aurora's data cleanup problem,
    suppose that the scores in each data set
    are always supposed to ramp upward:
    if we ever see a value that's less than the value before it,
    something's gong wrong.
    Here's a program that tries to check that
    (again, using inline data instead of reading from a file
    to make the sample code clearer):
  </p>

<pre>
data = [1, 2, 2, 3, 4, 4, 5, 6, 5, 6, 7, 7, 8]
for i in range(len(data)):
    if data[i] &lt; data[i-1]:
        print "failure at index:", i
    i = i + 1
<hr/>
<span class="out">failure at index: 0
failure at index: 8</span>
</pre>

  <p class="continue">
    Whoops&mdash;why is it telling us that there's a failure at index 0?
    Take a close look at the third line:
    when <code>i</code> is 0,
    it compares <code>data[0]</code> to <code>data[-1]</code>,
    but as we said earlier,
    index -1 means the last element of the list.
    We need to make sure that we only compare the <em>second</em> and higher elements
    to the ones before them:
  </p>

<pre>
data = [1, 2, 2, 3, 4, 4, 5, 6, 5, 6, 7, 7, 8]
for i in <span class="highlight">range(1, len(data))</span>:
    if data[i] &lt; data[i-1]:
        print "failure at index:", i
    i = i + 1
<hr/>
<span class="out">failure at index: 8</span>
</pre>

  <p class="continue">
    This program uses the fact that <code>range(low, high)</code>
    generates the values from <code>low</code> to <code>high-1</code>.
    We can also use <code>range(low, high, stride)</code>
    to generate values that are spaced <code>stride</code> apart,
    so that <code>range(5, 20, 3)</code> produces
    <code>[5, 8, 11, 14, 17]</code>.
    (Remember,
    <code>range</code> goes up to but not including the top value.)
  </p>

  <p>
    Now suppose that Aurora needs to add up successive triples of her data
    to time-average the scores.
    Our first try steps through the indices three at a time:
  </p>

<pre>
data = [1, 2, 2, 3, 4, 4, 5, 6, 5, 6, 7, 7, 8]
result = []
for i in range(0, len(data), 3):
    sum = data[i] + data[i+1] + data[i+2]
    result.append(sum)
print "grouped data:", result
<hr/>
<span class="err">Traceback (most recent call last):
  File "group-by-threes-fails.py", line 6, in &lt;module&gt;
    sum = data[i] + data[i+1] + data[i+2]
IndexError: list index out of range</span>
</pre>

  <p class="continue">
    It's not immediately obvious what's wrong,
    but a bit of experimenting with shorter lists turns up the problem.
    If the number of elements in the list isn't exactly divisible by 3,
    our program is going to try to reach past the end of the list.
    For example,
    if we have a 4-element list,
    we will add up the values at locations 0, 1, and 2,
    then try to add up the values at locations 3, 4, and 5,
    but locations 4 and 5 aren't valid
    (<a href="#f:a_step_too_far">Figure 20</a>).
  </p>

  <figure id="f:a_step_too_far">
    <img src="python/a_step_too_far.png" alt="A Step Too Far" />
    <figcaption>Figure 20: A Step Too Far</figcaption>
  </figure>

  <p>
    How we should fix this is a question for a scientist
    (or at least a statistician):
    should we throw away the top few values if there aren't enough to make another triple,
    or add up as many as there are and hope for the best?
    Let's assume the latter for now:
  </p>

<pre>
data = [1, 2, 2, 3, 4, 4, 5, 6, 5, 6, 7, 7, 8]
result = []
for i in range(0, len(data), 3):
    sum = data[i]
    if (i+1) &lt; len(data):
        sum += data[i+1]
    if (i+2) &lt; len(data):
        sum += data[i+2]
    result.append(sum)
print "grouped data:", result
<hr/>
<span class="out">grouped data: [5, 11, 16, 20, 8]</span>
</pre>

  <p>
    This works,
    but it feels clumsy:
    if we were adding up in groups of ten,
    we'd have a lot of <code>if</code> statements.
    We need a better way.
  </p>

  <p>
    Our first step toward that better way looks like this:
  </p>

<pre>
vowels = "ae"
consonants = "dnx"
for v in vowels:
    for c in consonants:
        print v + c
<hr/>
<span class="out">ad
an
ax
ed
en
ex</span>
</pre>

  <p>
    <a href="#f:nested_flowchart">Figure 21</a> shows
    what's going on in this <a href="glossary.html#nested-loop">nested loop</a>.
    Each time the <a href="glossary.html#outer-loop">outer loop</a> executes,
    Python runs the entire <a href="glossary.html#inner-loop">inner loop</a>.
    The innermost <code>print</code> statement therefore executes six times,
    because the outer loop runs twice,
    and the inner loop runs three times for each of those iterations.
  </p>

  <figure id="f:nested_flowchart">
    <img src="python/nested_flowchart.png" alt="Nested Loops" />
    <figcaption>Figure 21: Nested Loops</figcaption>
  </figure>

  <p>
    In this case,
    both loops execute a fixed number of times,
    but that doesn't have to be the case.
    It's common,
    for example,
    to set the number of times an inner loop runs
    based on the current value of the outer loop's counter:
  </p>

<pre>
for i in range(4):
    for j in range(i):
        print i, j
<hr/>
<span class="out">1 0
2 0
2 1
3 0
3 1
3 2</span>
</pre>

  <figure id="f:triangle_nested_loop">
    <img src="python/triangle_nested_loop.png" alt="Nested Loop Execution" />
    <figcaption>Figure 22: Nested Loop Execution</figcaption>
  </figure>

  <p>
    <a href="#f:triangle_nested_loop">Figure 22</a> traces
    this little program's execution.
    The first time through,
    <code>i</code> is 0.
    Since <code>range(0)</code> is the empty list <code>[]</code>,
    the inner loop is effectively:
  </p>

<pre>
    for j in []:
        print i, j
</pre>

  <p class="continue">
    so it doesn't execute at all.
    The next time,
    though,
    when <code>i</code> is 1,
    the inner loop is effectively:
  </p>

<pre>
    for j in [0]:
        print i, j
</pre>

  <p class="continue">
    so the innermost <code>print</code> statement is executed once
    with <code>i</code> equal to 1 and <code>j</code> equal to 0.
    The third time around the outer loop,
    <code>i</code> is 2,
    so <code>range(i)</code> is <code>[0, 1]</code>.
    This makes the inner loop execute twice,
    and so on.
  </p>

  <p>
    Now let's go back to Aurora's data smoothing.
    We can step through the data in threes like this:
  </p>

<pre>
for i in range(0, len(data), 3):
    ...body of loop...
</pre>

  <p>
    If we know that the length of a list is an exact multiple of three,
    we can always loop from index <code>i</code>
    up to (but not including) <code>i+3</code>:
  </p>

<pre>
for i in range(0, len(data), 3):
    for j in range(i, i+3):
        ...body of loop...
</pre>

  <p>
    If the list isn't long enough for us to do this,
    we want to go as high as
    the least of <code>i+3</code> and <code>len(data)</code>.
    Using Python's built-in <code>min</code> function,
    this is:
  </p>

<pre>
min(i+3, len(data))
</pre>

  <p class="continue">
    so we can write our inner loop as:
  </p>

<pre>
for i in range(0, len(data), 3):
    upper_bound = min(i+3, len(data))
    for j in range(i, upper_bound):
        ...smooth data...
</pre>

  <p>
    Here's the completed data smoothing program:
  </p>

<pre>
data = [1, 2, 2, 3, 4, 4, 5, 6, 5, 6, 7, 7, 8]
result = []
for i in range(0, len(data), 3):
    upper_bound = min(i+3, len(data))
    sum = 0
    for j in range(i, upper_bound):
        sum += data[j]
    result.append(sum)
print "grouped data:", result
<hr/>
<span class="out">grouped data: [5, 11, 16, 20, 8]</span>
</pre>

  <p>
    This program works,
    but there's room for improvement.
    If we ever want to change the smoothing interval,
    we have to replace the number 3 in two places.
    Let's put that value in a variable <code>width</code>
    to reduce the odds of us updating it one place
    and not the other:
  </p>

<pre>
data = [1, 2, 2, 3, 4, 4, 5, 6, 5, 6, 7, 7, 8]
<span class="highlight">width = 3</span>
result = []
for i in range(0, len(data), <span class="highlight">width</span>):
    upper_bound = min(i+<span class="highlight">width</span>, len(data))
    sum = 0
    for j in range(i, upper_bound):
        sum += data[j]
    result.append(sum)
print "grouped data:", result
<hr/>
<span class="out">grouped data: [5, 11, 16, 20, 8]</span>
</pre>

  <p>
    This change also tells readers
    (including our future selves)
    that the stride in the outer loop,
    and the offset used to calculate <code>upper_bound</code>,
    are always supposed to be the same.
    That's yet another reason to use variables with meaningful names:
    it tells people when values are intentionally the same,
    as opposed to accidentally the same.
  </p>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li><code>range(<em>start</em>, <em>end</em>)</code> creates the list of numbers from <code><em>start</em></code> up to, but not including, <code><em>end</em></code>.</li>
      <li><code>range(<em>start</em>, <em>end</em>, <em>stride</em>)</code> creates the list of numbers from <code><em>start</em></code> up to <code><em>end</em></code> in steps of <code><em>stride</em></code>.</li>
      <li>Use nested loops to do things for combinations of things.</li>
      <li>Make the range of the inner loop depend on the state of the outer loop to automatically adjust how much data is processed.</li>
      <li>Use <code>min(...)</code> and <code>max(...)</code> to find the minimum and maximum of any number of values.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>

      <li>
        What is the final value of <code>total</code> in this program?
<pre>
total = 0
for i in range(2):
    for j in range(-i):
        total += j
print total
</pre>
      </li>

      <li>
        How many different numbers can be put in the blank below so that the value of the expression is 12?
<pre>
sum(range(1, ____, 3))
</pre>
        <ol class="choices">
          <li>Only 1</li>
          <li>2 different values</li>
          <li>3 different values</li>
          <li>The expression's value can never be 12</li>
        </ol>
      </li>

      <li>
        How many different numbers can be put in the blank below so that the value of the expression is 12?
<pre>
sum(range(1, 3, ____))
</pre>
        <ol class="choices">
          <li>Only 1</li>
          <li>2 different values</li>
          <li>3 different values</li>
          <li>The expression's value can never be 12</li>
        </ol>
      </li>

      <li>
        Fill in the blanks so that this accurately describes
        the fragment of code given below.
        <blockquote>
          <code>final_mass</code> starts at 0,
          which is less than any of the values in ________,
          so <code>________(final_mass, inner)</code> is always 0,
          so <code>max(outer, min(...))</code> is always just ________,
          so the final value is just the last value of <code>outer_masses</code>.
        </blockquote>
<pre>
outer_masses = [10, 20, 30]
inner_masses = [1, 2, 3]
final = 0
for outer in outer_masses:
    for inner in inner_masses:
        final = max(outer, min(final, inner))
print final
</pre>
      </li>

    </ol>

  </div>

</section>

<section id="s:nestlist">
  <h2>Nesting Lists</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Explain what nested lists are, and their relationship to nested loops.</li>
      <li>Draw data structure diagrams corresponding to nested lists, and write nested lists that correspond to given diagrams.</li>
      <li>Explain what happens when an expression like "<code>table[3][2]</code>" is evaluated.</li>
    </ul>
  </div>

  <p>
    One of the hearing tests Aurora uses
    asks people to point out where a sound is coming from.
    The data files contain lists of XY coordinates:
  </p>

<pre>
4.2 1.7
3.1 5.0
0.8 6.1
... ...
</pre>

  <p>
    She has roughly 100 such files,
    and one more file (in the same format)
    that holds the actual location of each sound.
    She wants to calculate the average distance between
    each actual and reported location.
  </p>

  <p>
    The first step is to read a file
    and extract the XY values on each line:
  </p>

<pre>
x_values = []
y_values = []
reader = file('data.txt', 'r')
for line in reader:
    x, y = line.split()
    x = float(x)
    x_values.append(x)
    y = float(y)
    y_values.append(y)
reader.close()
</pre>

  <p>
    We can make this a bit more readable
    by combining the calls to <code>float</code> and <code>append</code>:
  </p>

<pre>
x_values = []
y_values = []
reader = file('data.txt', 'r')
for line in reader:
    x, y = line.split()
    x_values.append(float(x))
    y_values.append(float(y))
reader.close()
</pre>

  <p class="continue">
    but the basic approach is still unwieldy.
    What we really want is a list of XY coordinates,
    not two parallel lists of X and Y coordinates.
    We can easily create what we want
    using <a id="g:nested-list" href="glossary.html#nested-list">nested list</a>.
    <a href="#f:simple_nested_list">Figure 23</a> shows
    what we're going to do,
    and the code below shows
    how we would create a nested list by hand
    for specific XY values:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">coordinates = [ [4.2, 1.7], [3.1, 5.0], [0.8, 6.1] ]</span>
&gt;&gt;&gt; <span class="in">print coordinates[0]</span>
<span class="out">[4.2, 1.7]</span>
&gt;&gt;&gt; <span class="in">print coordinates[0][1]</span>
<span class="out">1.7</span>
</pre>

    <figure id="f:simple_nested_list">
      <img src="python/simple_nested_list.py" alt="A Simple Nested List" />
      <figcaption>Figure 23: A Simple Nested List</figcaption>
    </figure>

  <p>
    This isn't as complicated as it first looks.
    Just as a variable can point at any object,
    so too can any entry in a list.
    And since a list is just an object in memory,
    one list can contain a <a href="glossary.html#reference">reference</a> to another.
    This is why <code>coordinates[0]</code> is <code>[4.2, 1.7]</code>:
    the first entry of the outer list is
    a reference to an entire sublist.
    We could just as easily write:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">temp = coordinates[0]</span>
&gt;&gt;&gt; <span class="in">print temp</span>
<span class="out">[4.2, 1.7]</span>
</pre>

  <p class="continue">
    And since <code>x[1]</code> is 4.2,
    so too is <code>coordinates[0][1]</code>:
    the first subscript select the sublist,
    while the second selects an element from that sublist
    (<a href="#f:indexing_nested_lists">Figure 24</a>).
  </p>

  <figure id="f:indexing_nested_lists">
    <img src="python/indexing_nested_lists.png" alt="Indexing Nested Lists" />
    <figcaption>Figure 24: Indexing Nested Lists</figcaption>
  </figure>

  <p>
    It's important to understand that the inner list isn't "in" the outer list:
    what the outer list contains is a reference to the inner one.
    We'll return to this <a href="#s:alias">later</a>.
  </p>

  <p>
    With nested lists in hand,
    it's straightforward to create a list of coordinate pairs:
  </p>

<pre>
values = []
reader = file('data.txt', 'r')
for line in reader:
    x, y = line.split()
    coord = [float(x), float(y)]
    values.append(coord)
reader.close()
</pre>

  <p class="continue">
    Each time the loop executes,
    this program splits the line into two strings,
    creates a new two-element list containing the corresponding numbers,
    and then appends that list to <code>values</code>.
    <a href="#f:growing_nested_list">Figure 25</a> shows how
    the <code>values</code> list grows as successive pairs of numbers are read.
  </p>

  <figure id="f:growing_nested_list">
    <img src="python/growing_nested_list.png" alt="Growing a Nested List" />
    <figcaption>Figure 25: Growing a Nested List</figcaption>
  </figure>

  <p>
    Now suppose that we have two lists of coordinates,
    and we want to find the average distance between corresponding coordinates.
    For the moment,
    we'll just create two representative lists in memory
    and find their average difference:
  </p>

<pre>
expected = [ [4.0, 2.0], [3.0, 5.0], [1.0, 6.0] ]
actual   = [ [4.2, 1.7], [3.1, 5.0], [0.8, 6.1] ]
x_diff, y_diff = 0.0,  0.0
for i in range(len(actual)):
    e = expected[i]
    a = actual[i]
    x_diff += abs(e[0] - a[0])
    y_diff += abs(e[1] - a[1])
print "average errors:", x_diff / len(actual), y_diff / len(actual)
<hr/>
<span class="out">average errors: 0.166666666667 0.133333333333</span>
</pre>

  <p class="continue">
    The first two lines set up our data:
    in a real program,
    we'd read values from files.
    The next line initializes <code>x_diff</code> and <code>y_diff</code>,
    which will hold the errors in X and Y respectively.
    Each iteration of the loop
    sets <code>a</code> and <code>e</code> to point at
    corresponding elements of the vectors.
    <code>a[0]</code> is then the X coordinate of an actual point,
    while <code>e[0]</code> is the X coordinate of the corresponding expected point,
    so <code>abs(e[0] - a[0])</code> is the difference,
    which we add to <code>x_diff</code> using <code>+=</code>.
  </p>

  <div class="box">
    <h3>Choosing Better Test Cases</h3>

    <p>
      How can we be sure that the code shown above is working correctly?
      Putting it another way,
      what test data should we use so that we can tell
      if the answer is right or not?
      One better set of inputs would be:
    </p>
<pre>
expected = [ [0.0, 0.0], [0.0, 0.0], [0.0, 0.0] ]
actual   = [ [1.0, 2.0], [1.0, 4.0], [1.0, 6.0] ]
</pre>
    <p>
      It's clear in this case that the right answers are
      1.0 and 4.0 for X and Y.
      We'll discuss the choice of test cases in more detail
      in a <a href="quality.html">later lesson</a>.
    </p>
  </div>

  <p>
    Nested lists have a close relationship to nested loops.
    For example,
    suppose that Aurora has a list with one entry for each test subject,
    and that each of those entries contains several test scores:
  </p>

<pre>
scores = [ [1.5, 2.2, 1.7, 1.6],
           [2.8, 3.5, 3.6, 1.6],
           [1.3, 1.1, 1.7, 1.4] ]
</pre>

  <p>
    To calculate the average of all these scores,
    she needs to loop over the outer list
    (to cover each test subject),
    and also to loop over every element of each entry
    (to cover each subject's scores):
  </p>

<pre>
total = 0.0
number = 0
for entry in scores:
    for value in entry:
        total += value
        number += 1
average = total / number
print average
<hr/>
<span class="out">2.0</span>
</pre>

  <p>
    Since the data structure is a list of lists,
    we need to use a loop within a loop.
    If we want to average the scores per subject,
    we would only need to make a small change to this code:
  </p>

<pre>
for entry in scores:
<span class="highlight">    total = 0.0
    number = 0</span>
    for value in entry:
        total += value
        number += 1
<span class="highlight">    average = total / number
    print average</span>
<hr/>
<span class="out">1.75
2.875
1.375</span>
</pre>

  <p class="continue">
    The important change here is that
    <code>total</code> and <code>number</code> are re-initialized
    and then reported
    <em>inside</em> the main loop,
    so that each subject's scores are calculated and printed separately.
  </p>

  <p>
    If we want to average corresponding scores for each subject,
    i.e.,
    get the average of each subject's zeroth score,
    then the average of their first score,
    and so on,
    the code suddenly becomes more complex.
    The reason is that
    while <code>scores[1]</code> is "all the scores associated with subject 1",
    there is no equally simple expression meaning
    "the first score associated with all subjects".
    (We will see a structure that allows us to do this <a href="numpy.html">later</a>.)
  </p>

  <p>
    Here's the code that averages corresponding scores across subjects:
  </p>

<pre id="a:average_scores">
scores = [ [1.5, 2.2, 1.7, 1.6],
           [2.8, 3.5, 3.6, 1.6],
           [1.3, 1.1, 1.7, 1.4] ]
for loc in range(len(scores[0])):
    total = 0.0
    number = 0
    for entry in scores:
        total += entry[loc]
        number += 1
    average = total / number
    print average
<hr/>
<span class="out">1.86666666667
2.26666666667
2.33333333333
1.53333333333</span>
</pre>

  <p class="continue">
    We will take a closer look at how and why it works in the challenges below.
  </p>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>Use nested lists to store multi-dimensional data or values that have regular internal structure (such as XYZ coordinates).</li>
      <li>Use <code><em>list_of_lists</em>[<em>first</em>]</code> to access an entire sub-list.</li>
      <li>Use <code><em>list_of_lists</em>[<em>first</em>][<em>second</em>]</code> to access a particular element of a sub-list.</li>
      <li>Use nested loops to process nested lists.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>

      <li>
        Trace the values of <code>loc</code>, <code>total</code>,
        <code>number</code>, <code>entry</code>, and <code>average</code>
        for each iteration of the loop in the 
        <a href="#a:average_scores">final code sample</a>
        in above.
        Why does the loop use the expression <code>range(len(scores[0]))</code>?
      </li>

      <li>
        A colleague has defined a 3&times;3 matrix like this:
<pre>
tensor = [ [0, 1, 2],
           [3, 4, 5],
           [6, 7, 8] ]
</pre>
        She then tries to transpose it like this:
<pre>
transpose = []
for i in [-1, -2, -3]:
    transpose.append(tensor[i])
</pre>
        What is the actual result?
      </li>

      <li>
        Fill in the blanks so that this program produces the output shown.
<pre>
final = []
for i in range(______):
    final.append(range(______))
print final
<hr/>
<span class="out">[[], [0], [0, 1]]</span>
</pre>
      </li>

      <li>
        What does this program do?
<pre>
alpha = [ [1, 2], [3, 4] ]
beta = [ [10, 20], [30, 40] ]
result = [ [0, 0], [0, 0] ]
for i in range(2):
    for j in range(2):
        for k in range(2):
            result[i][j] += alpha[i][k] * beta[k][j]
</pre>
        <ol>
          <li>Calculate the sums of the rows and columns of <code>alpha</code> and <code>beta</code>.</li>
          <li>Calculate the products of the elements the rows and columns of <code>alpha</code> and <code>beta</code>.</li>
          <li>Calculate the matrix product <code>alpha</code>&times;<code>beta</code></li>
          <li>Calculate the matrix product <code>beta</code>&times;<code>alpha</code></li>
        </ol>
      </li>

    </ol>

  </div>

</section>

<section id="s:alias">
  <h2>Aliasing</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Explain what an "alias" is.</li>
      <li>Explain why aliases are useful.</li>
      <li>Explain why aliases can make programs harder to understand.</li>
      <li>Identify examples in which aliasing does and does not occur.</li>
      <li>Construct programs which create aliases for data.</li>
      <li>Trace changes to data in programs that contain aliases.</li>
    </ul>
  </div>

  <p>
    At this point,
    we need to take a small side trip to explore something which is very useful,
    but which can also be the source of some hard-to-find bugs.
    Consider the following snippet of Python:
  </p>

<pre>
outer = [ [10, 20, 30], [40, 50, 60] ]
inner = outer[0]
</pre>

  <p class="continue">
    After these two lines have been executed,
    the program's memory is as shown in <a href="#f:aliasing_a">Figure 26</a>:
    <code>outer</code> refers to a two-element list
    containing references to a couple of three-element lists,
    while <code>inner</code> refers to the first of those three-element lists.
  </p>
  
  <figure id="f:aliasing_a">
    <img src="src/python/aliasing_a.png" alt="First Step of Aliasing Example" />
    <figcaption>Figure 26: First Step of Aliasing Example</figcaption>
  </figure>

  <p>
    Now let's change the last value of the list that <code>inner</code> refers to:
  </p>

<pre>
inner[2] = 99
</pre>

  <p class="continue">
    This changes memory as shown in <a href="#f:aliasing_b">Figure 27</a>,
    which means that the values of both <code>inner</code> <em>and</em> <code>outer</code>
    have changed:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">print inner</span>
<span class="out">[10, 20, 99]</span>
&gt;&gt;&gt; <span class="in">print outer</span>
<span class="out">[[10, 20, 99], [40, 50, 60]]</span>
</pre>

  <figure id="f:aliasing_b">
    <img src="src/python/aliasing_b.png" alt="Second Step of Aliasing Example" />
    <figcaption>Figure 27: Second Step of Aliasing Example</figcaption>
  </figure>

  <p>
    This is called <a href="glossary.html#alias">aliasing</a>.
    It is not a bug:
    the program is supposed to work this way.
    It doesn't have to, though;
    Python's creator could have decided that:
  </p>

<pre>
inner = outer[0]
</pre>

  <p class="continue">
    would create a copy of <code>outer[0]</code>
    and assign that to <code>inner</code>
    rather than aliasing the first element of <code>outer</code>
    (<a href="#f:aliasing_copy">Figure 28</a>).
    That would be easier to understand&mdash;there would be no chance that
    assigning to one variable would cause another variable's value to change&mdash;but
    it would also be less efficient.
    If our sublists contain a million elements each,
    and we're assigning them to temporary variables
    simply to make our program more readable,
    copying would cause unnecessary slow-down.
  </p>

  <figure id="f:aliasing_copy">
    <img src="src/python/aliasing_copy.png" alt="Copying Instead of Aliasing" />
    <figcaption>Figure 28: Copying Instead of Aliasing</figcaption>
  </figure>

  <p>
    When a programming language copies data,
    and when it creates aliases instead,
    is one of the most important things a programmer must know about it.
    As we'll see <a href="web.html">later</a>,
    it's also one of the most important things to know about large systems of any kind.
    If we query a database,
    is the result a copy of the data as it was when we made the query,
    or a reference to the master copy?
    In the first case,
    we can now change the data however we want without affecting other people,
    but we won't see any updates they make.
    In the second case,
    we will automatically see updates to the data,
    but that means our program has to cope with changes at unpredictable times
    (and also has to re-fetch the data each time it needs it,
    which will reduce performance).
    Neither approach is right or wrong:
    there are simply engineering tradeoffs that we have to be aware of.
  </p>

  <div class="box">
    <h3>Copying When You Want To</h3>

    <p>
      Python has a library called (naturally enough) <code>copy</code>
      that knows how to copy complex data structures.
      We will take a look at it <a href="#a:copy_library">later</a>
      once we have looked at how Python manages libraries in general.
    </p>
  </div>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>Several variables can alias the same data.</li>
      <li>If that data is mutable (e.g., a list), a change made through one variable is visible through all other aliases.</li>
    </ul>
  </div>

  <div id="c:alias">
    <h3>Challenges</h3>

    <ol>

      <li>
        Draw a diagram to show the state of memory
        after the two lines below have been executed.
<pre>
base = [1]
base.append(base)
</pre>
      </li>

      <li>
        Which program creates the memory layout shown in
        <a href="#f:memory_layout_challenge">Figure 29</a>?

        <figure id="f:memory_layout_challenge">
          <img src="python/memory_layout_challenge.png" alt="Memory Layout Challenge" />
          <figcaption>Figure 29: Memory Layout Challenge</figcaption>
        </figure>

        <table>
          <tr>
            <td valign="top">A</td>
            <td valign="top">
<pre>
alpha = [beta]
beta = [alpha]
</pre>
            </td>
          </tr>
          <tr>
            <td valign="top">B</td>
            <td valign="top">
<pre>
alpha = []
beta = []
alpha[0] = beta
beta[0] = alpha
</pre>
            </td>
          </tr>
          <tr>
            <td valign="top">C</td>
            <td valign="top">
<pre>
alpha = [beta] + alpha
</pre>
            </td>
          </tr>
          <tr>
            <td valign="top">D</td>
            <td valign="top">
<pre>
alpha = []
beta = []
alpha.append(beta)
beta.append(alpha)
</pre>
            </td>
          </tr>
        </table>
      </li>

      <li>
        Modify this program so that it prints
        <code>[[100, 200], [300, 400]]</code>.
<pre>
vector = [100, 200]
matrix = []
matrix.append(vector)
vector[0] = 300
vector[1] = 400
matrix.append(vector)
print matrix
</pre>
      </li>

      <li>
        These lines produce the output shown:
<pre>
readings = [0] * 3
readings[-1] = 'zero'
print readings
<hr/>
<span class="out">[0, 0, 'zero']</span>
</pre>
        By analogy,
        the author of these lines wanted to create a 3&times;3 matrix of zeroes
        with a single value set to the string <code>'zero'</code>.
        What has she actually produced,
        why does it work that way,
        and how can she change her code to get what she wants?
<pre>
vec = [0] * 3
mat = [vec] * 3
mat[-1][-1] = 'zero'
print mat
</pre>
      </li>

        </ol>

      </div>

    </section>

    <section id="s:funcalias">

      <h2>Aliasing in Functions</h2>

      <div class="understand" id="u:aliasing">
        <h3>Understand:</h3>
        <ul>
          <li>How and when aliasing will occur during function calls.</li>
        </ul>
      </div>

      <p>
        We said <a href="#a:call-stack">earlier</a> that
        values are copied into parameters whenever a function is called.
        But as we explained in the <a href="python.html#s:alias">previous chapter</a>,
        variables don't actually store values:
        they are actually just names that refer to values.
        To see what this means for our programs,
        here's a function that takes a string and a list as parameters,
        and appends something to both:
      </p>

<pre src="src/funclib/appender.py">
def appender(a_string, a_list):
    a_string = a_string + 'turing'
    a_list.append('turing')
</pre>

      <p class="continue">
        And here is some code to set up a pair of variables and call that function:
      </p>

<pre src="src/funclib/appender.py">
string_val = 'alan'
list_val = ['alan']
appender(string_val, list_val)
print 'string', string_val
print 'list', list_val
<span class="out">string alan
list ['alan', 'turing']</span>
</pre>

      <p>
        Why did the list change when the string didn't?
        To find out,
        let's trace the function's execution.
        Just before the call,
        the global frame has two variables
        that refer to a string and a list:
      </p>

      <figure id="f:append_before_call">
        <img src="python/append_before_call.png" alt="Before Appending" />
      </figure>

      <p class="continue">
        The call creates a new stack frame with aliases for those values:
      </p>

      <figure id="f:append_during_call">
        <img src="python/append_during_call.png" alt="While Appending" />
      </figure>

      <p>
        The <code>a_string&nbsp;+&nbsp;'turing'</code> creates a new string <code>'alanturing'</code>;
        assigning this to the variable <code>a_string</code>
        changes what that local variable refers to,
        but doesn't change what the global variable <code>string_val</code> refers to:
      </p>

      <figure id="f:append_new_string">
        <img src="python/append_new_string.png" alt="A New String" />
      </figure>

      <p>
        The statement <code>a_list.append('turing')</code>,
        however,
        actually modifies the list that <code>a_list</code> is pointing to:
      </p>

      <figure id="f:append_same_list">
        <img src="python/append_same_list.png" alt="But the Same List" />
      </figure>

      <p>
        But this is the same thing that the variable <code>list_val</code> in the caller is pointing to.
        When the function returns and the call frame is thrown away,
        the new string <code>'alanturing'</code> is therefore lost,
        because the only reference to it was in the function call's stack frame.
        The change to the list,
        on the other hand,
        is kept,
        because the function actually modified the list in place:
      </p>

      <figure id="f:append_final_state">
        <img src="python/append_final_state.png" alt="The Final State of Memory" />
      </figure>

      <p>
        Let's change one line in the function:
      </p>

<pre src="src/funclib/appender_2.py">
def appender(a_string, a_list):
    a_string = a_string + 'turing'
    <span class="highlight">a_list = a_list + ['turing']</span>
</pre>

      <p class="continue">
        and see what happens when we run the same experiment:
      </p>

<pre src="src/funclib/appender_2.py">
string_val = 'alan'
list_val = ['alan']
appender(string_val, list_val)
print 'string', string_val
print 'list', list_val
<span class="out">string alan
list ['alan']</span>
</pre>

      <p>
        The answer is different because
        concatenating (adding) two lists creates a new list,
        rather than modifying either of the lists being concatenated.
        As a result,
        the local variable <code>a_list</code> is the only thing that refers to the list
        <code>['alan', 'turing']</code>,
        so that value is discarded when the function finishes
        and <code>list_val</code>'s value is undisturbed.
      </p>

      <div class="box">
        <h3>Memory Models</h3>

        <p>
          Python's treatment of lists
          (and other mutable data that we'll see <a href="setdict.html">later</a>)
          isn't the only way to handle things.
          For example,
          MATLAB functions
          use a rule called <a href="glossary.html#copy-on-write">copy on write</a>.
          Initially,
          it creates aliases for arrays that are passed into functions.
          The first time a function assigns to an array,
          though,
          MATLAB clones the array
          and changes the clone rather than the original
          (<a href="#f:copy_on_write">Figure XXX</a>).
          This saves it from copying data when it doesn't need to,
          while guaranteeing that functions don't have side effects
          (which makes them easier to think about).
        </p>

        <figure id="f:copy_on_write">
          <img src="python/copy_on_write.png" alt="Copy on Write" />
        </figure>

        <p>
          Other languages have slightly different rules about scoping and aliasing.
          Together,
          those rules make up the language's
          <a href="glossary.html#memory-model">memory model</a>.
          Understanding that model is perhaps the most important step
          in understanding how programs written in the language actually work,
          and more importantly,
          how to debug them when they don't.
        </p>
      </div>

      <div class="keypoints" id="k:aliasing">
        <h3>Summary</h3>
        <ul>
          <li>Values are actually passed into functions by reference, which means that they are aliased.</li>
          <li>Aliasing means that changes made to a mutable object like a list inside a function are visible after the function call completes.</li>
        </ul>
      </div>

    </section>

    <section id="s:python:provenance">
      <h3>Provenance Revisited</h3>

      <p>
        As we said near the end of <a href="svn.html#provenance">the previous chapter</a>,
        if we put a string like:
      </p>

<pre>
$Revision: ...$
</pre>

      <p class="continue">
        in a file,
        Subversion can automatically update it
        each time we commit a change to that file.
        Let's add put <code>$Revision:$</code> in our program:
      </p>

<pre>
import sys
<span class="highlight">my_version = '$Revision: 143$'</span>
<span class="highlight">'Processed by check.py:', my_version</span>
have_seen_dashed_line = False
for line in data:
    if line.startswith('---'):
        have_seen_dashed_line = True
    elif have_seen_dashed_line:
        name, number, score = line.split()
        score = float(score)
        if (score &lt; 0.0) or (score &gt; 5.0):
            print 'Out of range:', name, number, score
<span class="out">Processed by check.py: $Revision: 143$
Out of range: range 2 7.5
Out of range: volume 1 -3.0</span>
</pre>

      <p>
        This is kind of handy:
        our output now automatically includes a description of who produced it&mdash;<em>exactly</em> who,
        i.e.,
        not just the name of the program,
        but also which version.
        To see why this is useful,
        let's rewrite the program so that it clips scores to lie inside 0&ndash;5
        instead of just reporting outlying values:
      </p>

<pre>
import sys
my_version = '$Revision: 143$'
'Processed by clip.py:', my_version
have_seen_dashed_line = False
for line in data:

    if have_seen_dashed_line:
        name, number, score = line.split()
        score = float(score)
        if score &lt; 0.0:
            print 0.0
        elif score &gt; 5.0:
            print 5.0
        else:
            print score

    else:
        print line.rstrip()
        if line.startswith('---'):
            have_seen_dashed_line = True
</pre>

      <div class="box">

        <h3>Ordering</h3>

        <p>
          Note that this version checked the <code>have_seen_dashed_line</code> flag first,
          then handles the case where the flag isn't yet true.
          Some people find this ordering easier to understand,
          because the "main" case that handles actual data comes first.
          Others prefer the original,
          arguing that the cases should appear in the order in which
          we expect the data to occur.
          It doesn't matter which we use,
          as long as we're consistent with our other loops.
        </p>

      </div>

      <p>
        When we run this program on the data that has invalid scores, it prints:
      </p>

<pre>
<span class="out"><span class="highlight">Processed by clip.py: $Revision: 143$</span>
Subject: 1782
Date:    2012-05-21
Test     Run  Score
----     ---  -----
range    1    3
<span class="highlight">range    2    5.0</span>
discrim  1    1
discrim  2    1
discrim  4    1.5
<span class="highlight">volume   1    0.0</span>
volume   2    4.0</span>
</pre>

      <p>
        The three most important lines are highlighted.
        Two of them&mdash;the data lines&mdash;have been cleaned up;
        the line at the very top tells us who did the cleaning up.
        This is another step in our march toward having a real data provenance system:
        now,
        if we discover a bug in a program,
        we can look at our files and see which ones had been processed by that program.
        As we'll see in the <a href="funclib.html">next chapter</a>,
        we can extend this further to carry provenance information forward through an entire pipeline.
      </p>

    </section>

    <section id="s:python:funcobj">

      <h3>Functions as Objects</h3>

      <p>
        An integer is just 32 or 64 bits of data that a variable can refer to,
        while a string is just a sequence of bytes that a variable can also refer to.
        Functions are just more bytes in memory&mdash;ones that happen to represent instructions.
        That means that variables can refer to them
        just as they can refer to any other data.
      </p>

      <p>
        This insight&mdash;the fact that code is just another kind of data,
        and can be manipulated like integers or strings&mdash;is
        one of the most useful and powerful in all computing.
        To understand why,
        let's have a closer look at what actually happens when we define a function:
      </p>

<pre src="src/funclib/threshold.py">
def threshold(signal):
    return 1.0 / sum(signal)
</pre>

      <p class="continue">
        These two lines tell Python that <code>threshold</code> is
        a function that returns one over the sum of the values in <code>signal</code>.
        When we define it,
        Python translates the statements in the function into a blob of bytes,
        then creates a variable called <code>threshold</code> and makes it point at that blob:
      </p>

      <figure id="f:defining_function">
        <img src="img/funclib/defining_function.png" alt="Defining a Function" />
      </figure>

      <p class="continue">
        This is not really any different from assigning the string <code>'alan turing'</code>
        to the variable <code>name</code>.
        the only difference is what's in the memory the variable points to.
      </p>

      <p>
        If <code>threshold</code> is just a reference to something in memory,
        we should be able to assign that reference to another variable.
        Sure enough,
        we can,
        and when we call the function via that newly-created alias,
        the result is exactly what we would get
        if we called the original function with the same parameters,
        because there's really only one function&mdash;it just has two names:
      </p>

<pre src="src/funclib/threshold.py">
data = [0.1, 0.4, 0.2]
print threshold(data)
<span class="out">1.42857</span>
t = threshold
print t(data)
<span class="out">1.42857</span>
</pre>

      <figure id="f:aliasing_function">
        <img src="img/funclib/aliasing_function.png" alt="Aliasing a Function" />
      </figure>

      <div class="box">
        <h3>Aliasing and Importing</h3>

        <p>
          We have created aliases for functions before without realizing it.
          When we execute <code>from math import sqrt as square_root</code>,
          we are loading the <code>math</code> module,
          then creating an alias called <code>square_root</code>
          for its function <code>sqrt</code>.
        </p>
      </div>

      <p>
        If a function is just another kind of data,
        and we can create an alias for it,
        can we put it in a list?
        More precisely,
        can we put a reference to a function in a list?
        Let's define two functions,
        <code>area</code> and <code>circumference</code>,
        each of which takes a circle's radius as a parameter and returns the appropriate value:
      </p>

<pre src="src/funclib/funclist.py">
def area(r):
    return pi * r * r

def circumference(r):
    return 2 * pi * r
</pre>

      <p class="continue">
        Once those functions are defined, we can put them into a list
        (more precisely, put references to them in a list):
      </p>

<pre src="src/funclib/funclist.py">
funcs = [area, circumference]
</pre>

      <figure id="f:list_of_functions">
        <img src="img/funclib/list_of_functions.png" alt="A List of Functions" />
      </figure>

      <p>
        We can now loop through the functions in the list,
        calling each in turn.
        Sure enough,
        the output is what we would get if we called <code>area</code>
        and then <code>circumference</code>:
      </p>

<pre src="src/funclib/funclist.py">
for f in funcs:
    print f(1.0)
<span class="out">3.14159
6.28318</span>
</pre>

      <p>
        Let's go a little further.
        Instead of storing a reference to a function in a list,
        let's pass that reference into another function,
        just as we would pass a reference to an integer, a string, or a list.
        Here's a function called <code>call_it</code> that takes two parameters:
        a reference to some other function, and some other value.
      </p>

<pre src="src/funclib/passfunc.py">
def call_it(func, value):
    return func(value)
</pre>

      <p class="continue">
        All <code>call_it</code> does is call that other function with the given value as a parameter:
      </p>

<pre src="src/funclib/passfunc.py">
print call_it(area, 1.0)
<span class="out">3.14159</span>

print call_it(circumference, 1.0)
<span class="out">6.28318</span>
</pre>

      <p>
        Now it's time for the payoff.
        Here's a function called <code>do_all</code>
        that applies a function&mdash;anything at all that takes one argument&mdash;to
        each value in a list,
        and returns a list of the results:
      </p>

<pre src="src/funclib/doall.py">
def do_all(func, values):
    result = []
    for v in values:
        temp = func(v)
        result.append(temp)
    return result
</pre>

      <p>
        If we call <code>do_all</code> with <code>area</code> and a list of numbers,
        we get what we would get if we called <code>area</code> directly on each number in turn:
      </p>

<pre src="src/funclib/doall.py">
print do_all(area, [1.0, 2.0, 3.0])
<span class="out">[3.14159, 12.56636, 28.27431]</span>
</pre>

      <p class="continue">
        And if we define a function to "slim down" strings of text
        by throwing away their first and last characters,
        we can apply it to every string in a list,
        without having to write another copy of the code that loops through the list,
        calls the function,
        and concatenates the results:
      </p>

<pre src="src/funclib/doall.py">
def slim(text):
    return text[1:-1]

print do_all(slim, ['abc', 'defgh'])
<span class="out">b efg</span>
</pre>

      <p>
        Functions that operate on other functions are called
        <a href="glossary.html#higher-order-functions">higher-order functions</a>.
        They're common in mathematics:
        integration,
        for example,
        is a function that operates on some other function.
        In programming,
        higher-order functions allow us to mix and match pieces of code
        rather than duplicating them.
      </p>

      <p>
        As another example,
        let's look at <code>combine_values</code>,
        which takes a function and a list of values as parameters,
        and combines the values in the list using the function provided:
      </p>

<pre src="src/funclib/combine.py">
def combine_values(func, values):
    current = values[0]
    for i in range(1, len(values)):
        current = func(current, values[i])
    return current
</pre>

      <p class="continue">
        Now let's define <code>add</code> and <code>mul</code> to add and multiply values:
      </p>

<pre src="src/funclib/combine.py">
def add(x, y):
    return x + y

def mul(x, y):
    return x * y
</pre>

      <p class="continue">
        If we combine 1, 3, and 5 with <code>add</code>, we get their sum, 9:
      </p>

<pre src="src/funclib/combine.py">
print combine_values(add, [1, 3, 5])
<span class="out">9</span>
</pre>

      <p class="continue">
        If we combine the same values with <code>mul</code>, we get their product, 15:
      </p>

<pre src="src/funclib/combine.py">
print combine_values(mul, [1, 3, 5])
<span class="out">15</span>
</pre>

      <p class="continue">
        This same higher-order function <code>combine_values</code> could concatenate lists of strings, too,
        or multiply several matrices together, or whatever else we wanted,
        without us having to write or test the loop ever again.
        Without higher-order functions,
        we would have to  write one function for each combination of data structure and operation,
        i.e.,
        one function to add numbers,
        another to concatenate strings,
        a third to sum matrices,
        and so on.
        <em>With</em> higher-order functions,
        on the other hand,
        we only write one function for each basic operation,
        and one function for each kind of data structure.
        Since A plus B is usually a lot smaller than A times B,
        this saves us coding, testing, reading, and debugging.
      </p>

      <p>
        Several higher-order functions are built in to Python.
        One is <code>filter</code>,
        which constructs a new list containing all the values in an original list
        for which some function is true:
      </p>

<pre src="src/funclib/hof.py">
def positive(x):
    return x &gt; 0

print filter(positive, [-5, 3, -2, 9, 0])
<span class="out">[3, 9]</span>
</pre>

      <p class="continue">
        Another is <code>map</code>,
        which applies a function to every element of a list and returns a list of results:
      </p>

<pre src="src/funclib/hof.py">
def bump(x):
    return x + 10

print map(bump, [-5, 3, -2, 9, 0])
<span class="out">[5, 13, 8, 19, 10]</span>
</pre>

      <p class="continue">
        And then there's <code>reduce</code>,
        which combines values using a binary function,
        returning a single value as a result:
      </p>

<pre src="src/funclib/hof.py">
def add(x, y):
    return x + y

print reduce(add, [-5, 3, -2, 9, 0])
<span class="out">5</span>
</pre>

      <p>
        Combining all of these is a very powerful way to do a lot of computation
        with very little typing:
      </p>

<pre src="src/funclib/hof.py">
print reduce(add, map(bump, filter(positive, [-5, 3, -2, 9, 0])))
<span class="out">32</span>
</pre>

      <p class="continue">
        Reading from the inside out, we have:
      </p>

      <ol>
        <li>
          filtered the list, keeping only the positive values,
        </li>
        <li>
          bumped them up by 10, and
        </li>
        <li>
          summed the results.
        </li>
      </ol>

      <p class="continue">
        Written out, this is:
      </p>

<pre src="src/funclib/hof.py">
total = 0
for val in [-5, 3, -2, 9, 0]:
    if val &gt; 0:
        total += (val + 10)
print total
</pre>

      <p>
        The functional approach is usually more economical,
        and isn't too bad to read once calls are indented:
      </p>

<pre>
print reduce(add,
             map(bump,
             filter(positive,
                    [-5, 3, -2, 9, 0])))
</pre>

      <p class="continue">
        However,
        the all-in-one-loop approach <em>is</em> faster,
        since each call in the functional approach is creating its own temporary list of results,
        only to have it discarded by the next function in the chain.
        As always,
        we should only worry about this once we are sure that
        (a) the program is working correctly,
        and (b) its performance really is a problem.
      </p>

      <div class="box">
        <h3>List Comprehensions</h3>
        <p class="fixme">explain list comprehensions</p>
      </div>

      <div class="keypoints" id="k:funcobj">
        <h3>Summary</h3>
        <ul>
          <li idea="turing">A function is just another kind of data.</li>
          <li>Defining a function creates a function object and assigns it to a variable.</li>
          <li>Functions can be assigned to other variables, put in lists, and passed as parameters.</li>
          <li>Writing higher-order functions helps eliminate redundancy in programs.</li>
          <li>Use <code>filter</code> to select values from a list.</li>
          <li>Use <code>map</code> to apply a function to each element of a list.</li>
          <li>Use <code>reduce</code> to combine the elements of a list.</li>
        </ul>
      </div>

    </section>

</section>

<section id="s:web">
  <h2>Web Programming in Python</h2>
  
  <section id="s:web:reading">
    <h3>Reading Documents</h3>

    <p>
      People usually write their home pages by hand,
      but most pages that display lists of experimental results,
      or second-hand lab equipment for sale,
      are created by programs.
      For historical reasons,
      Python's standard library includes several libraries that process XML (including HTML);
      we'll use the simplest one,
      called <code>ElementTree</code>,
      but you will often run into programs that use others.
    </p>

    <p>
      Most of these libraries represent the nested structure of XML using something called
      the <a href="glossary.html#document-object-model">Document Object Model</a> (DOM).
      This stores the document as a <a href="glossary.html#tree">tree</a>
      with one node for each element or block of text.
      The root element of the document,
      such as the all-enclosing <code>html</code> in a web page,
      is the root node of the tree.
      Every other element or block of text is a child of it,
      or a child of a child,
      and so on.
      For example,
      the tree representing our web page about dimorphism
      looks like <a href="#f:dimorphism_tree">Figure XXX</a>.
    </p>

    <figure id="f:dimorphism_tree">
      <img src="img/web/dimorphism_tree.png" alt="Tree Representation of Dimorphism Page" />
      <figcaption>Tree Representation of Dimorphism Page</figcaption>
    </figure>

    <p>
      There are basically two ways to create a tree like this:
      parse a string (or file) containing XML,
      or build the nodes one by one and put them together manually.
      The former is more common,
      since the usual way to store and exchange XML or HTML is as text,
      so we will explore that first.
      Let's begin by turning text into HTML and then back into text:
    </p>

<pre src="src/web/parse_simple_page.py">
import xml.etree.ElementTree as ET

page = '''&lt;html&gt;
  &lt;body&gt;
    &lt;h1&gt;Dimorphism&lt;/h1&gt;
    &lt;p class="definition"&gt;Occurring or existing in two different &lt;u&gt;forms&lt;/u&gt;.&lt;/p&gt;
    &lt;p&gt;
      The most notable form is sexual dimorphism,
      in which males and females have noticeably different appearances.
    &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;'''

doc = ET.fromstring(page)
text = ET.tostring(doc, 'utf-8')
print text
</pre>

    <p class="continue">
      We start by importing the <code>xml.etree.ElementTree</code> library
      and giving it the alias <code>ET</code>
      (which is a lot easier to type and read).
      The multi-line string assigned to the variable <code>page</code>
      is the "document" we will parse;
      most real programs will read data from a file instead.
    </p>

    <p>
      Parsing itself takes just a single call to <code>ET.fromstring</code>;
      it returns the root node of the DOM tree corresponding to that document.
      We then convert that tree back to text by calling <code>ET.tostring</code>.
      The <code>'utf-8'</code> argument specifies how we want characters represented;
      you should always use this option unless you know enough to know
      that you want something else.
      <span class="fixme">need a better explanation than this</span>
    </p>

    <p>
      The program's output is:
    </p>

<pre><span class="out">&lt;html&gt;
  &lt;body&gt;
    &lt;h1&gt;Dimorphism&lt;/h1&gt;
    &lt;p class="definition"&gt;Occurring or existing in two different &lt;u&gt;forms&lt;/u&gt;.&lt;/p&gt;
    &lt;p&gt;
      The most notable form is sexual dimorphism,
      in which males and females have noticeably different appearances.
    &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</span>
</pre>

    <p class="continue">
      which is exactly what we started with.
    </p>

    <p class="fixme">point out how much simpler this is than parsing...</p>

    <p>
      In the example above,
      our output was exactly the same as our input,
      but that won't always be the case.
      Here's another simple program that converts text to a node tree and back:
    </p>

<pre src="src/web/round_trip.py">
import xml.etree.ElementTree as ET

original = '''&lt;root&gt;&lt;node
                     front="1"
                     back="2"&gt;content&lt;/node&gt;&lt;/root&gt;'''


doc = ET.fromstring(original)
print ET.tostring(doc, 'utf-8')
<span class="out">&lt;root&gt;&lt;node back="2" front="1"&gt;content&lt;/node&gt;&lt;/root&gt;</span>
</pre>

    <p class="continue">
      <code>node</code>'s attributes are all on one line in the output,
      and in a different order than they were in the input.
      The reason for the first difference is that XML ignores whitespace inside elements:
      the parser simply throws away
      the extra spaces and newlines inside the definition of <code>&lt;node&hellip;&gt;</code>.
      The reason for the second is that attributes are treated as a dictionary,
      and dictionary keys are unordered.
      As far as the rules of XML are concerned,
      the input and output are the same thing.
      Unfortunately,
      as far as string comparison and tools like <code>diff</code> are concerned,
      they are not.
    </p>

    <p>
      Since almost all XML or HTML documents are stored in files,
      the ElementTree library provides a convenience function
      that parses files directly.
      If <code>dimorphism.html</code> contains our definition of sexual dimorphism,
      then:
    </p>

<pre>
import xml.etree.ElementTree as ET
doc = ET.parse('dimorphism.html')
</pre>

    <p class="continue">
      reads the text in that file,
      converts it to a DOM tree,
      and returns the tree's root node.
    </p>

  </section>

  <section id="s:web:search">
    <h3>Finding Nodes</h3>

    <p>
      Most databases are read more often than they're written,
      so most of <a href="db.html">our discussion of SQL</a>
      focuses on finding things.
      Most web pages are read more than once too,
      so libraries like ElementTree provide tools for locating nodes of interest.
      The most important of these is the <code>findall</code> method,
      which searches all the children of a node
      to find ones that match a pattern.
      For example,
      if some molecular formulas are stored like this:
    </p>

<pre src="src/web/molecular_formulas.xml">
&lt;formulas&gt;
  &lt;formula name="ammonia"&gt;
    &lt;atom symbol="N" number="1"/&gt;
    &lt;atom symbol="H" number="3"/&gt;
  &lt;/formula&gt;
  &lt;formula name="water"&gt;
    &lt;atom symbol="H" number="2"/&gt;
    &lt;atom symbol="O" number="1"/&gt;
  &lt;/formula&gt;
  &lt;formula name="methanol"&gt;
    &lt;atom symbol="C" number="1"/&gt;
    &lt;atom symbol="O" number="1"/&gt;
    &lt;atom symbol="H" number="4"/&gt;
  &lt;/formula&gt;
&lt;/formulas&gt;
</pre>

    <p class="continue">
      then this program will count how many formulas there are:
    </p>

<pre src="src/web/count_formulas.py">
import sys
import xml.etree.ElementTree as ET

doc = ET.parse(sys.argv[1])
root = doc.getroot()
formulas = root.findall("./formula")
print len(formulas)
<span class="out">3</span>
</pre>

    <p>
      The key to this programs is <code>root.findall("./formula")</code>.
      The pattern <code>"./formula"</code> means,
      "Starting with this node ('.'),
      examine its children ('/')
      for elements with the tag 'formula."
      The result of the <code>findall</code> call is a list of nodes that match.
    </p>

    <p>
      The mini-language used for patterns is called
      <a href="glossary.html#xpath">XPath</a>.
      Some parts,
      like '.' and '/',
      are deliberately reminiscent of the way paths are described in
      <a href="shell.html#s:filedir">the Unix filesystem</a>.
      Other parts are more complicated,
      but it's possible to do a lot without using them.
      Some common XPath expressions are:
    </p>

    <table>
      <tr>
        <td>
          <code>tag</code>
        </td>
        <td>
          All immediate children with the given tag.
          <code>formula</code> selects all child <code>formula</code> elements,
          and <code>formula/atom</code> selects all <code>atom</code> elements
          that are children of <code>formula</code> children.
        </td>
      </tr>
      <tr>
        <td>
          <code>*</code>
        </td>
        <td>
          All child elements.
          <code>*/atom</code> selects all grandchild <code>atom</code> elements,
          regardless of what the intervening parent is.
        </td>
      </tr>
      <tr>
        <td>//</td>
        <td>
          All subelements on all levels beneath the current element.
          <code>.//atom</code> selects all <code>atoms</code> elements in the entire tree.
        </td>
      </tr>
      <tr>
        <td><code>.</code></td>
        <td>
          The current node.
          It is mostly used at the beginning of a path to indicate that it is a relative path.
        </td>
      </tr>
      <tr>
        <td><code>..</code></td>
        <td>The parent of the current node.</td>
      </tr>
      <tr>
        <td><code>[@attrib]</code></td>
        <td>
          All elements with the given attribute (regardless of that attribute's value).
          <code>.//atom[@name]</code> selects all atoms in the tree
          that have a <code>name</code> attribute,
          but not any <code>atom</code> elements that are missing that attribute.
        </td>
      </tr>
      <tr>
        <td>
          <code>[@attrib="value"]</code>
        </td>
        <td>
          All elements for which the given attribute has the given value.
          <code>.//atom[@symbol="C"]</code> finds all carbon atoms.
        </td>
      </tr>
      <tr>
        <td>
          <code>[tag]</code>
        </td>
        <td>
          All elements that have a child element with the given tag.
          <code>atom[comment]</code> finds all <code>atom</code> nodes
          that have an immediate child of type <code>comment</code>.
        </td>
      </tr>
      <tr>
        <td>
          <code>[position]</code>
        </td>
        <td>
          All elements that located in the given position relative to their parent.
          The position can be either an integer (1 is the first position),
          the expression <code>last()</code> for the last position,
          or a position relative to <code>last()</code>,
          such as <code>last()-1</code>.
        </td>
      </tr>
    </table>

    <p>
      Let's use these expressions to check that a data file is properly formatted
      by looking for all the <code>atom</code> nodes
      that are <em>not</em> immediate children of <code>formula</code> nodes.
      Our data file is:
    </p>

<pre src="src/web/bad_formulas.xml">
&lt;formulas&gt;
  &lt;formula name="ammonia"&gt;
    &lt;atom symbol="N" number="1"/&gt;
    &lt;atom symbol="H" number="3"/&gt;
  &lt;/formula&gt;
  &lt;atom symbol="H" number="2"/&gt;       <span class="comment">&lt;!-- mistake! --&gt;</span>
  &lt;formula name="water"&gt;
    &lt;atom symbol="O" number="1"&gt;
      &lt;atom symbol="H" number="2"/&gt;   <span class="comment">&lt;!-- another mistake --&gt;</span>
    &lt;/atom&gt;
  &lt;/formula&gt;
&lt;/formulas&gt;
</pre>

    <p class="continue">
      and our program is:
    </p>

<pre src="src/web/validate_doc.py">
import xml.etree.ElementTree as ET

doc = ET.parse('bad_formulas.xml')
all_atoms = doc.findall('.//atom')
proper_atoms = doc.findall('.//formula/atom')
wrongly_placed = set(all_atoms) - set(proper_atoms)
for atom in wrongly_placed:
    print ET.tostring(atom)
<span class="out">&lt;atom number="2" symbol="H" /&gt;

&lt;atom number="2" symbol="H" /&gt;

</span>
</pre>

    <p class="continue">
      After converting the XML document to a tree,
      this program uses <code>doc.findall</code> to get all of the <code>atom</code> nodes,
      and then uses it again to find all the <code>atom</code> nodes
      that are immediate children of <code>formula</code> nodes.
      Subtracting the second set from the first
      gives the nodes that are <em>not</em> immediate children of <code>formula</code> nodes,
      i.e.,
      that are in the wrong place.
    </p>

    <p>
      A couple of things are worth pointing out about this program.
      First,
      the ElementTree library doesn't record where in the document nodes are from,
      so we can't pinpoint the line or character position of the offending nodes.
      Second,
      the double-spacing on the output comes from the fact that
      our original document contained lots of whitespace
      to make it easier for human beings to read,
      and ElementTree kept this whitespace
      (storing it as the <code>tail</code> value for various nodes).
      This kind of extra whitespace is always an annoyance when we're programming,
      so it's tempting to leave it out.
      However,
      doing so makes it harder for human beings to read the raw XML
      using line-oriented editors.
      Most modern browsers will display the XML as a tree
      (<a href="#f:xml_in_browser">Figure XXX</a>)
      but native XML-oriented editing tools are still clumsy.
    </p>

    <figure id="f:xml_in_browser">
      <img src="img/web/xml_in_browser.png" alt="XML in the Browser" />
      <figcaption>XML in the Browser</figcaption>
    </figure>

  </section>

  <section id="s:web:creating">
    <h3>Creating Documents</h3>

    <p>
      So much for reading XML: how do we create it?
      Let's start by writing a program that re-creates our dimorphism page
      one element at time:
    </p>

<pre src="src/web/build_simple_page.py">
import xml.etree.ElementTree as ET

root = ET.Element('html')

body = ET.Element('body')
root.append(body)

title = ET.SubElement(body, 'h1')
title.text = 'Dimorphism'

p1 = ET.SubElement(body, 'p')
p1.text = 'Occurring or existing in two different '
u = ET.SubElement(p1, 'u')
u.text = 'forms'
p1.tail = '.'

long_text = '''The most notable form is sexual dimorphism,
in which males and females have noticeably different appearances.'''
ET.SubElement(body, 'p').text = long_text

print ET.tostring(root)
</pre>

    <p>
      There is much less to this program than first appears.
      It starts by creating an object of type <code>Element</code>,
      which is the class the ElementTree library uses to represent nodes.
      The argument to <code>Element</code>'s constructor,
      <code>html</code>,
      specifies the element's type.
    </p>

    <p>
      The next two lines create another node of type <code>body</code>
      and then append that to the root node.
      At this point, our tree looks like
      <a href="#f:partial_tree">Figure XXX</a>:
    </p>

    <figure id="f:partial_tree">
      <img src="img/web/partial_tree.png" alt="Partially-Constructed Tree" />
      <figcaption>Partially-Constructed Tree</figcaption>
    </figure>

    <p>
      The rest of the program does little more than create and append nodes.
      Because creating a node and appending it to another one is so common,
      ElementTree provides a convenience function called <code>SubElement</code>
      which combines the two steps.
      The two lines:
    </p>

<pre>
title = ET.SubElement(body, 'h1')
title.text = 'Dimorphism'
</pre>

    <p class="continue">
      create a new node of type <code>h1</code>,
      append it to the <code>body</code> node,
      and then set the text content of the title node to be the string <code>'Dimorphism'</code>.
    </p>

    <p>
      The next step is the most complicated.
      We need to create a paragraph node
      whose <code>class</code> attribute has the value <code>definition</code>,
      and which contains three things:
    </p>

    <ol>
      <li>
        the text <code>'Occurring or existing in two different&nbsp;'</code>
        (with a space at the end);
      </li>
      <li>
        a <code>u</code> element containing the text <code>'forms'</code>;
        and
      </li>
      <li>
        another piece of text containing the period '.' that ends the sentence.
      </li>
    </ol>

    <p>
      Creating the paragraph node and appending it to our body node is easy:
      we just call <code>SubElement</code>.
      Setting an attribute is also easy:
      every node has a dictionary called <code>attrib</code>
      whose keys are attribute names
      and whose values are those attributes' values.
      The single line:
    </p>

<pre>
p1.attrib['class'] = 'definition'
</pre>

    <p class="continue">
      therefore creates the attribute we want.
    </p>

    <p>
      Now for the paragraph's content.
      Again, the first part is easy:
      we just set <code>p1.text</code>.
      And underlining the word "forms" is easy too:
      we create a node of type <code>u</code> and append it to the paragraph.
      But where should the closing period be stored?
    </p>

    <p>
      Along with <code>text</code>,
      ElementTree nodes have another text field called <code>tail</code>,
      which stores the text <em>after</em> the node
      but before the start of anything else.
      Since the period is in the paragraph,
      the right place to store it is therefore <code>u.tail</code>
      (since putting it in <code>p1.tail</code> would imply that
      it came after the end of the first paragraph,
      but before the start of the next paragraph).
    </p>

    <p>
      Finally,
      we create the second paragraph that elaborates dimorphism's definition
      by combining node creation and text setting in a single line:
    </p>

<pre>
ET.SubElement(body, 'p').text = long_text
</pre>

    <p class="continue">
      This works because <code>SubElement</code> returns the node it just created,
      so we can immediately set its <code>text</code> value.
    </p>

    <figure id="f:final_tree">
      <img src="img/web/final_tree.png" alt="Final Tree" />
      <figcaption>Final Tree</figcaption>
    </figure>

    <p>
      In memory,
      our document is now something like <a href="#f:final_tree">Figure XXX</a>.
      If we convert it to text,
      we get:
    </p>

<pre>
<span class="out">&lt;html&gt;&lt;body&gt;&lt;h1&gt;Dimorphism&lt;/h1&gt;&lt;p class="definition"&gt;Occurring or existing in two&crarr;
different &lt;u&gt;forms&lt;/u&gt;.&lt;/p&gt;&lt;p&gt;The most notable form is sexual dimorphism,
in which males and females have noticeably different appearances.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</span>
</pre>

    <p class="continue">
      (As before, we use &crarr; to break a line that's too long to fit on the screen.)
      This has all the content we created,
      but <em>only</em> that content.
      We didn't create text nodes containing carriage returns and blanks,
      so <code>tostring</code> didn't insert them.
      Most machine-generated XML isn't nicely indented
      because computers don't care,
      but XML intended for human beings to read usually is.
    </p>

    <p>
      in practice,
      of course,
      programs usually wrap all these steps up in functions.
      For example,
      this function converts a Python list into an HTML ordered list:
    </p>

<pre src="src/web/list_to_ol.py">
import xml.etree.ElementTree as ET

def convert(values):
    '''Convert a list of values to an &lt;ol&gt; list.'''

    result = ET.Element('ol')
    for v in values:
        ET.SubElement(result, 'li').text = str(v)
    return result

root = convert([1, "two", 3.4])
print ET.tostring(root)
<span class="out">&lt;ol&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;two&lt;/li&gt;&lt;li&gt;3.4&lt;/li&gt;&lt;/ol&gt;</span>
</pre>

    <p>
      The line:
    </p>

<pre>
        ET.SubElement(result, 'li').text = str(v)
</pre>

    <p class="continue">
      does two things at once.
      First,
      it creates a new <code>li</code> (list element) node and returns it.
      Second,
      it sets the <code>text</code> of that node to be
      the string representation of the next list value.
      What it <em>doesn't</em> do is store a reference to that node in a separate variable.
      We could do this,
      as in:
    </p>

<pre>
    for v in values:
        node = ET.SubElement(result, 'li')
        node.text = str(v)
</pre>

    <p class="continue">
      It's a matter of taste which is less unreadable,
      but since we're about to see a different approach that most people find better anyway,
      the question is moot.
    </p>

  </section>
</section>

<section id="s:db">
  <h2>Databases</h2>

  <section id="s:db:design">
    <h3>Database Design</h3>

    <p>
      Let's go back to sorting for a moment,
      and see if we can produce a list of scientists
      ordered by family name.
      We want our output to look like this:
    </p>

    <table class="outlined">
      <tr><td>Kovalevskaya, Sofia</td></tr>
      <tr><td>Lomonosov, Mikhail</td></tr>
      <tr><td>Mendeleev, Dmitri</td></tr>
      <tr><td>Pavlov, Ivan</td></tr>
    </table>

    <p>
      This is easy to do in a programming language like Python:
      we just split the names on the space character,
      then join the two parts using a comma and a space.
    </p>

<pre>
result = []
for name in list_of_names:
    personal_name, family_name = name.split(' ')
    new_name = family_name + ', ' + personal_name
    result.append(new_name)
result.sort()
</pre>

    <p>
      We can do something like this in some dialects of SQL, but not all,
      and even when we can, it's harder to read.
      For example, if we're using Microsoft SQL Server, the query we need is:
    </p>

<pre>
SELECT SUBSTRING(Scientist, 1, CHARINDEX(Scientist, " ")-1)
       || ", "
       || SUBSTRING(Scientist, CHARINDEX(Scientist, " ")+1, LEN(Scientist))
       FROM Experiments;
</pre>

    <p class="continue">
      Here,
      <code>CHARINDEX</code> and <code>SUBSTRING</code> are built-in functions
      that find the locations of characters and take substrings respectively,
      and <code>||</code> concatenates strings.
      This won't work as written with other databases,
      though,
      since their equivalents of <code>CHARINDEX</code> have different names
      (or, in the case of SQLite, may not exist at all).
      And even when it does work, it's still not a complete solution,
      since it doesn't sort the names.
    </p>

    <p>
      We could get further by using <a href="#s:nested">nested queries</a>,
      which we will discuss later in this chapter,
      but the right solution is to reformulate the problem.
      What we're trying to do is difficult because
      we have violated one of the fundamental rules of database design.
      The values in the <code>Scientist</code> field have several parts that we care about;
      in technical terms,
      they are not <a href="glossary.html#atomic-value">atomic values</a>.
      In a well-designed database,
      every value <em>is</em> atomic,
      so that it can be accessed directly.
    </p>

    <p>
      Here's what our table looks like when we split names into their component parts:
    </p>

    <table class="outlined" src="db/create_single_table_experiments.sql">
      <tr><td colspan="4" align="center"><strong>Experiments</strong></td></tr>
      <tr>
        <td><strong>PersonalName</strong></td>
        <td><strong>FamilyName</strong></td>
        <td><strong>Project</strong></td>
        <td><strong>Hours</strong></td>
      </tr>
      <tr>
        <td>Sofia</td>
        <td>Kovalevskaya</td>
        <td>Antigravity</td>
        <td>6.5</td>
      </tr>
      <tr>
        <td>Sofia</td>
        <td>Kovalevskaya</td>
        <td>Teleportation</td>
        <td>11.0</td>
      </tr>
      <tr>
        <td>Sofia</td>
        <td>Kovalevskaya</td>
        <td>Teleportation</td>
        <td>5.0</td>
      </tr>
      <tr>
        <td>Mikhail</td>
        <td>Lomonosov</td>
        <td>Antigravity</td>
        <td>4.0</td>
      </tr>
      <tr>
        <td>Mikhail</td>
        <td>Lomonosov</td>
        <td>Time Travel</td>
        <td>-2.0</td>
      </tr>
      <tr>
        <td>Dmitri</td>
        <td>Mendeleev</td>
        <td>Antigravity</td>
        <td>9.0</td>
      </tr>
      <tr>
        <td>Ivan</td>
        <td>Pavlov</td>
        <td>Teleportation</td>
        <td>9.0</td>
      </tr>
      <tr>
        <td>Ivan</td>
        <td>Pavlov</td>
        <td>Time Travel</td>
        <td>-7.0</td>
      </tr>
    </table>

    <p class="continue">
      It looks like a small change, but it has major implications.
      First, it makes the SQL simpler,
      since we no longer have to do substring operations to get values:
    </p>

<pre make="select-distinct-names">
SELECT DISTINCT FamilyName || ", " || PersonalName FROM Experiments;
</pre>

    <p class="continue">
      Second,
      this SQL will be much more efficient,
      since repeatedly finding substrings takes more time than simply matching values directly.
    </p>

    <p>
      Our redesigned table still violates an important rule of database design.
      To see how,
      let's look at what happens if we want to store people's email addresses:
    </p>

    <table class="outlined" src="db/create_single_table_experiments.sql">
      <tr><td colspan="5" align="center"><strong>Experiments</strong></td></tr>
      <tr>
        <td><strong>PersonalName</strong></td>
        <td><strong>FamilyName</strong></td>
        <td><strong>Email</strong></td>
        <td><strong>Project</strong></td>
        <td><strong>Hours</strong></td>
      </tr>
      <tr>
        <td>Sofia</td>
        <td>Kovalevskaya</td>
        <td>skol@euphoric.edu</td>
        <td>Antigravity</td>
        <td>6.5</td>
      </tr>
      <tr>
        <td>Sofia</td>
        <td>Kovalevskaya</td>
        <td>skol@euphoric.edu</td>
        <td>Teleportation</td>
        <td>11.0</td>
      </tr>
      <tr>
        <td>Sofia</td>
        <td>Kovalevskaya</td>
        <td>skol@euphoric.edu</td>
        <td>Teleportation</td>
        <td>5.0</td>
      </tr>
      <tr>
        <td>Mikhail</td>
        <td>Lomonosov</td>
        <td>mikki@freesci.org</td>
        <td>Antigravity</td>
        <td>4.0</td>
      </tr>
      <tr>
        <td>Mikhail</td>
        <td>Lomonosov</td>
        <td>mikki@freesci.org</td>
        <td>Time Travel</td>
        <td>-2.0</td>
      </tr>
      <tr>
        <td>Dmitri</td>
        <td>Mendeleev</td>
        <td>mendeleev@euphoric.edu</td>
        <td>Antigravity</td>
        <td>9.0</td>
      </tr>
      <tr>
        <td>Ivan</td>
        <td>Pavlov</td>
        <td>pablum@euphoric.edu</td>
        <td>Teleportation</td>
        <td>9.0</td>
      </tr>
      <tr>
        <td>Ivan</td>
        <td>Pavlov</td>
        <td>pablum@euphoric.edu</td>
        <td>Time Travel</td>
        <td>-7.0</td>
      </tr>
    </table>

    <p>
      There's a lot of redundancy in this table:
      every time "Sofia" appears as a personal name,
      the family name is always "Kovalevskaya",
      and the email address is always "skol@euphoric.edu".
      If we use this design,
      we will have to eliminate duplicates almost every time we run a query,
      and if Sofia changes her email address,
      we will have to update several rows of the database.
    </p>

    <p>
      The right way to store this data is
      to separate information about scientists
      from information about experiments,
      so that no fact is ever duplicated.
      We can do this by splitting our table in two:
    </p>

    <table class="outlined">
      <tr><td colspan="3" align="center"><strong>Experiments</strong></td></tr>
      <tr><td>skol</td><td>Antigravity</td><td>6.5</td></tr>
      <tr><td>skol</td><td>Teleportation</td><td>11.0</td></tr>
      <tr><td>skol</td><td>Teleportation</td><td>5.0</td></tr>
      <tr><td>mlom</td><td>Antigravity</td><td>4.0</td></tr>
      <tr><td>mlom</td><td>Time Travel</td><td>-2.0</td></tr>
      <tr><td>dmen</td><td>Antigravity</td><td>9.0</td></tr>
      <tr><td>ipav</td><td>Teleportation</td><td>9.0</td></tr>
      <tr><td>ipav</td><td>Time Travel</td><td>-7.0</td></tr>
    </table>

    <table class="outlined">
      <tr><td colspan="4" align="center"><strong>Scientists</strong></td></tr>
      <tr><td>skol</td><td>Kovalevskaya</td><td>Sofia</td><td>skol@euphoric.edu</td></tr>
      <tr><td>mlom</td><td>Lomonosov</td><td>Mikhail</td><td>mikki@freesci.org</td></tr>
      <tr><td>dmen</td><td>Mendeleev</td><td>Dmitri</td><td>mendeleev@euphoric.edu</td></tr>
      <tr><td>ipav</td><td>Pavlov</td><td>Ivan</td><td>pablum@euphoric.edu</td></tr>
    </table>

    <p>
      Facts about our scientists now appear exactly once,
      as do the entries for experiments.
      The only exception is the two entries for Sofia Kovalevskaya's hours on the Teleportation project,
      which was in the original data.
      At this point,
      we should either insist that
      all the hours each scientist has spent on a particular project appear in a single database entry,
      or document the reasons for having multiple entries
      (e.g., because each entry is the hours worked in a single week or month).
    </p>
  </section>

  <section id="s:db:selfjoin">
    <h3>Self Join</h3>

    <p>
      One special case of joining tables comes up so often that it has its own name:
      <a href="glossary.html#self-join">self join</a>.
      As the name suggests,
      this means joining a table with itself.
      To see why this is useful,
      let's try to find out how many scientists have worked on two or more projects.
      Our first guess looks like this:
    </p>

<pre src="src/db/self_join_incorrect.sql">
SELECT PersonID, COUNT(*) FROM Experiments GROUP BY PersonID WHERE COUNT(*) > 1;
</pre>

    <p class="continue">
      but that's not legal SQL&mdash;we can't use
      an aggregated value in our <code>WHERE</code> clause,
      because <code>WHERE</code> is applied row-by-row before aggregation happens.
    </p>

    <p>
      Instead, let's join the <code>Experiments</code> table to itself.
      We will give each copy of the table an alias,
      so that we can tell which values came from which copy:
    </p>

<pre src="src/db/self_join_all.sql">
SELECT * FROM Experiments a JOIN Experiments b;
</pre>

    <p>
      The result has 64 rows, a few of which are shown below:
    </p>

    <table class="outlined">
      <tr>
        <td><strong>a.PersonID</strong></td>
        <td><strong>a.Project</strong></td>
        <td><strong>a.Hours</strong></td>
        <td><strong>b.PersonID</strong></td>
        <td><strong>b.Project</strong></td>
        <td><strong>b.Hours</strong></td>
      </tr>
      <tr><td>skol</td><td>Antigravity</td><td>6.5</td><td>skol</td><td>Antigravity</td><td>6.5</td></tr>
      <tr><td>skol</td><td>Antigravity</td><td>6.5</td><td>skol</td><td>Teleportation</td><td>11.0</td></tr>
      <tr><td>skol</td><td>Antigravity</td><td>6.5</td><td>skol</td><td>Teleportation</td><td>5.0</td></tr>
      <tr><td>skol</td><td>Antigravity</td><td>6.5</td><td>mlom</td><td>Antigravity</td><td>4.0</td></tr>
      <tr><td>skol</td><td>Antigravity</td><td>6.5</td><td>mlom</td><td>Time Travel</td><td>-2.0</td></tr>
      <tr><td>skol</td><td>Antigravity</td><td>6.5</td><td>dmen</td><td>Antigravity</td><td>9.0</td></tr>
      <tr><td>skol</td><td>Antigravity</td><td>6.5</td><td>ipav</td><td>Teleportation</td><td>9.0</td></tr>
      <tr><td>skol</td><td>Antigravity</td><td>6.5</td><td>ipav</td><td>Time Travel</td><td>-7.0</td></tr>
      <tr><td>skol</td><td>Teleportation</td><td>11.0</td><td>skol</td><td>Antigravity</td><td>6.5</td></tr>
      <tr><td>skol</td><td>Teleportation</td><td>11.0</td><td>skol</td><td>Teleportation</td><td>11.0</td></tr>
      <tr><td align="center">&hellip;</td><td align="center">&hellip;</td><td align="center">&hellip;</td><td align="center">&hellip;</td><td align="center">&hellip;</td><td align="center">&hellip;</td></tr>
      <tr><td>mlom</td><td>Antigravity</td><td>4.0</td><td>skol</td><td>Antigravity</td><td>6.5</td></tr>
      <tr><td>mlom</td><td>Antigravity</td><td>4.0</td><td>skol</td><td>Teleportation</td><td>11.0</td></tr>
      <tr><td align="center">&hellip;</td><td align="center">&hellip;</td><td align="center">&hellip;</td><td align="center">&hellip;</td><td align="center">&hellip;</td><td align="center">&hellip;</td></tr>
    </table>

    <p>
      Now let's add a <code>WHERE</code> clause to filter out rows
      that have different <code>PersonID</code> values,
      i.e.,
      where we have joined information about one person with information about another:
    </p>

<pre src="src/db/self_join_personid.sql">
SELECT * FROM Experiments a JOIN Experiments b WHERE a.PersonID = b.PersonID;
</pre>

    <table class="outlined">
      <tr>
        <td><strong>a.PersonID</strong></td>
        <td><strong>a.Project</strong></td>
        <td><strong>a.Hours</strong></td>
        <td><strong>b.PersonID</strong></td>
        <td><strong>b.Project</strong></td>
        <td><strong>b.Hours</strong></td>
      </tr>
      <tr><td>skol</td><td>Antigravity</td><td>6.5</td><td>skol</td><td>Antigravity</td><td>6.5</td></tr>
      <tr><td>skol</td><td>Antigravity</td><td>6.5</td><td>skol</td><td>Teleportation</td><td>5.0</td></tr>
      <tr><td>skol</td><td>Antigravity</td><td>6.5</td><td>skol</td><td>Teleportation</td><td>11.0</td></tr>
      <tr><td>skol</td><td>Teleportation</td><td>11.0</td><td>skol</td><td>Antigravity</td><td>6.5</td></tr>
      <tr><td>skol</td><td>Teleportation</td><td>11.0</td><td>skol</td><td>Teleportation</td><td>5.0</td></tr>
      <tr><td>skol</td><td>Teleportation</td><td>11.0</td><td>skol</td><td>Teleportation</td><td>11.0</td></tr>
      <tr><td>skol</td><td>Teleportation</td><td>5.0</td><td>skol</td><td>Antigravity</td><td>6.5</td></tr>
      <tr><td>skol</td><td>Teleportation</td><td>5.0</td><td>skol</td><td>Teleportation</td><td>5.0</td></tr>
      <tr><td>skol</td><td>Teleportation</td><td>5.0</td><td>skol</td><td>Teleportation</td><td>11.0</td></tr>
      <tr><td>mlom</td><td>Antigravity</td><td>4.0</td><td>mlom</td><td>Antigravity</td><td>4.0</td></tr>
      <tr><td>mlom</td><td>Antigravity</td><td>4.0</td><td>mlom</td><td>Time Travel</td><td>-2.0</td></tr>
      <tr><td>mlom</td><td>Time Travel</td><td>-2.0</td><td>mlom</td><td>Antigravity</td><td>4.0</td></tr>
      <tr><td>mlom</td><td>Time Travel</td><td>-2.0</td><td>mlom</td><td>Time Travel</td><td>-2.0</td></tr>
      <tr><td>dmen</td><td>Antigravity</td><td>9.0</td><td>dmen</td><td>Antigravity</td><td>9.0</td></tr>
      <tr><td>ipav</td><td>Teleportation</td><td>9.0</td><td>ipav</td><td>Teleportation</td><td>9.0</td></tr>
      <tr><td>ipav</td><td>Teleportation</td><td>9.0</td><td>ipav</td><td>Time Travel</td><td>-7.0</td></tr>
      <tr><td>ipav</td><td>Time Travel</td><td>-7.0</td><td>ipav</td><td>Teleportation</td><td>9.0</td></tr>
      <tr><td>ipav</td><td>Time Travel</td><td>-7.0</td><td>ipav</td><td>Time Travel</td><td>-7.0</td></tr>
    </table>

    <p>
      Now let's add another clause to our <code>WHERE</code>
      to get rid of records where the two project names are the same:
    </p>

<pre src="src/db/self_join_project.sql">
SELECT * FROM Experiments a JOIN Experiments b
WHERE (a.PersonID = b.PersonID) AND (a.Project != b.Project);
</pre>

    <table class="outlined">
      <tr><td>skol</td><td>Antigravity</td><td>6.5</td><td>skol</td><td>Teleportation</td><td>5.0</td></tr>
      <tr><td>skol</td><td>Antigravity</td><td>6.5</td><td>skol</td><td>Teleportation</td><td>11.0</td></tr>
      <tr><td>skol</td><td>Teleportation</td><td>11.0</td><td>skol</td><td>Antigravity</td><td>6.5</td></tr>
      <tr><td>skol</td><td>Teleportation</td><td>5.0</td><td>skol</td><td>Antigravity</td><td>6.5</td></tr>
      <tr><td>mlom</td><td>Antigravity</td><td>4.0</td><td>mlom</td><td>Time Travel</td><td>-2.0</td></tr>
      <tr><td>mlom</td><td>Time Travel</td><td>-2.0</td><td>mlom</td><td>Antigravity</td><td>4.0</td></tr>
      <tr><td>ipav</td><td>Teleportation</td><td>9.0</td><td>ipav</td><td>Time Travel</td><td>-7.0</td></tr>
      <tr><td>ipav</td><td>Time Travel</td><td>-7.0</td><td>ipav</td><td>Teleportation</td><td>9.0</td></tr>
    </table>

    <p>
      This may not seem like progress,
      but we have almost answered our original question.
      Each of these records represents the fact that some person has worked on two different projects.
      Putting it another way,
      if someone has only ever worked on one project (or hasn't worked on any projects at all),
      their ID will not appear in any record in this set.
      To get the list of names of people who have worked on two or more projects,
      therefore,
      all we have to do is display either <code>a.PersonID</code> or <code>b.PersonID</code>
      (and eliminate duplicates using <code>DISTINCT</code>).
      We will split our final query across several lines to make it easier to read,
      and use an <code>ORDER BY</code> to ensure that our results are sorted:
    </p>

<pre src="src/db/self_join_final.sql">
SELECT DISTINCT a.PersonID
FROM            Experiments a JOIN Experiments b
WHERE           (a.PersonID = b.PersonID) AND (a.Project != b.Project)
ORDER BY        a.PersonID ASC;
</pre>

    <table class="outlined">
      <tr>
        <td>ipav</td>
      </tr>
      <tr>
        <td>mlom</td>
      </tr>
      <tr>
        <td>skol</td>
      </tr>
    </table>

    <p>
      If you hang around programmers long enough,
      you will eventually hear someone call this trick "intuitive".
      They are using that word the way certain mathematicians use "obvious":
      it means,
      "You only have to read the proof a couple of times to get it."
      There actually is a rich mathematical theory underneath SQL,
      and if you immerse yourself in that theory,
      tricks like joining a table to itself do eventually seem obvious.
      For the rest of us, though,
      it's enough to learn this pattern
      and recognize when it should be used.
    </p>
  </section>

  <section id="s:db:nested">
    <h3>Nested Queries</h3>

    <p>
      Let's switch back to the <code>Experiments</code> table that doesn't contain <code>NULL</code>s.
      How do we find scientists who have <em>not</em> been working on time travel?
      Our first guess might be:
    </p>

<pre src="src/db/select_not_time_travel_flawed.sql">
SELECT DISTINCT PersonID FROM Experiments WHERE Project != "Time Travel";
</pre>

    <p>
      Unfortunately, this doesn't give us what we want.
      <code>ivan</code> and <code>skol</code> have both worked both on Time Travel,
      but show up in the results:
    </p>

    <table class="outlined">
      <tr><td>dmen</td></tr>
      <tr><td>ipav</td></tr>
      <tr><td>mlom</td></tr>
      <tr><td>skol</td></tr>
    </table>

    <p>
      Let's think this through.
      There are scientists who have worked on Time Travel,
      scientists who have only worked on other projects,
      and scientists who have done both.
      Our query returns all of the scientists who have worked on projects other than Time Travel,
      but that includes ones who have worked on Time Travel <em>and</em> other projects
      (<a href="#f:venn_time_travel">Figure XXX</a>).
    </p>

    <figure id="f:venn_time_travel">
      <img src="img/db/venn_time_travel.png" alt="Scientists and Time Travel" />
      <figcaption>Scientists and Time Travel</figcaption>
    </figure>

    <p>
      The trick to answering this question&mdash;and it <em>is</em> a trick&mdash;is
      to subtract those scientists who <em>have</em> worked on Time Travel
      (i.e., the ones we <em>don't</em> want)
      from the set of all scientists.
      To do this,
      we will need to use a <a href="glossary.html#nested-query">nested query</a>
      (also called a <a href="glossary.html#subquery">subquery</a>).
    </p>

    <p>
      Let's work up to it in stages.
      Finding all of the scientists is easy:
    </p>

<pre>
SELECT DISTINCT PersonID FROM Experiments;
</pre>

    <p class="continue">
      If we knew in advance which scientists we didn't want,
      we could use <code>NOT IN</code> to subtract a fixed set,
      like this:
    </p>

<pre>
SELECT DISTINCT PersonID FROM Experiment WHERE PersonID NOT IN ('ivan', 'skol');
</pre>

    <p class="continue">
      We don't actually know which scientists who have worked on Time Travel,
      but we can generate it with this query:
    </p>

<pre src="src/db/time_travel_subquery.sql">
SELECT DISTINCT PersonID FROM Experiment WHERE Project = "Time Travel";
</pre>

    <p>
      What we want to do is somehow use the result of the second query in the first.
      SQL allows us to do exactly this,
      i.e.,
      to nest one query inside another so that we can use the results of the nested query
      in the filter conditions of the main query.
      Here's what it looks like:
    </p>

<pre src="src/db/select_nested_subtract.sql">
SELECT DISTINCT PersonID FROM Experiments WHERE PersonID NOT IN
       (SELECT DISTINCT PersonID FROM Experiments WHERE Project = "Time Travel");
</pre>

<table class="outlined">
  <tr><td>dmen</td></tr>
  <tr><td>skol</td></tr>
</table>

    <p>
      We can read this query as saying,
      "Fetch all of the scientists who have done experiments,
      except for the ones that appear in the list of scientists who have worked on Time Travel".
      It isn't intuitive,
      but the pattern is easy to learn,
      and very useful.
    </p>

    <p>
      Nested queries can also be used as if they were tables in their own right.
      For example,
      suppose we want to know how many different projects each scientist has worked on.
      We can begin by finding the distinct list of projects for scientist like this:
    </p>

<pre>
SELECT DISTINCT PersonID, Project FROM Experiments;
</pre>

    <p>
      Now we want to count how many results there are for each scientist.
      Since counting is an aggregation,
      we need to use the results of this query as input for another query that does the aggregation.
      We can do this by wrapping the first query in parentheses
      and putting it in the <code>FROM</code> clause of the second query:
    </p>

<pre>
&hellip;
FROM (SELECT DISTINCT PersonID, Project FROM Experiments);
</pre>

    <p class="continue">
      The next step is to write the outer query.
      We want the scientist, and count of their projects:
    </p>

<pre>
SELECT PersonID, COUNT(*)
FROM   (SELECT DISTINCT PersonID, Project FROM Experiments);
</pre>

    <p class="continue">
      and since we want the count for each scientists,
      we have to add a <code>GROUP&nbsp;BY</code> for the outer query.
      The whole thing is therefore:
    </p>

<pre src="src/db/nested_query_group_by.sql">
SELECT   PersonID, COUNT(*)
FROM     (SELECT DISTINCT PersonID, Project FROM Experiments)
GROUP BY PersonID;
</pre>

    <table class="outlined">
      <tr><td>dmen</td><td>1</td></tr>
      <tr><td>ipav</td><td>2</td></tr>
      <tr><td>mlom</td><td>2</td></tr>
      <tr><td>skol</td><td>2</td></tr>
    </table>

    <p>
      Nesting queries like this is really useful
      if the data we want isn't present in exactly the right form in the database.
      We can use one query to get the data in the form we need it in,
      and then wrap another query around it to get the answer we originally wanted.
    </p>
  </section>
</section>
{% endblock content %}
