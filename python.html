{% extends "templates/_base.html" %}

{% block file_metadata %}
  <meta name="title" content="Basic Programming With Python" />
  <meta name="status" content="Ready for comment" />
{% endblock file_metadata %}

{% block content %}
<ol class="toc">
  <li><a href="#s:basic">Basic Operations</a></li>
  <li><a href="#s:program">Creating Programs</a></li>
  <li><a href="#s:types">Types</a></li>
  <li><a href="#s:io">Reading Files</a></li>
  <li><a href="#s:stdio">Standard Input and Output</a></li>
  <li><a href="#s:for">Repeating Things</a></li>
  <li><a href="#s:logic">Making Choices</a></li>
  <li><a href="#s:flag">Flags</a></li>
  <li><a href="#s:parse">Reading Data Files</a></li>
  <li><a href="#s:lists">Lists</a></li>
  <li><a href="#s:func">Functions</a></li>
  <li><a href="#s:scope">Scope</a></li>
  <li><a href="#s:return">Returning Values</a></li>
  <li><a href="#s:libraries">Libraries</a></li>
  <li><a href="#s:stdlib">Standard Libraries</a></li>
  <li><a href="#s:filter">Building Filters</a></li>
  <li><a href="#s:summary">Summing Up</a></li>
</ol>

<p>
  A cochlear implant is a small device placed in the inner ear
  to give the hearing impaired a sense of sound.
  To test how effective they are,
  Aurora Audio wants to measure three things:
  the range of tones that people can hear,
  how well they can discriminate between similar tones.
  and the softest volume they can notice.
  Each test is supposed to be scored from 0 to 5,
  but after her collaborators submitted their data,
  she found that some had scored from -5 to 5 instead.
  She needs to clean up the data before using it.
</p>

<p>
  If Aurora had only one data set,
  the fastest solution might be to use a spreadsheet.
  However,
  she actually has over a hundred data sets,
  with more coming in each week.
  Since she doesn't want to spend hours doing the same things over and over again,
  she wants to write a small program to clean up her data for her.
  To do that,
  she's going to have to learn how to program,
  and that's what the next couple of chapters are about.
</p>

<p>
  We will use a programming language called Python for our examples.
  Python is free,
  reasonably well documented,
  and widely used in science and engineering.
  Our main reason for choosing it,
  though,
  is that newcomers find it easier to read than most other languages.
  It also allows people to do useful things
  without having to master advanced concepts like object-oriented programming.
</p>

<div class="guide">
  <h2>For Instructors</h2>

  <p class="fixme">This is the slower-paced one for people new to programming.</p>

  <div class="prereq">
    <h3>Prerequisites</h3>
    <p class="fixme">write</p>
  </div>

  <div class="notes">
    <h3>Teaching Notes</h3>
    <ul>
      <li class="fixme">write</li>
    </ul>
  </div>
</div>

<section id="s:basic">
  <h2>Basic Operations</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Run the Python interpreter interactively.</li>
      <li>Correctly enter basic arithmetic expressions.</li>
      <li>Explain what variables are and what they are used for.</li>
      <li>Assign numbers and strings to variables.</li>
      <li>Explain what happens when one variable is assigned to another.</li>
      <li>Trace the effect of several consecutive assignment statements.</li>
    </ul>
  </div>

  <p>
    The best way to learn how to program is to start programming,
    so let's run the Python interpreter
    and type in the following:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">print 1 + 1</span>
<span class="out">2</span>
</pre>

  <p class="continue">
    The <code>&gt;&gt;&gt;</code> <a href="glossary.html#prompt">prompt</a>
    is the interpreter's way of telling us that it's waiting for input,
    like the <code>$</code> prompt in <a href="shell.html">the shell</a>.
    When we enter 1+1,
    Python does the calculation we've asked for
    and prints the result.
  </p>

  <p>
    Now type this:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">x = 1+1</span>
</pre>

  <p class="continue">
    Python doesn't display anything this time
    (except another prompt).
    Instead,
    as <a class="figref" href="#f:first_variable">Figure 1</a> shows,
    it creates a <a href="glossary.html#variable">variable</a> called <code>x</code>
    and assigns it the value 2.
    We can then get that variable's value simply by entering its name:
  </p>

<pre>
print x
<span class="out">2</span>
</pre>

  <p class="continue">
    (Here and elsewhere,
    we will leave out the Python prompts and just show the code.
    When we do this,
    we will use a horizontal line to separate
    the program from its output.)
  </p>

  <figure id="f:first_variable">
    <img src="python/first_variable.png" alt="Our First Variable" />
    <figcaption>Figure 1: Our First Variable</figcaption>
  </figure>

  <div class="box">
    <h3>Some Things That Don't Work</h3>

    <p>
      Python is a fairly relaxed language,
      but there are still some things it won't let us do.
      For example,
      this doesn't work:
    </p>

<pre>
print x = 1 + 2
<span class="err">SyntaxError: invalid syntax</span>
</pre>

    <p class="continue">
      The problem is that printing and assignment are both
      <a href="glossary.html#statement">statements</a>,
      and statements cannot be mixed together.
      1+2, on the other hand,
      is an <a href="glossary.html#expression">expression</a>&mdash;something
      that produces a new value&mdash;and expressions can be combined in many ways.
      Except for assignment,
      every statement in Python begins with a keyword like <code>print</code>,
      so it's usually easy to tell them apart.
    </p>

    <p>
      Something else that may not work as shown is printing.
      In Python 2,
      <code>print</code> is a statement written on a line of its own.
      In Python 3,
      <code>print</code> is a function,
      and must be written like this:
    </p>

<pre>
print(1+2, 'is', 3)
</pre>

    <p class="continue">
      We use the Python 2 syntax in these lessons.
    </p>

  </div>

  <p>
    We can now use that variable's value in calculations:
  </p>

<pre>
print x * 2
<span class="out">4</span>
</pre>

  <p class="continue">
    including ones that create more variables:
  </p>

<pre>
y = x * 2
print y
<span class="out">4</span>
</pre>

  <p class="continue">
    We can change a variable's value
    by assigning something new to it:
  </p>

<pre>
x = 10
print x
<span class="out">10</span>
</pre>

  <p class="continue">
    As <a class="figref" href="#f:assign_new_value">Figure 2</a> shows,
    assigning something to <code>x</code> changes what it points to,
    but does not change anything else.
    In particular,
    <code>y</code> still has the value 4 after this assignment:
    it is not automatically updated when <code>x</code>'s value changes,
    as it would in a spreadsheet.
  </p>

  <figure id="f:assign_new_value">
    <img src="python/assign_new_value.png" alt="Assigning a New Value" />
    <figcaption>Figure 2: Assigning a New Value</figcaption>
  </figure>

  <p>
    Here's a more complex calculation:
  </p>

<pre>
x = 98.6
y = (x - 32.0) * (5.0 / 9.0) + 273.15
print y
<span class="out">310.15</span>
</pre>

  <p class="continue">
    Its meaning becomes clearer if we rewrite it as:
  </p>

<pre>
temp_fahr = 98.6
temp_kelvin = (temp_fahr - 32.0) * (5.0 / 9.0) + 273.15
print "body temperature in Kelvin:", temp_kelvin
<span class="out">body temperature in Kelvin: 310.15</span>
</pre>

  <p>
    The first line creates a new variable called <code>temp_fahr</code>
    (short for "temperature in Fahrenheit")
    and gives it the value 98.6
    (<a class="figref" href="#f:first_memory_model">Figure 3</a>).
    The second line creates another variable to hold the temperature in Kelvin
    (hence its name).
    It calculates a value for this variable
    that depends on the value of <code>temp_fahr</code>.
    The last line prints the result.
    The <a href="glossary.html#string">character string</a>
    (or just "string" for short)
    inside double quotes is printed as-is,
    followed by the value of <code>temp_kelvin</code>.
  </p>

  <figure id="f:first_memory_model">
    <img src="python/first_memory_model.png" alt="First Memory Model" />
    <figcaption>Figure 3: First Memory Model</figcaption>
  </figure>

  <p>
    Every <a href="glossary.html#program">program</a> is just
    a series of statements like the ones shown above
    (for some possibly large value of "just").
    Like all programs,
    this one stores data and does calculations.
    We use variables to do the first,
    and write instructions that use those variables to do the second.
    And like every <em>good</em> program,
    this one is written with human beings in mind.
    Computers get faster every year,
    but our brains don't.
    As a result,
    the real bottleneck in scientific computing is usually not
    how fast the program runs,
    but how long it takes us to write it.
    This is why we use variable names like <code>temp_fahr</code> and <code>temp_kelvin</code>
    instead of <code>x</code> and <code>y</code>.
  </p>

  <div class="box">
    <h3>Creating Variables</h3>

    <p>
      Python creates a variable whenever a value is assigned to a name,
      but won't let us get the value of a variable that hasn't been assigned one.
      For example,
      if we try to do this:
    </p>

<pre>
double_temp = temp_celsius * 2
</pre>

    <p class="continue">
      then Python prints an error message:
    </p>

<pre>
<span class="err">Traceback (most recent call last):
  File "&lt;undefined-variable.py&gt;", line 1, in &lt;module&gt;
NameError: name 'temp_celsius' is not defined</span>
</pre>

    <p class="continue">
      We'll explain what "module" means <a href="funclib.html">later</a>.
      What's important now is that this strictness helps catch a lot of typing mistakes:
      if we mistakenly type <code>temp_far</code> instead of <code>temp_fahr</code>:
    </p>

<pre>
temp_kelvin = (<span class="highlight">temp_far</span> - 32.0) * (5.0 / 9.0) + 273.15
</pre>

    <p class="continue">
      then Python will tell us something's gone wrong.
      It can't help us if we type 3.20 instead of 32.0, though;
      if we want to catch that mistake,
      we'll actually have to <a href="quality.html">test our program</a>.
    </p>
  </div>

  <p>
    Readability is also why we put the temperature in Fahrenheit in a variable,
    then use that variable in line 2,
    rather than just putting 98.6 directly in the calculation.
    If we ever want to convert another temperature,
    it's easier to see and change the value on line 1
    than it would be to find it buried in the middle of a line of arithmetic.
  </p>

  <p>
    Finally,
    this first program also shows how arithmetic is done.
    '+' means addition,
    '*' means multiplication,
    and parentheses group things together,
    just as they do in pen-and-paper arithmetic.
    We have to use parentheses here because
    (also as in arithmetic)
    multiplication takes precedence over addition:
    the expression <code>2*3+5</code> means,
    "Multiply two by three, then add five,"
    rather than,
    "Add three and five, then multiple by two."
    If we want the latter,
    we have to write <code>2*(3+5)</code>.
  </p>

  <div class="box">
    <h3>Repeating Commands</h3>

    <p>
      Just as we could repeat previous commands in the shell
      by using the <a href="shell.html#a:repeat">up arrow</a>,
      so too can we repeat commands in the Python interpreter.
      And while the standard interpreter doesn't have an equivalent
      of the shell's <code>history</code> command,
      more advanced shells like IPython do
      (along with much more).
    </p>
  </div>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>Use '=' to assign a value to a variable.</li>
      <li>Assigning to one variable does not change the values associated with other variables.</li>
      <li>Use <code>print</code> to display values.</li>
      <li>Variables are created when values are assigned to them.</li>
      <li>Variables cannot be used until they have been created.</li>
      <li>Addition ('+'), subtraction ('-'), and multiplication ('*') work as usual in Python.</li>
      <li>Use meaningful, descriptive names for variables.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>

      <li>
        What is the output of:
<pre>
inner = 13.0
outer = 2 * inner
inner = 2 * inner
print outer
</pre>
      </li>

      <li>
        Fill in the blank so that these lines of code produce the output shown.
<pre>
female = 'GGT'
male = 'CAC'
________
print female
<span class="out">GGTGGTCAC</span>
</pre>
      </li>

      <li>
        What single change can be made to the first three lines below to get the output shown?
<pre>
scaling = 10
original = 7
adjusted = primary / scaling
print original + adjusted
<span class="out">7.7</span>
</pre>
      </li>
    </ol>
  </div>
 
</section>

<section id="s:program">
  <h2>Creating Programs</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Store Python commands in a file.</li>
      <li>Use the interpreter to run a file containing Python commands.</li>
    </ul>
  </div>

  <p>
    Typing in commands over and over again is tedious and error-prone.
    Just as we saved shell commands in <a href="shell.html#s:scripts">shell scripts</a>,
    we can save Python commands in files
    and then have the Python interpreter run those.
    Using your favorite text editor,
    put the following three lines into a plain text file:
  </p>

<pre>
left = "hello"
right = "there"
print left, right
</pre>

  <p class="continue">
    and then save it as <code>greeting.py</code>.
    (By convention,
    Python files end in '.py'
    rather than '.txt'.)
    To run it from the shell,
    type:
  </p>

<pre>
$ <span class="in">python greeting.py</span>
<span class="out">hello there</span>
</pre>

  <p>
    When the Python interpreter executes a file,
    it runs the commands in that file
    just as if they had been typed in interactively.
    It doesn't wait until the whole file has been read
    to start executing;
    instead,
    it runs each command as soon as it can.
    For example,
    if we create another file called <code>division.py</code>
    that contains the single line:
  </p>

<pre>
print "before", 1/0, "after"
</pre>

  <p class="continue">
    and run it,
    the output is:
  </p>

<pre>
before
<span class="err">Traceback (most recent call last):
  File "a.py", line 2, in &lt;module&gt;
    1/0
ZeroDivisionError: integer division or modulo by zero</span>
</pre>

  <p class="continue">
    because Python tries (and fails) to divide by zero
    before printing the word "after".
  </p>

  <div class="box">
    <h3>Using the IPython Notebook</h3>
    <p class="fixme">explain how to use the notebook instead</p>
  </div>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>Store programs in files whose names end in <code>.py</code> and run them with <code>python <em>name.py</em></code>.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>

      <li>
        Nelle has created a file called <code>example.py</code>
        that contains the following lines:
<pre>
tolerance = 5.0e3
thinning = 2 * tolerance / 1000
</pre>
        What happens when she runs this file from the shell using the command:
<pre>
$ <span class="in">python -i example.py</span>
</pre>
      </li>

      <li>
        Nelle has a file called <code>powers.txt</code> that contains:
<pre>
density = 1.417e3
radius = 4.5
mass = density * (4.0/3.0) * 3.14159 * radius ** 3
print mass
</pre>
        What does the double asterisk <code>**</code> do?
        And does she have to rename this file to <code>powers.py</code>
        in order to run it?
      </li>

    </ol>

  </div>
</section>

<section id="s:types">
  <h2>Types</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Explain what a data type is, and give examples of three different data types.</li>
      <li>Correctly identify the types of integer, floating-point, and string values.</li>
      <li>Call a built-in function.</li>
      <li>Explain what "type conversion" is, and give an example.</li>
      <li>Explain (with an example) why programs shouldn't guess what people want to do.</li>
    </ul>
  </div>

  <p>
    Let's take another look at our temperature conversion program:
  </p>

<pre>
temp_fahr = 98.6
temp_kelvin = (temp_fahr - 32.0) * (5.0 / 9.0) + 273.15
print "body temperature in Kelvin:", temp_kelvin
<span class="out">body temperature in Kelvin: 310.15</span>
</pre>

  <p>
    Why have we written 5.0/9.0 instead of 5/9?
    Let's see what happens if we take out the .0's:
  </p>

<pre>
temp_fahr = 98.6
<span class="highlight">temp_kelvin = (temp_fahr - 32) * (5 / 9) + 273.15</span>
print "body temperature in Kelvin:", temp_kelvin
<span class="out">body temperature in Kelvin: 273.15</span>
</pre>

  <p>
    That's not right.
    To understand what's gone wrong,
    let's look at 5/9:
  </p>

<pre>
5/9
<span class="out">0</span>
</pre>

  <p>
    The problem is that integers and floating point numbers
    (or <a href="glossary.html#float">floats</a>)
    are different things to a computer.
    If a number doesn't have a decimal point,
    then Python stores its value as an integer (with no fractional part).
    When it divides one integer by another,
    it throws away the remainder.
    If a number contains a decimal point,
    though,
    Python stores it as a float.
    When it does division (or any other kind of arithmetic),
    the result is a float if either of the values involved is a float:
  </p>

  <table>
    <tr>
      <td valign="top">
<pre>
print 10 / 3
<span class="out">3</span>
</pre>
      </td>
      <td valign="top">
<pre>
10.0 / 3
<span class="out">3.3333333333333335</span>
</pre>
      </td>
    </tr>
  </table>

  <p class="continue">
    This makes sense,
    but only if you understand how the chips inside computers work.
    Version 3 of Python changed the rules for division
    so that it returns fractional numbers whenever it needs to.
    However,
    we're using Python 2.7 in this course,
    so 10/3 is 3 until further notice.
  </p>

  <p>
    Every value in a program has a specific <a href="glossary.html#type">type</a>
    which determines how it behaves
    and what can be done to it.
    We can find out what type something is
    using a built-in <a href="glossary.html#function">function</a> called <code>type</code>:
  </p>

  <table>
    <tr>
      <td valign="top">
<pre>
print type(12)
<span class="out">&lt;type 'int'&gt;</span>
</pre>
      </td>
      <td valign="top">
<pre>
type(12.0)
<span class="out">&lt;type 'float'&gt;</span>
</pre>
      </td>
    </tr>
  </table>

  <p>
    Integers and floating-point numbers are two common types;
    another is the character string.
    We can create one by putting characters inside either single or double quotes
    (as long as they match at the beginning and end):
  </p>

<pre>
name = "Alan Turing"
born = 'June 23, 1912'
print name, born
<span class="out">Alan Turing June 23, 1912</span>
</pre>

  <p>
    We can also "add" strings:
  </p>

<pre>
full = name + " (" + born + ")"
print full
<span class="out">Alan Turing (June 23, 1912)</span>
</pre>

  <p>
    What we <em>can't</em> do is add numbers and strings:
  </p>

<pre>
print 2 + "three"
<span class="err">Traceback (most recent call last):
  File "add-numbers-strings.py", line 1, in &lt;module&gt;
    print 2 + "three"
TypeError: unsupported operand type(s) for +: 'int' and 'str'</span>
</pre>

  <p>
    The string "2three" would be a reasonable result in this case,
    but it's not so where <code>2+"3"</code> should produce
    the integer 5 or the string <code>"23"</code>.
    Rather than guessing at the programmer's intentions,
    Python expects some guidance:
  </p>

  <table>
    <tr>
      <td valign="top">
<pre>
print 2 + int("3")
<span class="out">5</span>
</pre>
      </td>
      <td valign="top">
<pre>
print str(2) + "3"
<span class="out">23</span>
</pre>
      </td>
    </tr>
  </table>

  <p>
    <code>int</code> and <code>str</code> are two more built-in functions
    which convert values to particular types.
    We'll look at functions in much more detail later.
  </p>

  <div class="box">
    <h3>Values Have Types, Variables Don't</h3>

    <p>
      One important difference between "dynamic" languages
      like Python, Perl, and R,
      and compiled languages like C++, Java, and Fortran,
      is the relationship between variables and types.
      In a Java program,
      any particular variable can only store values of a particular type:
      if a variable has the type "integer",
      it can not hold a string,
      and vice versa.
      In Python,
      on the other hand,
      a variable is just a name,
      and can refer to anything at all.
      For example,
      the following is perfectly legal in Python:
    </p>

<pre>
age = 35 <span class="comment"># 'age' refers to an integer</span>
age = 'young' <span class="comment"># 'age' now refers to a string</span>
</pre>

    <p>
      Programmers disagree about whether this is good style or bad.
      On the one hand,
      the meaning of <code>age</code> is always the age of the current test subject;
      we're just representing it in different coordinate systems
      (years and then age bracket).
      On the other hand,
      switching types imposes an extra cognitive burden on readers:
      multiplying <code>age</code> by two makes makes sense when
      the value is an integer,
      but not when it's a string.
    </p>
  </div>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>The most commonly used data types in Python are integers (<code>int</code>), floating-point numbers (<code>float</code>), and strings (<code>str</code>).</li>
      <li>Strings can start and end with either single quote (') or double quote (&quot;).</li>
      <li>Division ('/') produces an <code>int</code> result when given <code>int</code> values: one or both parameters must be <code>float</code> to get a <code>float</code> result.</li>
      <li>"Adding" strings concatenates them, multiplying strings by numbers repeats them.</li>
      <li>Strings and numbers cannot be added because the behavior is ambiguous: convert one to the other type first.</li>
      <li>Variables do not have types, but values do.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>

      <li>
        If the variable <code>x</code> holds a number,
        is the value of <code>int(str(x))</code> the same as the value of <code>x</code>?
      </li>

      <li>
        What is value of <code>molecule</code> after the following code is run?
<pre>
oxygen = 'O'
carbon = 'C
molecule = carbon + oxygen * 2
</pre>
      </li>

    </ol>

  </div>

</section>

<section id="s:io">
  <h2>Reading Files</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Draw a diagram to explain where computers store data.</li>
      <li>Write programs that open, read, and close files.</li>
      <li>Explain how "lines" of text are actually stored in files.</li>
      <li>Call a pre-defined method of a built-in type.</li>
      <li>Write programs that write data to files.</li>
    </ul>
  </div>

  <p>
    Broadly speaking,
    modern computers store data in one of six places
    (<a class="figref" href="#f:memory_architecture">Figure 4</a>):
  </p>

  <ol>

    <li>
      Inside the processor itself.
    </li>

    <li>
      In memory.
    </li>

    <li>
      On a local disk.
    </li>

    <li>
      On disk somewhere else on a network.
    </li>

    <li>
      In an offline archive,
      such as a DVD jukebox.
    </li>

  </ol>

  <figure id="f:memory_architecture">
    <img src="python/memory_architecture.png" alt="Where Data is Stored" />
    <figcaption>Figure 4: Where Data is Stored</figcaption>
  </figure>

  <p>
    Each level is tens to thousands of times faster than the one below it,
    but tens to thousands of times more expensive per byte.
    Broadly speaking,
    programs access information in three different ways:
  </p>

  <ol>

    <li>
      The data is in memory.
      The program can manipulate it directly,
      but changes will not be saved when the program ends.
    </li>

    <li>
      The data is on disk.
      The program has to read it into memory to work with it,
      and write changes back out,
      but those changes will persist after the program ends.
    </li>

    <li>
      The data is far away,
      and must be copied to the local machine for use
      (although given the speed of today's internet,
      there is much less difference between "local" and "remote"
      than there used to be).
    </li>

  </ol>

  <p>
    We'll deal with the third case <a href="web.html">later</a>.
    For now,
    let's look at how to get data out of a file on our computer's hard drive.
    Suppose that one of our hearing data files,
    <code>cochlear01.txt</code>,
    is formatted like this:
  </p>

<pre>
Subject: 1782
Date:    2012-05-21
Test     Run  Score
----     ---  -----
range    1    3
range    2    5
discrim  1    1
discrim  2    1
discrim  4    1.5
volume   1    3.5
volume   2    4.0
</pre>

  <p class="continue">
    It's easy to see where the tester decided that half-point scores were OK.
    We can also see that the tester either forgot to record
    the result of the third discrimination test,
    or decided to leave it out.
    Before worrying about that,
    let's write a small program that extracts the subject ID from a data file.
    Save the lines below in a file called <code>first.py</code>
    in the same directory as the <code>cochlear01.txt</code> data file:
  </p>

<pre>
reader = file('cochlear01.txt', 'r')
first_line = reader.readline()
print first_line
reader.close()
</pre>

  <p>
    The first line uses a built-in function called <code>file</code>
    to open our file.
    Its first parameter is the name of the file being opened.
    Its second is the string <code>'r'</code>,
    which signals that we want to read from this file
    (rather than write to it).
  </p>

  <p>
    <code>file</code>
    creates a connection (or <a href="glossary.html#handle">handle</a>)
    between the program and the data on disk
    (<a class="figref" href="#f:file_object">Figure 5</a>),
    which is assigned to the variable <code>reader</code>.
    There's nothing special about that name&mdash;we could call it <code>newton</code>&mdash;but
    whatever we call it,
    we can ask it to read a line from the file for us
    and assign that string to <code>first_line</code>
    by calling its <a href="glossary.html#method">method</a> <code>readline</code>.
    The program then prints that line and tells the file to close itself.
    This last step isn't strictly necessary in a small program&mdash;Python
    automatically closes any files that are open when the program finishes&mdash;but
    it's a good habit to get into,
    since the operating system limits the number of files any one program can have open at a time.
  </p>

  <figure id="f:file_object">
    <img src="python/file_object.png" alt="File Objects" />
    <figcaption>Figure 5: File Objects</figcaption>
  </figure>

  <div class="box">
    <h3>Methods</h3>

    <p>
      <code>readline</code> is a special kind of function
      called a <a href="glossary.html#method">method</a>.
      It's attached to a particular object&mdash;in this case,
      to the file handle <code>reader</code>.
      You can think of objects and methods as nouns and verbs,
      so when we write <code>reader.readline()</code>,
      we're asking whatever the variable <code>reader</code> points at
      to do <code>readline</code> for us.
      As <a class="figref" href="#f:methods">Figure 6</a> shows,
      the methods are associated with the thing the variable points at,
      not with the variable itself.
    </p>

    <figure id="f:methods">
      <img src="python/methods.png" alt="Where Methods Are Stored" />
      <figcaption>Figure 6: Where Methods Are Stored</figcaption>
    </figure>

  </div>

  <p>
    Here's what happens when we run our program:
  </p>

<pre>
$ <span class="in">python first.py</span>
<span class="out">Subject: 1782

</span>
</pre>

  <p>
    It's not easy to see, but there's actually an extra blank line in the output.
    Where does it come from?
  </p>

  <p>
    The answer depends on the fact that text files aren't stored in lines:
    that's just how things like text editors and shell commands display them.
    A text file is actually stored as a sequence of bytes
    (<a class="figref" href="#f:text_file_storage">Figure 7</a>).
    Some of those happen to be newline characters,
    and most tools interpret them as meaning "end of line".
    In particular,
    when asked to read the next line from a file,
    Python's file-reading functions read up to and including the end-of-line marker
    and return that.
  </p>

  <figure id="f:text_file_storage">
    <img src="python/text_file_storage.png" alt="Text File Storage" />
    <figcaption>Figure 7: Text File Storage</figcaption>
  </figure>

  <p>
    Nothing says files have to be stored this way, though.
    On Windows,
    text files use two characters&mdash;a carriage return and a newline&mdash;to
    mark the end of line.
    If we are using Python on Windows,
    it automatically translates those two characters into a single newline when reading,
    and translates newlines back into those two characters when writing,
    so that our programs don't have to worry about it.
  </p>

  <p>
    Coming back to our program,
    the <code>print</code> command automatically adds an end-of-line marker
    to its output.
    We can tell it not to do that by putting a comma at the end of the line.
    This can make things confusing when we're using the interpreter interactively:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">print 5</span> <span class="comment"># without comma</span>
<span class="out">5</span>
&gt;&gt;&gt; <span class="in">print 5,</span> <span class="comment"># with comma</span>
<span class="out">5</span>&gt;&gt;&gt;
</pre>

  <p class="continue">
    but it's useful when we want to prevent newlines doubling up:
  </p>

<pre>
reader = file('cochlear01.txt', 'r')
first_line = reader.readline()
print first_line<span class="highlight">,</span>
reader.close()
<span class="out">Subject: 1782</span>
</pre>

  <p>
    A better way to solve the problem is to get rid of the line ending on the string:
  </p>

<pre>
reader = file('cochlear01.txt', 'r')
first_line = reader.readline()
<span class="highlight">first_line = first_line.strip()</span>
print first_line
reader.close()
<span class="out">Subject: 1782</span>
</pre>

  <p class="continue">
    The variable <code>first_line</code> refers to a string,
    and strings in Python are also objects with methods.
    One of those methods,
    <code>strip</code>,
    creates a new string by removing any leading or trailing spaces, tabs, or line-ending characters
    from the original string
    (<a class="figref" href="#f:string_strip">Figure 8</a>).
    It does <em>not</em> modify the original string:
    in Python,
    any string has a fixed value,
    just as the integer <code>5</code>'s value is always fixed at 5.
  </p>

  <figure id="f:string_strip">
    <img src="python/string_strip.png" alt="Stripping Strings" />
    <figcaption>Figure 8: Stripping Strings</figcaption>
  </figure>

  <div class="box">
    <h3>Writing Files</h3>

    <p>
      Writing to a file is as easy as reading from one:
    </p>

<pre>
writer = file('mydata.txt', 'w')
print &gt;&gt; writer, 'largest value:', 20
print &gt;&gt; writer, 'smallest value:', -2
writer.close()
</pre>

    <p class="continue">
      We begin by opening the file in <code>'w'</code> (write) mode.
      This gives us a handle that we can use in subsequent operations,
      which we assign to a variable.
      (We've called it <code>writer</code> here,
      but we could call it anything.)
      After that,
      we can print to the file exactly as we have been printing to the screen;
      as always,
      we close the file when we're done
      (which is when the last few things we've written to the file are actually stored on disk).
    </p>

    <p>
      Opening a file for writing erases its previous content,
      or creates the file if it didn't already exist.
      If we don't want to erase any previous content,
      we can open the file for appending using <code>'a'</code> instead of <code>'w'</code>.
    </p>

  </div>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>Data is either in memory, on disk, or far away.</li>
      <li>Most things in Python are objects, and have attached functions called methods.</li>
      <li>When lines are read from files, Python keeps their end-of-line characters.</li>
      <li>Use <code>str.strip</code> to remove leading and trailing whitespace (including end-of-line characters).</li>
      <li>Use <code>file(<em>name</em>, <em>mode</em>)</code> to open a file for reading ('r'), writing ('w'), or appending ('a').</li>
      <li>Opening a file for writing erases any existing content.</li>
      <li>Use <code>file.readline</code> to read a line from a file.</li>
      <li>Use <code>file.close</code> to close an open file.</li>
      <li>Use <code>print &gt;&gt; file</code> to print to a file.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>

      <li>
        If <code>species.txt</code> is a text file,
        what do the following lines print?
<pre>
info = open('species.txt', 'r')
print info.readline().strip()
</pre>
      </li>

      <li>
        What does the following program leave in the file <code>output.txt</code>?
<pre>
results = open('output.txt', 'w')
results.write('first')
results.close()
results = open('output.txt', 'a')
results.write('second')
results.close()
</pre>
      </li>

      <li>
        If the file <code>square.txt</code> contains:
<pre>
abcde
fghij
klmno
</pre>
        what does the following program print?
<pre>
handle = open('square.txt', 'r')
result = len(handle)
handle.close()
print result
</pre>
      </li>

      <li>
        If <code>square.txt</code> contains the three lines shown above,
        and the file <code>final.txt</code> does not exist,
        what is the effect of the following program?
<pre>
reader = open('square.txt', 'r')
writer = open('final.txt', 'w')
writer = reader
reader.close()
writer.close()
</pre>
      </li>

    </ol>

  </div>

</section>

<section id="s:stdio">
  <h2>Standard Input and Output</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Explain what "importing a module" means and does.</li>
      <li>Write programs that import standard library modules.</li>
      <li>Explain what standard input and output are, and how they relate to the <a href="shell.html#b:pipefilter">pipe-and-filter</a> model.</li>
      <li>Write programs that read from standard input.</li>
      <li>Write programs that write to standard output.</li>
    </ul>
  </div>

  <p>
    Our program currently reads the header from <code>cochlear01.txt</code>
    every time we run it.
    There's not much point in that:
    what we really want is to read from any file,
    or from several files in turn.
    Doing that requires a bit of machinery we haven't seen yet,
    so let's solve a simpler problem:
    reading from standard input instead of from a file.
    Once we can do that,
    we can run our program as:
  </p>

<pre>
$ <span class="in">python first.py &lt; somefile.txt</span>
</pre>

  <p class="continue">
    or read from several files using:
  </p>

<pre>
$ <span class="in">for inputfile in cochlear*.txt
do
    python first.py &lt; $inputfile
done</span>
</pre>

  <p>
    Here's the modified program:
  </p>

<pre>
<span class="highlight">import sys
reader = sys.stdin</span>
first_line = reader.readline()
first_line = first_line.strip()
print first_line
reader.close()
</pre>

  <p class="continue">
    The two lines that have changed are highlighted at the top of the program.
    The first loads a library called <code>sys</code>,
    which connects Python to the system it is running on.
    The second line sets <code>reader</code> to be <code>sys.stdin</code>,
    which is just the standard input stream we met in
    <a href="shell.html#s:pipefilter:pipes">our discussion of pipes</a>.
    Nothing else changes,
    since standard input tries really hard to behave like an open file
    (<a class="figref" href="#f:replacing_with_stdin">Figure 9</a>).
    In particular,
    the object that <code>sys.stdin</code> (and hence <code>reader</code>) points at
    has a method with the same name and behavior as a file's <code>readline</code> method,
    and another with the same name and behavior as a file's <code>close</code>,
    so we can swap one for the other without having to modify anything else.
  </p>

  <figure id="f:replacing_with_stdin">
    <img src="python/replacing_with_stdin.png" alt="Replacing a File with Standard Input" />
    <figcaption>Figure 9: Replacing a File with Standard Input</figcaption>
  </figure>

  <div class="box">
    <h3>Interactive Testing</h3>

    <p>
      One other benefit of reading from standard input when no files are supplied
      is that it allows interactive testing:
      we can run our program
      and then just type in things we want it to read.
      If we do this,
      we must type control-D to signal the end of input
      (or control-Z in a Windows shell).
    </p>

  </div>

  <div class="box">
    <h3>Writing to Standard Output</h3>

    <p>
      Just as we can write to an open file using <code>print &gt;&gt; handle</code>,
      we can write to standard output using <code>print &gt;&gt; sys.stdout</code>.
      This is redundant, though,
      since <code>print</code> sends things to standard output by default.
    </p>

  </div>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>The operating system automatically gives every program three open "files" called standard input, standard output, and standard error.</li>
      <li>Standard input gets data from the keyboard, from a file when redirected with '&lt;', or from the previous stage in a pipeline with '|'.</li>
      <li>Standard output writes data to the screen, to a file when redirected with '&gt;', or to the next stage in a pipeline with '|'.</li>
      <li>Standard error also writes data to the screen, and is not redirected by '&gt;' or '|'.</li>
      <li>Use <code>import <em>library</em></code> to import a library.</li>
      <li>Use <code>library.thing</code> to refer to something imported from a library.</li>
      <li>The <code>sys</code> library provides open "files" called <code>sys.stdin</code> and <code>sys.stdout</code> for standard input and output.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>

      <li>
        What is the difference between:
<pre>
import sys
reader = sys.stdin
print len(reader.readline())
</pre>
        and:
<pre>
import sys
print len(sys.stdin.readline())
</pre>
      </li>

      <li>
        What is the error in the following program,
        and how would you fix it?
<pre>
import sys
sys.stdin = open('temporary.txt', 'w')
sys.stdin.write(123)
sys.stdin.close()
</pre>
      </li>

      <li>
        Nelle wants to copy the first line of <code>patients.txt</code>
        to the file <code>subjects.txt</code>
        using the shell command:
<pre>
$ <span class="in">python copier.py &gt; subjects.txt</span>
</pre>
        Fill in the blanks in the program below so that it does this.
<pre>
import sys
source = ________
line = ________
source.close()
________.________(line)
</pre>
      </li>

    </ol>

  </div>

</section>

<section id="s:for">
  <h2>Repeating Things</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Write a loop that processes the lines of a file.</li>
      <li>Trace the values taken on by a loop variable during execution of the loop.</li>
      <li>Explain what the "body" of a loop is, and correctly identify the bodies of loops.</li>
    </ul>
  </div>

  <p>
    Computers are useful because they can do lots of calculations on lots of data,
    which means we need a concise way to represent multiple steps:
    after all,
    writing out a million additions would take longer than doing them.
    Let's start by finding out how many lines we have in our data file,
    showing the prompts as the Python interpreter displays them:
  </p>

<pre>
&gt;&gt;&gt; reader = file('cochlear01.txt', 'r')
&gt;&gt;&gt; number = 0
&gt;&gt;&gt; for line in reader:
...    number = number + 1
&gt;&gt;&gt; reader.close()
&gt;&gt;&gt; print number, 'lines in file'
<span class="out">11 lines in file</span>
</pre>

  <p class="continue">
    Once again, we create a connection to the file using <code>file</code>.
    We then use a <a href="glossary.html#for-loop">for loop</a>
    to get one line from the file at a time.
    We don't do anything with the lines;
    instead,
    we add 1 to the value of <code>number</code> each time we see a new one.
    Once we're done,
    we close the file
    (so that other people and programs can access it safely)
    and report our findings
    (<a class="figref" href="#f:for_loop">Figure 10</a>).
  </p>

  <figure id="f:for_loop">
    <img src="python/for_loop.png" alt="For Loop" />
    <figcaption>Figure 10: For Loop</figcaption>
  </figure>

  <p>
    The indented line is called the <a href="glossary.html#loop-body">body</a> of the loop.
    It's the command that Python executes repeatedly.
    When Python is expecting us to type in the body of a loop interactively,
    it changes its prompt from <code>&gt;&gt;&gt;</code> to <code>...</code>
    as a reminder.
  </p>

  <p>
    The variable <code>line</code> is sometimes called
    the <a href="glossary.html#loop-variable">loop variable</a>.
    There's nothing special about its name:
    we could equally well have called it <code>something</code>.
    What's important is that the <code>for</code> loop repeatedly
    assigns a value to it,
    then executes the loop body one more time.
  </p>

  <p>
    Python always uses indentation to show what's in the body of a loop
    (or anything else&mdash;we'll see other things that have bodies soon).
    This means that:
  </p>

<pre>
for line in reader:
    print line.strip()
    print "done"
</pre>

  <p class="continue">
    and:
  </p>

<pre>
for line in reader:
    print line.strip()
print "done"
</pre>

  <p class="continue">
    behave differently.  The first one prints:
  </p>

<pre>
<span class="out">Subject: 1782
done
Date:    2012-05-21
done
Test     Run  Score
done
...</span>
</pre>

  <p class="continue">
    because the statement <code>print "done"</code> is inside the loop.
    The second prints:
  </p>

<pre>
<span class="out">Subject: 1782
Date:    2012-05-21
Test     Run  Score
...
volume   2    4.0
done
</span>
</pre>

  <p class="continue">
    because it is not.
  </p>

  <div class="box">
    <h3>Why Indentation?</h3>

    <p>
      Most other languages use visible markers to show the beginnings and ends of loop bodies,
      such as:
    </p>

<pre>
for value in data {
    print value
}
</pre>

    <p class="continue">
      or:
    </p>

<pre>
for value in data
begin
    print value
end
</pre>

    <p>
      Python uses indentation because studies of how people read programs have found
      that's what people actually pay attention to.
      If we write something as:
    </p>
<pre>
for value in data {
    print value
}
    print "done"
</pre>

    <p class="continue">
      then most people reading the code in a hurry will "see"
      the second <code>print</code> statement as part of the loop,
      even though it's not.
    </p>

  </div>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>Use <code>for <em>variable</em> in <em>something</em>:</code> to loop over the parts of something.</li>
      <li>The body of a loop must be indented consistently.</li>
      <li>The parts of a string are its characters; the parts of a file are its lines.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>

      <li>
        Suppose that the file <code>counts.txt</code> contains:
<pre>
1
2
3
</pre>
        What are the values of <code>result</code> and <code>data</code>
        each time the loop shown below is executed,
        and what are their final values?
<pre>
source = open('counts.txt', 'r')
result = 'result:'
for data in source:
    result = result + data.strip()
source.close()
print result
</pre>
      </li>

      <li>
        If <code>lines.txt</code> contains dozens or hundreds of lines,
        what is a good short description of what the following program does?
<pre>
source = open(lines.txt', 'r')
one = source.readline()
two = source.readline()
for next in source:
    one = two
    two = next
source.close()
print one
</pre>
      </li>

      <li>
        What does the following program print?
<pre>
text = 'abc'
for char in text:
    text = text + char
print text
</pre>
      </li>

    </ol>

  </div>

</section>

<section id="s:logic">
  <h2>Making Choices</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Trace the execution of conditional statements.</li>
      <li>Write conditional statements to perform selected statements only under specific conditions.</li>
      <li>Use logical operators to combine tests in conditional statements.</li>
      <li>Explain what "in-place operators" are, and correctly write statements using them.</li>
    </ul>
  </div>

  <p>
    Let's make another change to our program <code>first.py</code>.
    If you recall,
    our data files look like this:
  </p>

<pre>
Subject: 1782
Date:    2012-05-21
Test     Run  Score
----     ---  -----
range    1    3
range    2    5
discrim  1    1
discrim  2    1
discrim  4    1.5
volume   1    3.5
volume   2    4.0
</pre>

  <p class="continue">
    The first four lines aren't actually data,
    so we really shouldn't include them
    when we're counting how many records are in the file.
    We could "fix" this simply by counting the total number of lines
    and subtracting four:
  </p>

<pre>
<span class="comment"># second.py</span>
reader = file('cochlear01.txt', 'r')
number = 0
for line in reader:
    number = number + 1
reader.close()
print number - 4, 'records in file'
<span class="out">7 records in file</span>
</pre>

  <p class="continue">
    but that is fragile:
    if anyone ever puts more (or less) than four descriptive lines at the top of a data file,
    our count will be wrong again.
    What we <em>really</em> want to do is skip everything up to the dashed lines.
    We also want to check that all the scores are between 0 and 5.
  </p>

  <p>
    Let's step back and build up the machinery we need.
    Suppose that our data files contained nothing but a single number on each line:
  </p>

<pre>
3
5
<span class="highlight">-1</span>
1
1.5
<span class="highlight">7</span>
4.0
</pre>

  <p class="continue">
    (We have deliberately added two out-of-range values for our program to find.)
    Here's a program that reads the data
    and counts the number that fall outside the allowed range:
  </p>

<pre>
import sys
num_outliers = 0
for value in sys.stdin:
    if value &lt; 0:
        num_outliers = num_outliers + 1
    if value &gt; 5:
        num_outliers = num_outliers + 1
print num_outliers, "values out of range"
</pre>

  <p class="continue">
    The command <code>if</code> means exactly what it does in English:
    if a particular condition is true,
    then do the statement or statements that are in the <code>if</code> statement's body
    (i.e., indented underneath it).
    Here,
    we are using one <code>if</code> to see if the current value is less than 0,
    and another to see if it is greater than 5.
    In either case,
    we add one to the count of outliers.
    If neither condition is satisfied,
    the value is clean,
    and <code>num_outliers</code> won't be changed in that loop
    (<a class="figref" href="#f:loop_cond_flow">Figure 11</a>).
  </p>

  <figure id="f:loop_cond_flow">
    <img src="python/loop_cond_flow.png" alt="Conditional Execution" />
    <figcaption>Figure 11: Conditional Execution</figcaption>
  </figure>

  <p>
    When we run this program, though,
    it reports that all of the values in the input are outliers:
  </p>

<pre>
$ <span class="in">python second.py &lt; cochlear01.txt</span>
<span class="out">7 values out of range</span>
</pre>

  <p class="continue">
    The problem is once again one of types:
    the loop variable <code>line</code> holds a string like <code>'3'</code>,
    not the number 3,
    and all strings are greater than all numbers:
  </p>

<pre>
'hello' &gt; 0
<span class="out">True</span>
</pre>

  <p>
    The fix is straightforward&mdash;we just have to convert
    all the strings to numbers before we do the comparison:
  </p>

<pre>
import sys
num_outliers = 0
for <span class="highlight">line</span> in sys.stdin:
    <span class="highlight">value = float(line)</span>
    if value &lt; 0:
        num_outliers = num_outliers + 1
    if value &gt; 5:
        num_outliers = num_outliers + 1
print num_outliers, "values out of range"
<span class="out">2 values out of range</span>
</pre>

  <div class="box">
    <h3>Why Isn't It An Error?</h3>

    <p>
      Take a closer look at the original verison of the outlier counter,
      which produced the wrong answer:
    </p>

<pre>
for value in sys.stdin:
    if value &lt; 0:
        num_outliers = num_outliers + 1
    ...
</pre>

    <p>
      Why did this produce the wrong answer
      rather than an error message?
      If <code>value</code> contains a string
      and 0 is an integer,
      <code>value+0</code> is an error&mdash;why
      isn't <code>value&lt;0</code> also an error?
    </p>

    <p>
      The answer is that Python always lets us compare things,
      no matter what the types of those things are.
      We can't add a string and a number,
      but we can ask which is greater,
      whether they're equal,
      and so on.
      Python does this so that it can always sort things,
      even if those things have different types,
      and sorting only works if we can compare things.
      We'll revisit sorting <a href="#a:sorting">later</a>.
    </p>
  </div>

  <p>
    Let's make this program a little more readable.
    First,
    we'll combine our two tests using <code>or</code>
    so that the statement that adds one to <code>num_outliers</code>
    doesn't have to be duplicated:
  </p>

<pre>
import sys
num_outliers = 0
for line in sys.stdin:
    value = float(line)
    if (value &lt; 0) or (value &gt; 5):
        num_outliers = num_outliers + 1
print num_outliers, "values out of range"
</pre>

  <p class="continue">
    Alternatively,
    we could count how many values are in range using <code>and</code>:
  </p>

<pre>
import sys
num_valid = 0
for line in sys.stdin:
    value = float(line)
    if (0 &lt;= value) and (value &lt;= 5):
        num_valid = num_valid + 1
print num_valid, "values in range"
</pre>

  <p class="continue">
    which tells us that five values are in range.
    We can simplify the test even further by writing it the way a mathematician would:
  </p>

<pre>
import sys
num_valid = 0
for line in data:
    value = float(line)
    if <span class="highlight">0 &lt;= value &lt;= 5</span>:
        num_valid = num_valid + 1
print num_valid, "values in range"
</pre>

  <p>
    And if we want to count in-range values and outliers at the same time,
    we can use <code>else</code>.
    Its block of code is executed when
    the code in the <code>if</code> it's paired with
    <em>isn't</em> executed
    (<a class="figref" href="#f:else_flow">Figure 12</a>):
  </p>

  <figure id="f:else_flow">
    <img src="python/else_flow.png" alt="If and Else" />
    <figcaption>Figure 12: If and Else</figcaption>
  </figure>

<pre>
import sys
num_outliers = 0
num_valid = 0
for line in sys.stdin:
    value = float(line)
    if 0 &lt;= value &lt;= 5:
        num_valid = num_valid + 1
    else:
        num_outliers = num_outliers + 1
print num_valid, "in range and", num_outliers, "outliers"
</pre>

  <div class="box">
    <h3>Alternatives</h3>

    <p>
      <code>if</code> lets us check a particular condition,
      and <code>else</code> does something when the <code>if</code> failed.
      Python has a third keyword <code>elif</code> that combines the two:
      it tests a condition,
      but only when all preceding tests have failed.
      For example,
      we can categorize test subjects as follows:
    </p>

<pre>
if age &lt; 12:
    category = 'child'
elif age &lt; 20:
    category = 'teen'
elif age &lt; 40:
    category = 'young adult'
elif age &lt; 65:
    category = 'middle-aged'
else:
    category = 'senior'
</pre>

    <p>
      As <a class="figref" href="#f:elif">Figure 13</a> shows,
      at most one path is taken through this conditional.
    </p>

    <figure id="f:elif">
      <img src="python/elif.png" alt="If/Elif/Else" />
      <figcaption>Figure 13: If/Elif/Else</figcaption>
    </figure>

  </div>

  <p>
    Finally,
    we have seen expressions like:
  </p>

<pre>
num_valid = num_valid + 1
</pre>

  <p class="continue">
    several times now.
    In Python and many other languages,
    we can simplify this by writing:
  </p>

<pre>
num_valid += 1
</pre>

  <p class="continue">
    which means,
    "Update the value on the left using addition with the value on the right."
    Similarly,
    we could double the value in the variable <code>something</code>
    like this:
  </p>

<pre>
something *= 2
</pre>

  <p class="continue">
    and so on for other binary (two-valued) operators.
    It may seem like a small saving,
    but it actually prevents a lot of bugs
    by eliminating duplicated code.
  </p>
  
  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>Use <code>if <em>test</em></code> to do something only when a condition is true.</li>
      <li>Use <code>else</code> to do something when a preceding <code>if</code> test is not true.</li>
      <li>The body of an <code>if</code> or <code>else</code> must be indented consistently.</li>
      <li>Combine tests using <code>and</code> and <code>or</code>.</li>
      <li>Use '&lt;', '&lt;=', '&gt;=', and '&gt;' to compare numbers or strings.</li>
      <li>Use '==' to test for equality and '!=' to test for inequality.</li>
      <li>Use <code><em>variable</em> += <em>expression</em></code> as a shorthand for <code><em>variable</em> = <em>variable</em> + <em>expression</em></code> (and similarly for other arithmetic operations).</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>
      <li>
        What is the value of <code>x</code> after executing the code shown below?
<pre>
x = 1
x += x + 1
</pre>
        Should you write code this way?
        Why or why not?
      </li>

      <li>
        What change must be made to the following code
        (if any)
        so that it prints the word "one"?
<pre>
major = 5 &gt; 0
minor = 0.5 &lt;= 0
if major and minor:
    print 'both'
elif major or minor:
    print 'one'
else:
    print 'neither'
</pre>
      </li>

      <li>
        A program starts with these two lines:
<pre>
color = 'green'
shape = 'triangle'
</pre>
        Which of the blocks of code shown below
        changes the shape to a square
        without changing the color?
        <table>
          <tr>
            <td valign="top">A</td>
            <td valign="top">
<pre>
if color == 'green':
    shape = 'square'
elif shape == 'square':
    color = 'red'
</pre>
            </td>
          </tr>
          <tr>
             <td valign="top">B</td>
             <td valign="top">
<pre>
if color == 'green':
    shape = 'square'
if shape == 'square':
    color = 'red'
</pre>
             </td>
          </tr>
          <tr>
            <td valign="top">C</td>
            <td valign="top">
<pre>
if color == 'green' or shape == 'square':
    shape = 'circle'
if shape == 'square':
    color = 'red'
</pre>
            </td>
            <tr>
              <td valign="top">D</td>
              <td valign="top">
<pre>
if color == 'green':
    if shape != 'triangle':
        shape = 'circle'
else:
    shape = 'square'
</pre>
              </td>
            </tr>
        </table>
      </li>

      <li>
        Python allows programmers to attach an <code>else</code> to a <code>for</code> loop:
<pre>
name = ''
for char in name:
    print char
else:
    print 'nothing in name'
</pre>
        When would you use this in a data analysis program?
      </li>

    </ol>

  </div>

</section>

<section id="s:flag">
  <h2>Flags</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Explain the difference between Boolean expressions and Boolean values.</li>
      <li>Write statements that create and store Boolean values, and use them correctly in conditional statements.</li>
      <li>Write examples showing how to keep track of events using flag variables.</li>
    </ul>
  </div>

  <p>
    We're used to thinking of "less than" and "equal to" as adjectives.
    In a program,
    though,
    an expression like <code>value &lt; 0</code> produces one of two values
    called (unsurprisingly) <code>True</code> and <code>False</code>.
    These are called <a href="glossary.html#boolean">Boolean values</a>,
    after the English mathematician George Boole,
    and they can be assigned to variables like any other kind of values:
  </p>

<pre>
x = 5
is_less_than = x &lt; 0
print is_less_than
<span class="out">False</span>
</pre>

  <p>
    It's very common to assign <code>True</code> and <code>False</code> to variables
    to keep track of whether some event has happened.
    For example,
    we could create a variable called <code>have_seen_dashed_line</code>
    to keep track of whether or not we have seen the dashed line that separates
    the header in a data file from the actual data.
    Its initial value will be <code>False</code>,
    because we obviously haven't seen the dashed line before we've read any input.
    As soon as we do see the dashed line,
    we set it to <code>True</code>:
  </p>

<pre>
import sys
have_seen_dashed_line = False
for line in data:
    if line.startswith('---'):
        have_seen_dashed_line = True
print 'Did we ever see the dashed line?', have_seen_dashed_line
<span class="out">True</span>
</pre>

  <p>
    A variable that is used this way is often called
    a <a href="glossary.html#flag">flag</a>.
    We can use the <code>have_seen_dashed_line</code> flag's value
    to decide whether or not to count a line as data:
  </p>

<pre>
import sys
have_seen_dashed_line = False
number = 0
for line in data:
    if line.startswith('---'):
        have_seen_dashed_line = True
    if have_seen_dashed_line:
        number = number + 1
print 'Number of data lines:', number
<span class="out">Number of data lines: 8</span>
</pre>

  <figure id="f:set_and_increment">
    <img src="python/set_and_increment.png" alt="Flagging and Incrementing" />
    <figcaption>Figure 14: Flagging and Incrementing</figcaption>
  </figure>

  <p>
    Whoops&mdash;that's almost right, but not quite.
    There are only 7 data lines in our file:
    why are we reporting 8?
    The reason is that when we see the dashed line,
    we set <code>have_seen_dashed_line</code> to <code>True</code>,
    then immediately check its value,
    see that it's true,
    and increment <code>number</code>
    (<a class="figref" href="#f:set_and_increment">Figure 14</a>).
    What we want to do is <em>either</em> set the flag
    (so that we'll start incrementing on the next iteration),
    <em>or</em> add one to <code>number</code>.
    Here's the fixed program:
  </p>

<pre>
import sys
have_seen_dashed_line = False
number = 0
for line in data:
    if line.startswith('---'):
        have_seen_dashed_line = True
<span class="highlight">    else:
        if have_seen_dashed_line:
            number = number + 1</span>
print 'Number of data lines:', number
<span class="out">Number of data lines: 7</span>
</pre>

  <p>
    And here's a version that combines the second <code>if</code>
    with the <code>else</code>
    using <code>elif</code>:
  </p>

<pre>
import sys
have_seen_dashed_line = False
number = 0
for line in data:
    if line.startswith('---'):
        have_seen_dashed_line = True
    elif have_seen_dashed_line:
        number = number + 1
print 'Number of data lines:', number
<span class="out">Number of data lines: 7</span>
</pre>

  <p class="continue">
    Organizing our choices this way makes it clearer that
    exactly one will be executed.
  </p>

  <div class="keypoints" id="k:flag">
    <h3>Summary</h3>
    <ul>
      <li>The two Boolean values <code>True</code> and <code>False</code> can be assigned to variables like any other values.</li>
      <li>Programs often use Boolean values as flags to indicate whether something has happened yet or not.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>
      <li>
        When converted to numbers,
        <code>True</code> has the value 1 and <code>False</code> has the value 0:
<pre>
print True + True + False
<span class="out">2</span>
</pre>
        Knowing this,
        explain what the following does and why it works:
<pre>
in_range += 0 &lt;= number &lt;= 5
</pre>
        Do you think this is readable or not?
        Do you think your opinion will change over the next few months or not?
      </li>

      <li>
        Using the same relationship between Boolean values and numbers,
        explain why <code>5 &lt; 0 &lt; 10</code> is <code>False</code>,
        but <code>(5 &lt; 0) &lt; 10</code> is <code>True</code>.
      </li>

      <li>
        Python considers zero and the empty string equivalent to be false,
        and all non-zero numbers and non-empty strings equivalent to be true.
        Knowing that,
        how can you simplify the following lines of code:
<pre>
if len(some_string) != 0:
    print 'string is not empty'
elif some_number != 0:
    print 'number is not zero'
elif some_flag == True:
    print 'flag is true'
</pre>
      </li>

      <li>
        Aurora has inherited some audio sample files
        in which regions are marked with the words "begin" and "end":
<pre>
4.1
4.3
begin
7.2
7.9
8.1
end
5.5
begin
12.0
11.5
end
9.2
</pre>
        She wants to add up the values that lie within each marked region,
        so that for the sample data shown above,
        her program's output would be:
<pre>
<span class="out">23.2
23.5</span>
</pre>
        Fill in the program shown below to do this.
<pre>
import sys
in_region = False
current = 0.0
for line in sys.stdin:
    line = line.strip()
    if in_region:
        if line == 'end':
            print current
            ________
        else:
            ________
    else:
        if line == ________:
            ________
            current = 0.0
print current
</pre>
        Why is the final <code>print</code> statement needed?
        How will the output of the program be wrong without it?
      </li>

    </ol>

  </div>

</section>

<section id="s:parse">
  <h2>Reading Data Files</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Read a simple columnar data file and operate on its values.</li>
    </ul>
  </div>

  <p>
    It's finally time to clean up Aurora's actual cochlear implant data files.
    Once again,
    these files typically look like this:
  </p>

<pre>
Subject: 1782
Date:    2012-05-21
Test     Run  Score
----     ---  -----
range    1    3
range    2    5
discrim  1    1
discrim  2    1
discrim  4    1.5
volume   1    3.5
volume   2    4.0
</pre>

  <p>
    We already know how to ignore everything
    up to and including the dash line:
  </p>

<pre>
import sys
have_seen_dashed_line = False
number = 0
for line in data:
    if line.startswith('---'):
        have_seen_dashed_line = True
    elif have_seen_dashed_line:
        number = number + 1
print 'Number of data lines:', number
</pre>

  <p class="continue">
    Let's put that in a file called <code>check.py</code>
    and modify it to report scores that are outside the range 0&ndash;5.
    First,
    we need a way to break each line into columns.
    Luckily for us,
    strings know how to split themselves into fields:
  </p>
  
<pre>
&gt;&gt;&gt; typical_line = 'volume   2    4.0'
&gt;&gt;&gt; name, number, score = typical_line.split()
&gt;&gt;&gt; name
'volume'
&gt;&gt;&gt; number
'2'
&gt;&gt;&gt; score
'4.0'
</pre>

  <p class="continue">
    The <code>string.split</code> returns as many new strings
    as there are whitespace-separated fields in the original string.
    In our case,
    there are three fields,
    so we can assign them result of <code>split</code> to three separate variables simultaneously.
    The third field,
    which we have put in the variable <code>score</code>,
    is a string;
    if we want its value as a floating-point number,
    we'll have to convert it using the <code>float</code> function.
    Combining this code with the program we already had,
    we get:
  </p>

<pre>
import sys
have_seen_dashed_line = False
for line in data:
    if line.startswith('---'):
        have_seen_dashed_line = True
    elif have_seen_dashed_line:
<span class="highlight">        name, number, score = line.split()
        score = float(score)</span>
</pre>

  <p>
    A simple <code>if</code> statement is the last piece of the puzzle:
  </p>

<pre>
import sys
have_seen_dashed_line = False
for line in data:
    if line.startswith('---'):
        have_seen_dashed_line = True
    elif have_seen_dashed_line:
        name, number, score = line.split()
        score = float(score)
<span class="highlight">        if (score &lt; 0.0) or (score &gt; 5.0):
            print 'Out of range:', name, number, score</span>
</pre>

  <p>
    This program doesn't produce any output
    when we run it on our original data file
    because all the scores in the file are valid:
  </p>

<pre>
$ <span class="in">python check.py &lt; cochlear01.txt</span>
$
</pre>

  <p class="continue">
    But if we make some of the scores invalid,
    like this:
  </p>

<pre>
Subject: 1782
Date:    2012-05-21
Test     Run  Score
----     ---  -----
range    1    3
range    2    <span class="highlight">7.5</span>
discrim  1    1
discrim  2    1
discrim  4    1.5
volume   1    <span class="highlight">-3</span>
volume   2    4.0
</pre>

  <p class="continue">
    then the output changes to:
  </p>

<pre>
<span class="out">Out of range: range 2 7.5
Out of range: volume 1 -3.0</span>
</pre>

  <p class="continue">
    which is what we wanted.
  </p>

  <div class="box">
    <h3>When Not To Do This</h3>

    <p>
      The technical term for extracting information from a file
      that has some internal structure
      is <a href="glossary.html#parsing">parsing</a>.
      Most of the time,
      you <em>don't</em> want to do this.
      Instead,
      you want to use a parser that someone else has already written and tested.
      We'll meet a few later in this lesson;
      for now,
      though,
      learning how to get values out of files
      is a good way to learn basic programming concepts.
    </p>
  </div>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>Use <code>str.split()</code> to split a string into pieces on whitespace.</li>
      <li>Values can be assigned to any number of variables at once.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>
      <li>
        What does this program calculate?
<pre>
for line in open('columns.txt', 'r'):
    first, second = line.strip().split()
    print int(first) + int(second)
</pre>
      </li>

      <li>
        Explain what this program does,
        and give an example of five or six lines of input
        that will cause each line in this program to be executed
        at least once.
<pre>
import sys
total = 0.0
for line in sys.stdin:
    if line.startswith('#'):
        print total
        total = 0.0
    else:
        total += float(line)
</pre>
      </li>

      <li>
        Explain what this program does:
<pre>
import sys
largest = 0
for line in sys.stdin:
    if '#' in line:
        line, rest = line.split('#')
    largest = max(largest, len(line.strip()))
print largest
</pre>
      </li>

      <li>
        Explain what this program does:
<pre>
import sys
for line in sys.stdin:
    line = line.strip()
    if line:
        print line
</pre>
      </li>

    </ol>
  </div>

</section>

<section id="s:lists">
  <h2>Lists</h2>

  <p class="fixme">explain slicing</p>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Explain why it is useful to store many values together.</li>
      <li>Write programs that create and manipulate lists of numbers and strings.</li>
      <li>Write programs that use loops to operate independently on each value in a list.</li>
      <li>Explain why programs should be tested on short, simple inputs first.</li>
      <li>Explain the difference between mutable and immutable values.</li>
      <li>Index a list to retrieve values at specific locations.</li>
      <li>Show how to alter the values in a list.</li>
      <li>Trace changes to a list's values as a result of assignment.</li>
      <li>Explain what an "out-of-bounds error" is, and give an example showing when one would occur.</li>
      <li>Show how to generate all the valid indices for a list's elements.</li>
      <li>Explain when it is appropriate to use short or long variable names, and why.</li>
    </ul>
  </div>

  <p>
    Loops give us a way to do many operations by repeating a few instructions.
    Lists give us a way to store many values under one name,
    so that we can do the same things to all of them.
    To start our exploration of lists,
    let's run an interpreter and try this:
  </p>

<pre>
data = [1, 3, 5]
for value in data:
    print value
<span class="out">1
3
5</span>
</pre>

  <p>
    <code>[1, 3, 5]</code> is a <a href="glossary.html#list">list</a>:
    a single object that stores multiple values
    (<a class="figref" href="#f:simple_list">Figure 15</a>).
    Just as a <code>for</code> loop over an open file
    reads lines from that file one by one
    and assigns them to the loop variable,
    a <code>for</code> loop over a list assigns each value in the list
    to the loop variable in turn.
  </p>

  <figure id="f:simple_list">
    <img src="python/simple_list.png" alt="A Simple List" />
    <figcaption>Figure 15: A Simple List</figcaption>
  </figure>

  <p>
    Let's do something a bit more useful with those numbers:
  </p>

<pre>
data = [1, 4, 2, 3, 3, 4, 3, 4, 1]
total = 0
for n in data:
    total += n
mean = total / len(data)
print "mean is", mean
<span class="out">mean is 2</span>
</pre>

  <p class="continue">
    This loop adds each value in the list to <code>total</code>.
    Once the loop is over,
    we divide <code>total</code> by the length of the list,
    which we find using the built-in function <code>len</code>.
  </p>

  <p>
    The result should be the average of the values in the list,
    but what we get isn't quite right.
    The total of the numbers in the list is 25,
    but we're printing 2 instead of 25/9
    (which is 2.7777&hellip;).
    The problem (once again) is that we're dividing one integer by another,
    which throws away the remainder.
    We can fix this by initializing <code>total</code> to 0.0
    (so that all the additions involve a floating-point number and an integer,
    which produces a floating-point number),
    or by using the <code>float</code> function to do the conversion explicitly:
  </p>

<pre>
data = [1, 4, 2, 3, 3, 4, 3, 4, 1]
total = 0
for n in data:
    total += n
mean = <span class="highlight">float(total)</span> / len(data)
print "mean is", mean
<span class="out">mean is 2.77777777778</span>
</pre>

  <p>
    The <em>real</em> problem isn't a matter of integers versus floats, though.
    The real problem with this program is that
    we didn't know whether the answer was right or wrong,
    so we couldn't tell if the program was correct or not.
    After all,
    the average of these nine numbers might well have been 2.
  </p>
  
  <p>
    The fact that a program runs without crashing doesn't mean it's correct.
    One way to make programs easier to check
    is to run them on smaller or more regular data.
    For example,
    If we ran the program on <code>[1, 4]</code>,
    we'd probably notice that we were getting 2 instead of 2.5.
    Writing programs so that they're checkable is another idea
    that we'll explore in detail <a href="quality.html">later</a>.
  </p>

  <div class="box">
    <h3>Even Simpler</h3>

    <p>
      Python actually has a built-in function called <code>sum</code>,
      so we can get rid of the loop entirely:
    </p>

<pre>
total = sum(data)
print "mean is", float(total) / len(data)
</pre>

    <p class="continue">
      and shorten this even further by calling <code>float</code>
      directly on the result of <code>sum</code>:
    </p>

<pre>
print "mean is", float(sum(data)) / len(data)
</pre>

    <p>
      <code>float(sum(data))</code> is like <em>sin(log(x))</em>:
      the inner function is evaluated first,
      and its result is used as the input to the outer function.
      It's important to get the parentheses in the right place,
      since the expressions:
    </p>
    
<pre>
float(sum(data)) / len(data)
</pre>

    <p class="continue">
      and
    </p>

<pre>
float(sum(data) / len(data))
</pre>

    <p class="continue">
      calculate different things.
      In the first,
      <code>float</code> is applied to <code>sum(data)</code>,
      i.e.,
      Python adds up all the numbers,
      then converts the result to a floating-point value
      before dividing by <code>len(data)</code>
      to get the mean.
    </p>

    <p>
      In the second,
      Python adds up the numbers,
      divides by <code>len(data)</code> to get an integer result,
      and then converts that integer to a floating point number.
      This is just our original bug in a more compact form.
      Once again,
      the only way to guard against it is to test the program.
    </p>

  </div>

  <p>
    Lists are probably used more than any other data structure in programming,
    so let's have a closer look at them.
    First,
    lists are <a href="glossary.html#mutable">mutable</a>,
    i.e.,
    they can be changed after they are created:
  </p>
  
<pre>
data = [1, 4, 2, 3]
result = []
current = 0
for n in data:
    current = current + n
    result.append(current)
print "running total:", result
<span class="out">[1, 5, 7, 10]</span>
</pre>

  <p class="continue">
    <code>result</code> starts off as an <a href="glossary.html#empty-list">empty list</a>,
    and <code>current</code> starts off as zero
    (<a class="figref" href="#f:running_total">Figure 16</a>).
    Each time the loop executes&mdash;i.e.,
    for each number in <code>values</code>&mdash;Python
    adds the next value in the list to <code>current</code>
    to calculate the running total.
    It then append this value to <code>result</code>,
    so that when the program finishes,
    we have a complete list of partial sums.
  </p>

  <figure id="f:running_total">
    <img src="python/running_total.png" alt="Running Total" />
    <figcaption>Figure 16: Running Total</figcaption>
  </figure>

  <p>
    What if we want to double the values in <code>data</code> in place?
    We could try this:
  </p>

<pre>
data = [1, 4, 2, 3]
for n in data:
    n = 2 * n
print "doubled data is:", data
<span class="out">doubled data is [1, 4, 2, 3]</span>
</pre>

  <p class="continue">
    but as we can see,
    it doesn't work.
    When Python calculates <code>2*n</code>,
    it creates a new value in memory
    (<a class="figref" href="#f:doubling_list">Figure 17</a>).
    It then makes the variable <code>n</code> point at the value for a few microseconds
    before going around the loop again
    and pointing <code>n</code> at the next value from the list instead.
    Since nothing is pointing to the temporary value we just created any longer,
    Python throws it away.
  </p>

  <figure id="f:doubling_list">
    <img src="python/doubling_list.png" alt="Failed Attempt to Double Values in a List" />
    <figcaption>Figure 16: Failed Attempt to Double Values in a List</figcaption>
  </figure>

  <p>
    The solution to our problem is to <a href="glossary.html#list-indexing">index</a> the list,
    which is just like subscripting a vector in mathematics.
    Here are some examples:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">scientists = ["Newton", "Darwing", "Turing"]</span>
&gt;&gt;&gt; <span class="in">print "length:", len(scientists)</span>
<span class="out">length: 3</span>
&gt;&gt;&gt; <span class="in">print "first element:", scientists[0]</span>
<span class="out">first element: Newton</span>
&gt;&gt;&gt; <span class="in">print "second element:", scientists[1]</span>
<span class="out">second element: Darwing</span>
&gt;&gt;&gt; <span class="in">print "third element:", scientists[2]</span>
<span class="out">third element: Turing</span>
</pre>

  <div class="box">
    <h3>It Seemed Like a Good Idea at the Time</h3>

    <p>
      For reasons that made sense in 1970,
      when the C programming language was invented,
      Python lists are indexed from 0 to N-1 rather than 1 to N.
      C++, C#, Java, and other languages that imitate C also use 0 to N-1,
      while Fortran, Pascal, MATLAB,
      and other languages that imitate human beings use 1 to N.
    </p>

  </div>

  <p>
    How does indexing help us?
    Well,
    after noticing that we have misspelled Darwin's name as "Darwing",
    we can fix it by assigning a new value to that location in the list:
  </p>

<pre>
scientists[1] = "Darwin"
print scientists
<span class="out">["Newton", "Darwin", "Turing"]</span>
</pre>

  <p class="continue">
    <a class="figref" href="#f:update_list">Figure 18</a> shows
    the list before and after the change.
    Again,
    once we've made the update,
    nothing is pointing to the string "Darwing" with a "g" on the end,
    so the memory it's using is recycled.
  </p>

  <figure id="f:update_list">
    <img src="python/update_list.png" alt="Successfully Doubling Values in a List" />
    <figcaption>Figure 17: Successfully Doubling Values in a List</figcaption>
  </figure>

  <p>
    In order for Python to give us a sensible value,
    the index we provide for a list must be in range,
    i.e.,
    between 0 and one less than the length of the list.
    If it's too large,
    we get an error message:
  </p>

<pre>
scientists = ["Newton", "Darwin", "Turing"]
print scientists[55]
<span class="err">Traceback (most recent call last):
  File "list-04.py", line 2, in &lt;module&gt;
    print "out of range:", scientists[55]
IndexError: list index out of range</span>
</pre>

  <p class="continue">
    The error message doesn't appear
    until Python actually tries to fetch the out-of-bounds value.
    If this is in the middle of some other operation,
    we may see some partial output before our error message:
  </p>

<pre>
scientists = ["Newton", "Darwin", "Turing"]
print "out of range:", scientists[55]
<span class="out">out of range:</span>
<span class="err">Traceback (most recent call last):
  File "list-04.py", line 2, in &lt;module&gt;
    print "out of range:", scientists[55]
IndexError: list index out of range</span>
</pre>

  <div class="box">
    <h3>Useful but not Intuitive</h3>

    <p>
      Here's something else that's useful.
      In Python (but <em>not</em> in most other languages),
      negative indices count backward from the end of a list:
    </p>

<pre>
scientists = ["Newton", "Darwin", "Turing"]
print "last:", scientists[-1]
print "penultimate:", scientists[-2]
<span class="out">last: Turing
penultimate: Darwin</span>
</pre>

    <p class="continue">
      It's a lot easier to type <code>scientists[-1]</code>
      than <code>scientists[len(scientists)-1]</code>
      to get the last item in a list,
      but it does take some getting used to.
    </p>
  </div>
    
  <p>
    Back to our original problem of doubling values in place.
    We now know that we can do this:
  </p>

<pre>
data = [1, 4, 2]
data[0] = 2 * data[0]
data[1] = 2 * data[1]
data[2] = 2 * data[2]
print "doubled data is:", data
<span class="out">doubled data is [2, 8, 4]</span>
</pre>

  <p class="continue">
    but it clearly doesn't scale:
    we're not going to write a million statements
    to update a list of a million values.
    We need to use a loop,
    but instead of looping over the values in the list,
    we want to loop over the allowed indices of the list.
    To do this,
    we will rely on a function called <code>range</code>
    which creates a list of the first N integers:
  </p>

<pre>
print range(5)
<span class="out">[0, 1, 2, 3, 4]</span>
</pre>

  <p>
    Once again,
    the values go from 0 to one less than the number given to <code>range</code>,
    which just happens to be exactly the indices of a list of that length.
    Let's try it out:
  </p>

<pre>
data = [1, 4, 2]
indices = range(3)
for i in indices:
    print i, data[i]
<span class="out">0 1
1 4
2 2</span>
</pre>

  <p class="continue">
    then fold the call to <code>range</code> into the loop:
  </p>

<pre>
data = [1, 4, 2]
for i in <span class="highlight">range(3)</span>:
    print i, data[i]
<span class="out">0 1
1 4
2 2</span>
</pre>

  <p>
    This program is correct, but fragile:
    if we add more values to the list,
    Python will still only execute the loop three times,
    so we'll still only print the first three values in the list:
  </p>

<pre>
data = [1, 4, 2<span class="highlight">, 5, 1, 3</span>]
for i in range(3):
    print i, data[i]
<span class="out">0 1
1 4
2 2</span>
</pre>

  <p>
    What we want is for the loop to automatically adjust itself
    based on the length of the list:
  </p>

<pre>
data = [1, 4, 2, 5, 1, 3]
<span class="highlight">data_length = len(data)</span>
for i in range(<span class="highlight">data_length</span>):
    print i, data[i]
<span class="out">0 1
1 4
2 2
3 5
4 1
5 3</span>
</pre>

  <p>
    We can now get rid of the variable <code>data_length</code>
    by putting the call to <code>len(data)</code>
    inside the call to <code>range</code>:
  </p>

<pre>
data = [1, 4, 2, 5, 1, 3]
for i in range(<span class="highlight">len(data)</span>):
    print i, data[i]
<span class="out">0 1
1 4
2 2
3 5
4 1
5 3</span>
</pre>

  <p class="continue">
    Again,
    <code>range(len(data))</code> is like <em>sin(log(x))</em>:
    the inner function is evaluated first,
    and its result becomes the input to the outer function.
    Put together like this,
    they are a common <a href="glossary.html#idiom">idiom</a> in Python,
    i.e.,
    a way of saying something that everyone recognizes and uses.
    When an experienced programmer sees:
  </p>

<pre>
for i in range(len(something)):
</pre>

  <p class="continue">
    what she "hears" is:
  </p>

<pre>
for each legal index of something:
</pre>

  <p>
    The reason this idiom is better than what we started with is that
    there is no duplicated information.
    Instead of having a list of length 3,
    and looping from 0 up to 3,
    we have a list of any length whatever,
    and loop from 0 up to that length.
    In general,
    anything that is repeated two or more times in a program
    will eventually be wrong in at least one.
    Putting it another way,
    any piece of information should appear exactly once in a program,
    so that if it needs to change,
    it only needs to be changed in one place.
  </p>

  <div class="box">
    <h3>Short and Long Variable Names</h3>

    <p>
      We have said several times that programs should use meaningful variable names.
      Are we not violating our own rule by using <code>i</code> as a variable in this program?
      The short answer is "yes", but it's a defensible violation.
      Suppose we re-write our loop as:
    </p>

<pre>
data = [1, 4, 2, 5, 1, 3]
for location in range(len(data)):
    print location, data[location]
</pre>

    <p class="continue">
      The longer name are more meaningful,
      but it also takes longer to read.
      Since the original <code>i</code> is only used for a few lines,
      users will easily be able to keep its meaning in short-term memory
      as long as they need to.
      On balance,
      therefore,
      the short name are better in this case.
    </p>

    <p>
      This is actually a general principle in program design.
      A variable that holds a simple value,
      and is only used in a few adjacent lines of code,
      can (and usually should) have a short name.
      A variable that holds a complex value,
      or one which is used over more than a few lines of code,
      should have a longer name
      in order to optimize the tradeoff between reading speed
      and the limitations of human short-term memory.
    </p>

  </div>

  <p>
    Let's finally go back and double the values in place:
  </p>

<pre>
data = [1, 4, 2, 5, 3, 4, 5]
for i in range(len(data)):
    data[i] = 2 * data[i]
print data
<span class="out">[2, 8, 4, 10, 6, 8, 10]</span>
</pre>

  <div class="box">
    <h3>Left and Right</h3>

    <p>
      Seeing the expression <em>x = 2x</em>,
      most mathematicians would say,
      "Right&mdash;so <em>x</em> is zero."
      Seeing the same expression,
      most programmers would say,
      "Right&mdash;you're doubling the value of <em>x</em>."
      <a class="figref" href="#f:double_in_place">Figure 19</a> shows
      how that actually works:
    </p>

    <ol>

      <li>
        Python reads the current value of <code>x</code> from memory.
      </li>

      <li>
        It multiplies that value by 2,
        storing the result in a temporary location&hellip;
      </li>

      <li>
        &hellip;and then modifies <code>x</code> to point at the new value.
      </li>

    </ol>

    <figure id="f:double_in_place">
      <img src="python/double_in_place.png" alt="Doubling in Place" />
      <figcaption>Figure 18: Doubling in Place</figcaption>
    </figure>

    <p>
      Now look at what happens when Python execute the statements:
    </p>

<pre>
x = 5
y = x
x = 2 * x
</pre>

    <ol>

      <li>
        The variable <code>x</code> is created,
        and set to point at the value 5
        (<a class="figref" href="#f:new_values_for_variables">Figure 20</a>).
      </li>

      <li>
        The variable <code>y</code> is created,
        and set to point at the same value.
      </li>

      <li>
        The value 10 (i.e., 2&times;5) is created and stored in a temporary location.
      </li>

      <li>
        <code>x</code> is altered to point at that value.
      </li>

    </ol>

    <figure id="f:new_values_for_variables">
      <img src="python/new_values_for_variables.png" alt="New Values for Variables" />
      <figcaption>Figure 19: New Values for Variables</figcaption>
    </figure>

    <p>
      After these operations are complete,
      <code>y</code> is left pointing at the original value, 5.
      It does <em>not</em> point at the same thing <code>x</code> does any longer,
      and its value is <em>not</em> automatically recalculated
      to keep it twice the value of <code>x</code>.
    </p>

  </div>

  <div class="box">
    <h3>Even More Idiomatic</h3>

    <p>
      There's an even better way to do this job.
      Python allows us to assign values to multiple variables at once:
    </p>

<pre>
red, green, blue = 1.0, 0.5, 0.25
print blue, green, red
<span class="out">0.25 0.5 1.0</span>
</pre>

    <p>
      One thing this lets us do is swap variables' values in a single statement:
    </p>

<pre>
left = 'red
right = 'green'
left, right = right, left
print 'left is now', left, 'and right is now', right
<span class="out">left is now green and right is now red</span>
</pre>

    <p>
      Some functions can also return multiple values&mdash;for example,
      <code>divmod</code> returns the quotient and remainder in a single call:
    </p>

<pre>
q, r = divmod(11, 3)
print 'quotient is', q
print 'remainder is', r
<span class="out">quotient is 3
remainder is 2</span>
</pre>

    <p>
      The <code>enumerate</code> function takes
      anything that a <code>for</code> loop can loop over
      as its parameter.
      It returns pairs,
      each of which contains an index and the value at that index:
    </p>

<pre>
for (i, c) in enumerate('word'):
    print 'index', i, 'character', c
index 0 character w
index 1 character o
index 2 character r
index 3 character d
</pre>

    <p>
      These days,
      most Python programmers would use <code>enumerate</code>
      instead of <code>range(len())</code> to update a list in place:
    </p>


<pre>
data = [1, 4, 2, 5, 1, 3]
for (loc, val) in enumerate(data):
    data[loc] = 2 * val
</pre>

  </div>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>Use <code>[<em>value</em>, <em>value</em>, ...]</code> to create a list of values.</li>
      <li><code>for</code> loops process the elements of a list, in order.</li>
      <li><code>len(<em>list</em>)</code> returns the length of a list.</li>
      <li><code>[]</code> is an empty list with no values.</li>
      <li>Lists are mutable: they can be changed in place.</li>
      <li>Use <code><em>list</em>.append(<em>value</em>)</code> to append something to the end of a list.</li>
      <li>Use <code><em>list</em>[<em>index</em>]</code> to access a list element by location.</li>
      <li>The index of the first element of a list is 0; the index of the last element is <code>len(<em>list</em>)-1</code>.</li>
      <li>Negative indices count backward from the end of the list, so <code><em>list</em>[-1]</code> is the last element.</li>
      <li>Trying to access an element with an out-of-bounds index is an error.</li>
      <li><code>range(<em>number</em>)</code> produces the list of numbers <code>[0, 1, ..., <em>number</em>-1]</code>.</li>
      <li><code>range(len(<em>list</em>))</code> produces the list of legal indices for <code><em>list</em></code>.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>

      <li>
        What does the following program print?
<pre>
total = 0
for v in []:
    total += v
print total
</pre>
      </li>

      <li>
        The expression <code>list('abc')</code> produces the list <code>['a', 'b', 'c']</code>.
        What does the expression <code>str(['a', 'b', 'c'])</code> produce?
      </li>

      <li>
        What is the value of the expression <code>len(['abc', 'def'])</code>?
      </li>

      <li>
        What does this program print, and why?
<pre>
for i in 4:
    print i
</pre>
      </li>

      <li>
        What does this program print?
<pre>
sizes = [0, 1, 1, 2, 2]
total = 0
for s in sizes:
    total += sizes[s]
print total
</pre>
      </li>

      <li>
        Explain the order in which operations occur
        in the final line of the program below.
<pre>
pop = [20, 40, 30]
loc = [1, 2, 1]
print pop[loc[2]]
</pre>
      </li>

      <li>
        What does this program print?
<pre>
genders = list('FMFFMFM')
print [genders[0] + genders[-1]]
</pre>
      </li>

      <li>
        What is the value of the list <code>letters</code>
        before the loop shown below,
        and during each iteration of the loop?
<pre>
letters = list('abcd')
for i in range(len(letters)):
    letters[i] = letters[-i]
</pre>
      </li>

      <li>
        What appears to happen when the program below is run?
        Why?
<pre>
values = list('abcd')
for char in values:
    values.append(char)
</pre>
        (Remember:
        to interrupt a running program, type control-C.)
      </li>

      <li id="a:sorting">
        Lists have a method called <code>sort</code>
        that sorts the values in the list:
<pre>
numbers = [5, 3, 10, -2]
numbers.sort()
print numbers
<span class="out">[-2, 3, 5, 10]</span>
</pre>
        They also have a method called <code>reverse</code>
        that reverse the values in the list:
<pre>
words = ['first', 'second', 'third']
words.reverse()
print words
['third', 'second', 'first']
</pre>
        Given these two methods,
        it would seem natural that:
<pre>
values.sort().reverse()
</pre>
        would put the values in the list into reverse sorted order,
        but it doesn't.
        Why not?
        What actually happens,
        and why does Python do that?
      </li>

    </ol>

  </div>

</section>

<section id="s:func">
  <h2>Functions</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Explain the benefits of breaking a program up into functions.</li>
      <li>Define a function of a single parameter.</li>
      <li>Explain what a call stack is, what a variable's scope is, and how the two concepts are related.</li>
      <li>Trace values as they are passed into and returned by functions.</li>
      <li>Compose function calls.</li>
    </ul>
  </div>

  <p>
    We have used functions several times in this lesson.
    It is now time to see how to create new functions ourselves.
    A function's job is to bundle several steps together
    so that they can be used as if they were a single command.
    The simplest possible function is one that
    produces the same value over and over again:
  </p>
  
<pre>
def zero():
    return 0
</pre>

  <p class="continue">
    We create functions in Python using the keyword <code>def</code>,
    followed by the function's name.
    The empty parentheses signal that the function doesn't take any inputs&mdash;we'll
    see functions that do in a moment&mdash;and the colon signals
    the start of a new block of code.
    The body of the function is then indented,
    just like the body of a loop.
    The keyword <code>return</code> then specifies
    the value that the function produces.
  </p>

  <p>
    Defining a function tells the computer how to do something,
    but doesn't actually do whatever that "something" is.
    To do that,
    we need to call the function:
  </p>

<pre>
result = zero()
print "zero produces", result
<span class="out">zero produces 0</span>
</pre>

  <p>
    When Python sees the call <code>zero()</code>
    it sets aside whatever it was doing,
    goes and does whatever the function <code>zero</code> tells it to do,
    and then continues with its original calculation using the function's result.
    In this case,
    the overall effect is to assign 0 to <code>result</code>,
    which is then printed.
  </p>

  <p>
    Functions that always produce the same value aren't particularly useful,
    so most functions take input values,
    or <a href="glossary.html#parameter">parameters</a>,
    and use them in their calculations.
    A parameter is a variable that is given a new value
    each time the function is called.
    For example,
    the function <code>fahr_to_kelvin</code> defined below
    has a single parameter <code>temp</code>,
    which is assigned the value 32 the first time it is called,
    and the value 212 the second time:
  </p>

<pre>
def fahr_to_kelvin(temp):
    return ((temp - 32.0) * 5.0/9.0) + 273.15

print 'water freezes at', fahr_to_kelvin(32)
print 'water boils at', fahr_to_kelvin(212)
<span class="out">water freezes at 273.15
water boils at 373.15</span>
</pre>

  <p>
    The functions we have seen so far have had only one parameter.
    When we define a function,
    however,
    we can give it any number of parameters.
    When the function is called and a new stack frame is created,
    a new variable is defined for each of those parameters,
    and the actual values given by the caller are assigned to the parameters in order from left to right.
    For example,
    if we define <code>average3</code> to calculate the average of three numbers:
  </p>

<pre>
def average3(a, b, c):
    return (a + b + c) / 3.0
</pre>

  <p class="continue">
    and call it like this:
  </p>

<pre>
x = 2
y = 2
z = 5
print average3(x, y, z)
<span class="out">3.0</span>
</pre>

  <p class="continue">
    then just before the function returns,
    the program's memory is as shown in <a class="figref" href="#f:memory_before_return">Figure 33</a>.
  </p>

  <figure id="f:memory_before_return">
    <img src="python/memory_before_return.png" alt="State of Memory Before Function Return" />
    <figcaption>Figure 31: State of Memory Before Function Return</figcaption>
  </figure>

  <p>
    Calling this function with the wrong number of values is an error:
  </p>

<pre>
print average3(1, 5)
<span class="err">Traceback (most recent call last):
  File "python/average-3-wrong.py", line 4, in &lt;module&gt;
    print 1, 5, '=&gt;', average3(1, 5)
TypeError: average3() takes exactly 3 arguments (2 given)</span>
</pre>

  <p class="continue">
    This is only sensible:
    if we pass two values to <code>average3</code>,
    Python has no way of knowing what third value to use.
    We can create functions that have
    <a href="glossary.html#default-value">default values</a> for parameters
    simply by providing those values when the function is defined:
  </p>

<pre>
def average3(a=0.0, b=0.0, c=0.0):
    return (a + b + c) / 3.0
</pre>

  <p>
    The meaning is straightforward:
    if the caller doesn't tell the function what value to use for <code>a</code>,
    the function should use 0.0,
    and similarly for the other parameters.
    We can now call our function in four different ways:
  </p>

  <table>
    <tr>
      <th>Call</th>
      <th><code>a</code></th>
      <th><code>b</code></th>
      <th><code>c</code></th>
      <th>Result</th>
    </tr>
    <tr>
      <td><code>average3()</code></td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <td><code>average3(3.0)</code></td>
      <td>3.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <td><code>average3(3.0, 6.0)</code></td>
      <td>3.0</td>
      <td>6.0</td>
      <td>0.0</td>
      <td>3.0</td>
    </tr>
    <tr>
      <td><code>average3(3.0, 6.0, 9.0)</code></td>
      <td>3.0</td>
      <td>6.0</td>
      <td>9.0</td>
      <td>6.0</td>
    </tr>
  </table>

  <p class="continue">
    We still can't call this function with more than three parameters,
    though,
    since once again Python wouldn't know where to put the fourth and higher.
  </p>

  <p>
    One restriction on functions with default values
    is that all of the parameters that have default values must come <em>after</em>
    all of the parameters that don't.
    To see why,
    imagine we were allowed to mix defaulting and non-defaulting parameters like this:
  </p>

<pre>
def average(<span class="highlight">start=None, values, end=None</span>):
    if start is None:
        start = 0
    if end is None:
        end = len(values)
    result = 0.0
    i = start
    while i &lt; end:
        result += values[i]
        i += 1
    return result / (end - start)
</pre>

  <p>
    If we call the function with just one parameter,
    it's pretty clear that its value has to be assigned to <code>values</code>.
    But what should Python do if the function is called with two parameters,
    like <code>average([1.0, 2.0, 5.0], 1)</code>?
    Should it use the provided values for the first and second parameters,
    and the default for the third?
    Or should it use the first parameter's default,
    and assign the given values to the second and third?
    We know what we want,
    but Python doesn't:
    remember, it can't infer anything from variables' names.
    We could define some sort of rule to tell it what to do in this case,
    but it's simpler and safer to disallow the problem in the first place.
  </p>

  <div class="box">
    <h3>How Older Languages Do It</h3>

    <p>
      If the language we are using doesn't let us define default parameter values,
      we would have to write two functions:
    </p>

<pre>
def is_close_diff(left, right, difference):
    return abs(left - right) &lt; difference

def is_close_default(left, right):
    return is_close_diff(left, right, 1.0e-6)
</pre>

    <p class="continue">
      This is a common <a href="glossary.html#design-pattern">design pattern</a>
      in many programming languages.
      We start by defining the most general function we can think of&mdash;in
      this case, one that uses a user-specified difference&mdash;and
      then write <a href="glossary.html#wrapper-function">wrapper functions</a>
      as easy-to-use shortcuts for common cases.
      These wrapper functions do <em>not</em> duplicate what's in the general function;
      instead, they call it,
      filling in some or all of the parameters it requires with sensible defaults.
    </p>

    <p>
      The problem with this approach is that
      we have to come up with names for all those little functions.
      Default parameters were invented to solve this problem:
      instead of writing lots of functions,
      we write one,
      and provide default values for some or all of its parameters.
    </p>
  </div>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>Define a function using <code>def <em>name</em>(...)</code></li>
      <li>The body of a function must be indented.</li>
      <li>Use <code><em>name</em>(...)</code> to call a function.</li>
      <li>Use <code>return</code> to return a value from a function.</li>
      <li>The values passed into a function are assigned to its parameters in left-to-right order.</li>
      <li>Function calls are recorded on a call stack.</li>
      <li>Every function call creates a new stack frame.</li>
      <li>The variables in a stack frame are discarded when the function call completes.</li>
      <li>Grouping operations in functions makes code easier to understand and re-use.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>

      <li>
        Draw memory diagrams showing what is on the call stack
        each time it changes in the program below:
<pre>
def double(x):
    return 2 * x

def trim(lower, value, upper):
    if value &lt; lower:
        result = lower
    elif value &gt; upper:
        result = upper
    else:
        result = value
    return value

print double(trim(0, 15, double(5)))
</pre>
      </li>

      <li>
        A colleague of yours wants to apply <code>double</code> and <code>trim</code>
        to every value in a list.
        Her function <code>squish</code> is shown below:
<pre>
def squish(numbers, lower, upper):
    result = []
    for n in numbers:
        result.append(double(trim(lower, n, upper)))
    return result

print squish([-3, 5], 0, 10)
</pre>
        You notice that while <code>trim</code> takes
        the lower bound, the value to be trimmed, and the upper bound as parameters,
        this function takes the values to be trimmed first,
        followed by the lower and upper bounds.
        Explain why this is bad style,
        and what you would do to fix it.
      </li>

      <li>
        This program reads files that contain comments (starting with '#'),
        blank lines (containing only whitespace),
        and words (separated by spaces),
        and prints the longest word found:
<pre>
import sys

longest = ''
for line in sys.stdin:
    line = line.strip().split('#')[0]
    if line:
        words = line.split()
        for w in words:
            if len(w) &gt; len(longest):
                longest = w
print longest
</pre>
        Rewrite it to use two functions call
        <code>get_words</code> and <code>keep_longest</code>
        so that the main program looks like:
<pre>
import sys

longest = ''
for line in sys.stdin:
    words = get_words(line)
    for w in words:
        longest = keep_longest(longest, w)
print longest
</pre>
      </li>

    </ol>

  </div>

</section>

<section id="s:scope">
  <h2>Scope</h2>

  <div class="understand">
    <h3>Understand:</h3>
    <ul>
      <li>Explain what global scope is, and how it differs from local scope.</li>
      <li>Explain why functions shouldn't pass information through global variables.</li>
    </ul>
  </div>

  <p>
    If one function is good,
    two must be better.
    Let's write a function to convert Kelvin to Celsius:
  </p>

<pre>
def kelvin_to_celsius(temp):
    return temp - 273.15

print 'absolute zero is', kelvin_to_celsius(0)
<span class="out">absolute zero is -273.15</span>
</pre>

  <p class="continue">
    Instead of writing a third equation to translate Fahrenheit into Celsius,
    we can now combine the two functions we have
    to do the required calculation:
  </p>

<pre>
def fahr_to_celsius(temp):
    degrees_k = fahr_to_kelvin(temp)
    return kelvin_to_celsius(degrees_k)

temp_f = 32.0
temp_c = fahr_to_celsius(temp_f)
print 'water freezes at', temp_c
<span class="out">water freezes at 0.0</span>
</pre>

  <p id="a:call-stack">
    To really understand what happens when we combine functions this way,
    we need to understand the <a href="glossary.html#call-stack">function call stack</a>.
    Here are the function definitions once again:
  </p>

<pre>
def fahr_to_kelvin(temp):
    return ((temp - 32.0) * 5.0/9.0) + 273.15

def kelvin_to_celsius(temp):
    return temp - 273.15

def fahr_to_celsius(temp):
    degrees_k = fahr_to_kelvin(temp)
    return kelvin_to_celsius(degrees_k)
</pre>

  <p class="continue">
    All three functions have a parameter called <code>temp</code>;
    how does Python keep them straight?
    Let's call one of the functions
    and print <code>temp</code>'s value after the call:
  </p>

<pre>
def kelvin_to_celsius(temp):
    return temp - 273.15

absolute_zero = 0.0
result = kelvin_to_celsius(absolute_zero)
print 'temp after function call is', temp
<span class="out">temp after function call is</span>
<span class="err">Traceback (most recent call last):
  File "python/print-temp.py", line 5, in &lt;module&gt;
    print 'temp after function call is', temp
NameError: name 'temp' is not defined</span>
</pre>

  <p class="continue">
    Why isn't <code>temp</code> defined?
    And if it isn't,
    why did we get an error for the last line of our program,
    rather than when we used <code>temp</code> inside <code>kelvin_to_celsius</code>?
  </p>

  <p>
    The answer is that
    Python doesn't actually create a variable called <code>temp</code>
    when the function is defined.
    Instead,
    it makes a note that it is supposed to create such a variable
    when <code>kelvin_to_celsius</code> is called,
    and then throw it away when the function finishes executing.
  </p>

  <p>
    This is easier to explain with pictures.
    After executing line 4 of our program,
    Python knows that <code>kelvin_to_celsius</code> refers to a function,
    and that <code>absolute_zero</code> refers to the value 0.0
    (<a class="figref" href="#f:func_call_step_1">Figure 21</a>):
  </p>

  <figure id="f:func_call_step_1">
    <img src="python/func_call_step_1.png" alt="First Step of Function Call" />
    <figcaption>Figure 20: First Step of Function Call</figcaption>
  </figure>

  <p>
    The first thing it does when it executes line 5 is call <code>kelvin_to_celsius</code>.
    To do this,
    it creates a new storage area for variables
    and puts it on top of the one that holds
    <code>kelvin_to_celsius</code> and <code>absolute_zero</code>.
    Since the function has one parameter,
    <code>temp</code>,
    Python creates a variable with that name in the new storage area
    and gives it the value 0.0
    (since that's what we passed in when we called the function).
    The program's memory is now in the state shown in
    <a class="figref" href="#f:func_call_step_2">Figure 22</a>:
  </p>

  <figure id="f:func_call_step_2">
    <img src="python/func_call_step_2.png" alt="Second Step of Function Call" />
    <figcaption>Figure 21: Second Step of Function Call</figcaption>
  </figure>

  <p>
    This variable storage area is called
    a <a href="glossary.html#stack-frame">stack frame</a>:
    stack, because it is stacked on top of the previous area,
    and frame, because&hellip;well, just because.
    Every time a function is called&mdash;any function&mdash;Python
    creates a new frame to holds the function's variables
    and puts it on top of the stack.
    While it is executing that function's code,
    Python looks in the top stack frame to find variables;
    when the function returns,
    Python discards the top stack frame
    and starts using the one underneath it again.
  </p>

  <p>
    Since the rest of the statement on line 5
    (the line containing the function call)
    assigns the function's value to <code>not_used</code>,
    memory looks something like <a class="figref" href="#f:func_call_step_3">Figure 23</a>
    after line 5 is finished:
  </p>

  <figure id="f:func_call_step_3">
    <img src="python/func_call_step_3.png" alt="Third Step of Function Call" />
    <figcaption>Figure 22: Third Step of Function Call</figcaption>
  </figure>

  <p>
    It should now be clear why we got the error we did,
    and why we got it <em>where</em> we did.
    When Python executes line 6,
    the uppermost frame of the stack doesn't contain a variable called <code>temp</code>.
    The frame that <em>did</em> contain that variable
    was discarded when the call to <code>kelvin_to_celsius</code> finished.
  </p>

  <p>
    To understand why Python (and other languages) do all of this,
    let's go back to <code>fahr_to_celsius</code> again.
    Its definition,
    and the definitions of the functions it calls,
    are:
  </p>

<pre>
def fahr_to_kelvin(temp):
    return ((temp - 32.0) * 5.0/9.0) + 273.15

def kelvin_to_celsius(temp):
    return temp - 273.15

def fahr_to_celsius(temp):
    degrees_k = fahr_to_kelvin(temp)
    return kelvin_to_celsius(degrees_k)
</pre>

  <p class="continue">
    These nine lines of code define the variable <code>temp</code> three times&mdash;once
    in each function&mdash;but those three <code>temp</code>s are <em>not</em> the same variable.
    The first <code>temp</code>,
    defined on line 1,
    is created each time <code>fahr_to_kelvin</code> is called,
    and only lasts as long as that call is in progress.
    In computer science jargon,
    it is <a href="glossary.html#local-scope">local</a> to the function.
    Similarly,
    the second <code>temp</code> (on line 4) is local to <code>kelvin_to_celsius</code>,
    and the third (on line 7) to <code>fahr_to_celsius</code>.
    They only exist while the functions that own them are being executed,
    and can only be "seen" inside those functions.
  </p>

  <p>
    Again, some pictures will make this clearer
    (and it does need to be clear,
    since everything else about functions depends on this idea).
    Let's call <code>fahr_to_celsius</code> as before:
  </p>

<pre>
temp_f = 32.0
temp_c = fahr_to_celsius(temp_f)
print 'water freezes at', temp_c
</pre>

  <p>
    Just before line 9 runs,
    the stack consists of a single frame,
    which contains the three functions
    and the variable <code>temp_f</code>
    (<a class="figref" href="#f:stack_single_frame">Figure 24</a>):
  </p>

  <figure id="f:stack_single_frame">
    <img src="python/stack_single_frame.png" alt="A Call Stack With a Single Frame" />
    <figcaption>Figure 23: A Call Stack With a Single Frame</figcaption>
  </figure>

  <p>
    When we call <code>fahr_to_celsius</code>,
    Python creates a new stack frame containing the variable <code>temp</code>
    and assigns it the value 32.0
    (which it got from <code>temp_f</code>).
    Memory is now as shown in <a class="figref" href="#f:stack_double_frame">Figure 25</a>.
  </p>

  <figure id="f:stack_double_frame">
    <img src="python/stack_double_frame.png" alt="A New Stack Frame" />
    <figcaption>Figure 24: A New Stack Frame</figcaption>
  </figure>

  <p>
    <code>fahr_to_celsius</code> immediately calls <code>fahr_to_kelvin</code>,
    so Python creates another stack frame
    to hold <code>fahr_to_kelvin</code>'s local variables.
    This frame also contains a variable called <code>temp</code>,
    but since it's in a different frame,
    it's a different variable than <code>fahr_to_celsius</code>'s <code>temp</code>
    (<a class="figref" href="#f:stack_triple_frame">Figure 26</a>).
  </p>

  <figure id="f:stack_triple_frame">
    <img src="python/stack_triple_frame.png" alt="Yet Another Stack Frame" />
    <figcaption>Figure 25: Yet Another Stack Frame</figcaption>
  </figure>

  <p>
    Using its <code>temp</code>,
    <code>fahr_to_kelvin</code> calculates a result of 273.15.
    When it returns that value,
    Python discards <code>fahr_to_kelvin</code>'s stack frame
    (<a class="figref" href="#f:stack_back_to_double_frame">Figure 27</a>):
  </p>

  <figure id="f:stack_back_to_double_frame">
    <img src="python/stack_back_to_double_frame.png" alt="Back to a Double Frame" />
    <figcaption>Figure 26: Back to a Double Frame</figcaption>
  </figure>

  <p class="continue">
    and creates a new variable <code>degrees_k</code> to hold that value
    in what is now the top frame&mdash;the one belonging to <code>fahr_to_celsius</code>
    (<a class="figref" href="#f:new_variable_in_double_frame">Figure 28</a>):
  </p>

  <figure id="f:new_variable_in_double_frame">
    <img src="python/new_variable_in_double_frame.png" alt="A New Variable in the Second Frame" />
    <figcaption>Figure 27: A New Variable in the Second Frame</figcaption>
  </figure>

  <p class="continue">
    Python then goes through the same steps for the call to <code>kelvin_to_celsius</code>.
    It creates a stack frame with a variable <code>temp</code>,
    which it assigns the value 273.15
    (<a class="figref" href="#f:repeat_stack_frame">Figure 29</a>):
  </p>

  <figure id="f:repeat_stack_frame">
    <img src="python/repeat_stack_frame.png" alt="Repeating the Process" />
    <figcaption>Figure 28: Repeating the Process</figcaption>
  </figure>

  <p class="continue">
    does its calculations,
    and then discards the stack frame when the function is finished.
    Since <code>fahr_to_celsius</code> is also now done,
    Python discards its stack frame,
    creates a variable called <code>temp_c</code> in the original (bottom) frame,
    and assigns it the value 0.0
    (<a class="figref" href="#f:final_state_of_frames">Figure 30</a>):
  </p>

  <figure id="f:final_state_of_frames">
    <img src="python/final_state_of_frames.png" alt="The Final State" />
    <figcaption>Figure 29: The Final State</figcaption>
  </figure>

  <p>
    Every modern programming language uses this model to manage calculations.
    Each function call creates a new stack frame with its own variables.
    While the function is running,
    it uses the variables in its own frame,
    and when the function call is finished,
    the stack frame is discarded.
  </p>

  <p>
    The area of the program in which a particular variable is visible
    is called its <a href="glossary.html#scope">scope</a>.
    As a rule,
    programming languages do not let functions access variables in other functions' scopes
    because doing so would make large programs almost impossible to write.
    For example,
    imagine we used two functions to sum the squares of the values in a list:
  </p>

<pre>
def sum(numbers):                       <span class="comment">#  1</span>
    result = 0                          <span class="comment">#  2</span>
    for x in numbers:                   <span class="comment">#  3</span>
        result = result + square(x)     <span class="comment">#  4</span>
    return result                       <span class="comment">#  5</span>
                                        <span class="comment">#  6</span>
def square(val):                        <span class="comment">#  7</span>
    result = val * val                  <span class="comment">#  8</span>
    return result                       <span class="comment">#  9</span>
                                        <span class="comment"># 10</span>
print sum([1, 2])                       <span class="comment"># 11</span>
</pre>

  <p class="continue">
    We expect to get 1<sup>2</sup>+2<sup>2</sup> = 5
    via the following steps:
  </p>

  <table border="1">
    <tr>
      <th></th>
      <th><code>sum</code></th>
      <th><code>sum</code></th>
      <th><code>square</code></th>
      <th><code>square</code></th>
    </tr>
    <tr>
      <th>Line</th>
      <th><code>result</code></th>
      <th><code>x</code></th>
      <th><code>val</code></th>
      <th><code>result</code></th>
    </tr>
    <tr>
      <td>2</td>
      <td>0</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>3</td>
      <td>0</td>
      <td>1</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>7</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td></td>
    </tr>
    <tr>
      <td>8</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>4</td>
      <td>1</td>
      <td>1</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>3</td>
      <td>1</td>
      <td>2</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>7</td>
      <td>1</td>
      <td>2</td>
      <td>2</td>
      <td></td>
    </tr>
    <tr>
      <td>8</td>
      <td>1</td>
      <td>2</td>
      <td>2</td>
      <td>4</td>
    </tr>
    <tr>
      <td>4</td>
      <td>1</td>
      <td>5</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>5</td>
      <td>1</td>
      <td>5</td>
      <td></td>
      <td></td>
    </tr>
  </table>

  <p>
    If <code>sum</code>'s <code>result</code> and <code>square</code>'s <code>result</code>
    were the same variable, though,
    we would get 8 instead:
  </p>

  <table border="1">
    <tr>
      <th>Line</th>
      <th><code>result</code></th>
      <th><code>x</code></th>
      <th><code>val</code></th>
    </tr>
    <tr>
      <td>2</td>
      <td>0</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>3</td>
      <td>0</td>
      <td>1</td>
      <td></td>
    </tr>
    <tr>
      <td>7</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>8</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>4</td>
      <td>2</td>
      <td>1</td>
      <td></td>
    </tr>
    <tr>
      <td>3</td>
      <td>2</td>
      <td>2</td>
      <td></td>
    </tr>
    <tr>
      <td>7</td>
      <td>2</td>
      <td>2</td>
      <td>2</td>
    </tr>
    <tr>
      <td>8</td>
      <td>4</td>
      <td>2</td>
      <td>2</td>
    </tr>
    <tr>
      <td>4</td>
      <td>8</td>
      <td>2</td>
      <td></td>
    </tr>
    <tr>
      <td>5</td>
      <td>8</td>
      <td>2</td>
      <td></td>
    </tr>
  </table>

  <p class="continue">
    What's worse,
    if we changed the name of the variable in <code>square</code>
    from <code>result</code> to <code>y</code>,
    the final answer would be 5 again.
    Changing the name of a variable shouldn't matter:
    <em>f(x)=x<sup>2</sup></em> and <em>f(y)=y<sup>2</sup></em>
    ought to calculate the same value,
    and if changing a variable name in one part of our program
    can change the result calculated by another,
    we will have to keep the entire program in our head
    in order to make any change safely.
  </p>

  <p>
    The fundamental issue here is one of evolution rather than one of technology.
    Human short-term memory can only hold a few items at a time;
    the value is sometimes given as "seven plus or minus two",
    and while that is an over-simplification,
    it's a good guideline.
    If we need to remember more unrelated bits of information than that for more than a few seconds,
    they become jumbled and we start making mistakes.
  </p>

  <p>
    If we have to keep more than half a dozen things straight in our mind
    in order to understand or change a piece of code,
    we will therefore start making mistakes.
    Most programming languages therefore enforce a "local scope only" rule
    so that programmers can ignore what's inside the functions they are calling,
    or what's outside the functions they are writing,
    and use their short-term memory for the task at hand instead.
  </p>

  <p>
    There is one important pragmatic exception to the "local scope only" rule
    mentioned at the end of the previous section.
    Every function also has access to the <a href="glossary.html#global-scope">global scope</a>,
    which is all the top-level definitions in the program
    (i.e., ones that aren't inside any particular function).
    In our pictures,
    the global scope is the bottom-most frame on the stack,
    which is there when the program starts and never goes away
    (<a class="figref" href="#f:global_scope">Figure 31</a>).
  </p>

  <figure id="f:global_scope">
    <img src="python/global_scope.png" alt="Global Scope" />
    <figcaption>Figure 30: Global Scope</figcaption>
  </figure>

  <p>
    Functions need access to the global scope because
    that is where other functions are defined.
    Going back to our temperature calculator,
    if <code>fahr_to_celsius</code> could only see variables defined in its local scope,
    it wouldn't be able to see either <code>fahr_to_kelvin</code>
    or <code>kelvin_to_celsius</code>,
    and therefore wouldn't be able to call them.
  </p>

  <p>
    Programmers also usually put constants at the top level of their program
    (i.e., define them in the global scope)
    so that they don't need to pass them into functions.
    For example,
    it's common to see code like this:
  </p>

<pre>
SCALING = 2.5

def scale_up(x):
    return x * SCALING

def scale_down(x):
    return x / SCALING
</pre>

  <p class="continue">
    (Many programmers write the names of constants in upper case
    to help readers distinguish them from variables,
    but languages don't enforce this.)
    When Python executes <code>scale_up</code> (or <code>scale_down</code>),
    it looks inside that function's scope for a variable called <code>SCALING</code>.
    Since there isn't one,
    it then checks the global scope,
    where it finds what it needs.
  </p>

  <p>
    Defining <code>SCALING</code> once at the top of the program
    ensures that both functions always use the same scaling factor.
    This code produces the same result:
  </p>

<pre>
def scale_up(x):
    return x * 2.5

def scale_down(x):
    return x / 2.5
</pre>

  <p class="continue">
    but experience shows that
    it's very easy for a programmer to change the scaling factor in one function
    and forget to change it in the other.
    Programs always evolve to meet new needs;
    good programmers plan for this,
    because they know that if they don't,
    they'll eventually pay the price.
  </p>

  <p>
    Putting constants in the global scope is good style.
    The following is not
    (and in fact,
    isn't even legal Python,
    for reasons we'll discuss in a moment):
  </p>

<pre>
largest = 0

def fixup(values):
    for i in range(len(values)):
        if values[i] &gt; largest:
            largest = values[i]

def scale(values):
    for i in range(len(values)):
        values[i] = values[i] / largest
</pre>

  <p class="continue">
    Here,
    the function <code>fixup</code> puts the largest value it has seen
    in a global variable called <code>largest</code>,
    which <code>scale</code> then uses.
    This works in simple cases:
  </p>

<pre>
rows = [1.0, 4.0, -2.5, 3.5]
fixup(rows)
scale(rows)
print rows
<span class="out">[0.25, 1.0, 0.0, 0.875]</span>
</pre>

  <p class="continue">
    but look what happens when we try to process another data set:
  </p>

<pre>
columns = [1.5, 1.5, -2.0, 3.0]
fixup(columns)
scale(columns)
print columns
<span class="out">[0.375, 0.375, 0.0, 0.75]</span>
</pre>

  <p class="continue">
    If we actually want each data set fixed up and scaled separately,
    the answer for <code>columns</code> should be <code>[0.5, 0.5, 0.0, 1.0]</code>.
    The problem is that
    the values in <code>columns</code> are actually being scaled by
    the largest value found in <code>rows</code>,
    because that's what was left behind in <code>largest</code>
    by the initial call.
  </p>

  <p>
    Bugs like this are caused by <a href="glossary.html#side-effect">side effects</a>
    that aren't visible in either the functions' definitions or calls.
    They are notoriously difficult to track down,
    so most modern programming languages discourage programmers from using global variables.
    In Python,
    for example,
    the sample program shown above doesn't actually run.
    If we really want it to,
    we have to add one more line:
  </p>

<pre>
largest = 0

def fixup(values):
    <span class="highlight">global largest</span>
    for i in range(len(values)):
        if values[i] &gt; largest:
            largest = values[i]

def scale(values):
    for i in range(len(values)):
        values[i] = values[i] / largest
</pre>

  <p>
    Without the highlighted <code>global</code> statement,
    Python assumes that <code>largest</code> is local to the function <code>fixup</code>.
    Again,
    the root cause is the way that human memory works.
    If information only comes into a function through its parameters,
    it's easy for readers to keep track of what they need to know
    in order to trace the function's behavior.
    But if information can magically appear in the middle of a function
    (as it does in <code>scale</code> when <code>largest</code> is suddenly used
    without having been defined),
    the person reading the program has to keep much more information in their head.
    This increases the chances that they'll misunderstand the program,
    which in turn increases the chances of that program being wrong.
    As a rule,
    therefore,
    functions should <em>only</em> use
    values passed in explicitly as parameters,
    values defined as global constants,
    and variables created locally.
  </p>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>Every function always has access to variables defined in the global scope.</li>
      <li>Programmers often write constants' names in upper case to make their intention easier to recognize.</li>
      <li>Functions should <em>not</em> communicate through global variables.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>

      <li>
        Identify the global variables in this program,
        and rewrite it
        so that the two functions do not share information
        through global variables.
<pre>
def increase(floor):
    for (i, n) in enumerate(values):
        if n &lt; floor:
            values[i] = floor

def scale(amount):
    for i in range(bound):
        values[i] *= amount

values = [4.0, 4.3, 4.7, 5.1]
bound = 2
increase(4.5)
scale(10.0)
</pre>
      </li>

      <li>
        Python allows programmers to define functions inside other functions:
<pre>
def scale_all(values, amount):

    def scale_one(v):
        return 1.0 + v * amount

    for (i, v) in enumerate(values):
        values[i] = scale_one(v)
    return values

scale_all([1.0, 2.0, 3.0], 10.0)
<span class="out">[11.0, 21.0, 31.0]</span>
</pre>
        Draw a memory diagram showing what's on the stack
        when Python is calculating
        <code>1.0 + 2.0 * 10.0</code>
        (the second iteration of the loop in <code>scale_all</code>).
        What happens if we try to call <code>scale_one(7.0)</code>
        after the call to <code>scale_all</code> has completed?
      </li>

    </ol>

  </div>

</section>

<section id="s:return">
  <h2>Returning Values</h2>

  <div class="understand">
    <h3>Understand:</h3>
    <ul>
      <li>How to return values from a function at any time.</li>
      <li>Why functions shouldn't return values at arbitrary points.</li>
      <li>What a function returns if it doesn't return anything explicitly.</li>
    </ul>
  </div>

  <p>
    All of our functions so far have ended with a <code>return</code> statement,
    and that has been the only <code>return</code> statement they've contained.
    Once again,
    this doesn't have to be the case:
    it is often easier to write functions that return from several places,
    though this can also make them harder to read.
  </p>

  <p>
    Let's start with a function that calculates the sign of a number:
  </p>

<pre>
def sign(num):
    if num &lt; 0:
        return -1
    if num == 0:
        return 0
    return 1
</pre>

  <p class="continue">
    If we call it with a negative number,
    the first branch of the <code>if</code> returns -1.
    If we call it with 0,
    the <code>return</code> in the second <code>if</code> is executed,
    and if we call it with a positive number,
    neither of the <code>if</code> branches is taken,
    so we <a href="glossary.html#fall-through">fall through</a> to the final <code>return</code>,
    which produces the value 1:
  </p>

<pre>
print -5, '=&gt;', sign(-5)
print 0, '=&gt;', sign(0)
print 241, '=&gt;', sign(241)
<span class="out">-5 =&gt; -1
0 =&gt; 0
241 =&gt; 1</span>
</pre>

  <p>
    One common use of multiple return statements
    is to handle special cases at the start of a function.
    For example,
    suppose we decide that we want the average of an empty list to be zero after all.
    We could modify our averaging function to check for this case
    before doing anything else:
  </p>

<pre>
def average(values):

    <span class="comment"># The average of no values is 0.0.</span>
    if len(values) == 0:
        return 0.0

    <span class="comment"># Handle actual values.</span>
    result = 0.0
    for v in values:
        result += v
    return result / len(values)
</pre>

  <p class="continue">
    The early <code>return</code> statement (plus a comment)
    makes it very clear to whoever is reading this code
    that we are handling an empty list in a special way.
    Compare this to an implementation that uses <code>if</code> and <code>else</code>
    to separate the two cases
    while keeping a single <code>return</code> statement at the end of the function:
  </p>

<pre>
def average(values):

    <span class="comment"># The average of no values is 0.0.</span>
    if len(values) == 0:
        result = 0.0

    <span class="comment"># Handle actual values.</span>
    else:
        result = 0.0
        for v in values:
            result += v
        result /= len(values)

    <span class="comment"># Return final result.</span>
    return result
</pre>

  <p class="continue">
    This version is easier to understand in one way,
    but harder in another.
    What makes it harder is our limited short-term memory:
    the body of the <code>else</code> is only four lines long,
    but reading and understanding those lines
    may push the special handling of the empty list out of our mind.
    In this case,
    the code is short enough that
    we will probably be able to retain the special case,
    but if the calculation was more complex,
    we would lose sight of the big picture.
  </p>

  <p>
    What makes it easier is its regularity:
    each possible case of input (empty or non-empty) is handled in a conditional branch,
    and each branch's job is to assign a value to <code>result</code>
    for the function to return.
    If there were six or seven special cases,
    this pattern would help us keep track of what what going on&mdash;provided
    we knew (or recognized) the pattern.
  </p>

  <p>
    The psychological term for what's going on here is
    <a href="glossary.html#chunk">chunking</a>,
    which refers to the way people group items together in memory.
    For example, when you look at the five dots on a dice:
  </p>

  <figure id="f:five_spots">
    <img src="python/five_spots.png" alt="Five Spots" />
    <figcaption>Figure 32: Five Spots</figcaption>
  </figure>

  <p class="continue">
    what you actually "see" is the X pattern,
    and what you remember is that pattern rather than five individual dots.
    rather than remembering five individual dots.
    Similarly,
    you remember common words such as "common" as words,
    not as sequences of letters,
    and so on.
  </p>

  <p>
    One of the key differences between experts and novices is that
    experts are better at chunking:
    they don't actually have larger short-term memories,
    but since they recognize a broader repertoire of patterns,
    they are able to manage more information.
    Turning that over,
    the more recognizable patterns are used in a program,
    the easier it is for people to keep it in their heads.
    And as Chase and Simon discuss in their classic paper
    "<a href="bib.html#chase-simon-chess">Perception in chess</a>",
    things that <em>don't</em> conform to patterns can actually be <em>harder</em> for experts to recognize,
    since their brains will mis-match and "correct" what's actually there.
  </p>

  <p>
    Here's a third version of our function that doesn't use an early return.
    and only has one conditional branch:
  </p>

<pre>
def average(values):
    result = 0.0
    if len(values) &gt; 0:
        for v in values:
            result += v
        result /= len(values)
    return result
</pre>

  <p class="continue">
    Many people find this version harder to understand than either of the previous two,
    even though it is shorter.
    The reason is that the special case isn't handled explicitly.
    Instead,
    this function returns 0 for the empty list
    because of the code that <em>isn't</em> executed:
    if the list is empty,
    the loop doesn't run,
    so the initial value of <code>result</code>
    becomes the function's final value by default.
    Spotting this,
    and keeping track of what the function isn't doing as well as what it is,
    is difficult enough that
    many people won't realize there is a special case at all.
  </p>

  <p>
    One last thing to note about functions in Python is that
    every function returns something:
    if there isn't an explicit <code>return</code> statement,
    the value returned is <code>None</code>.
    For example,
    let's comment out the last line of our sign function:
  </p>

<pre>
def sign(num):
    if num &lt; 0:
        return -1
    if num == 0:
        return 0
<span class="comment">#    return 1</span>

print -5, '=&gt;', sign(-5)
print 0, '=&gt;', sign(0)
print 241, '=&gt;', sign(241)
<span class="out">-5 =&gt; -1
0 =&gt; 0
241 =&gt; None</span>
</pre>

  <p class="continue">
    The sign of 241 is now <code>None</code> instead of 1,
    because when the function is called with a positive value,
    neither of the <code>if</code> branches is taken,
    and execution "falls off" the end of the function.
  </p>

  <p>
    Other languages do this differently.
    In C,
    for example,
    trying to use the "result" of a function that doesn't explicitly return something
    is a compilation error&mdash;the program can't even be run.
    No matter what the language,
    this is one reason why commenting out blocks of code is a bad idea:
    it's all too easy to accidentally disable a <code>return</code> statement
    buried inside the code that's no longer being executed.
  </p>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>A function may return values at any point.</li>
      <li>A function should have zero or more <code>return</code> statements at its start to handle special cases, and then one at the end to handle the general case.</li>
      <li>"Accidentally" correct behavior is hard to understand.</li>
      <li>If a function ends without an explicit <code>return</code>, it returns <code>None</code>.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>

      <li>
        One alternative to returning from inside a loop
        is to use the <code>break</code> statement
        to end the loop immediately:
<pre>
def first_negative(values):
    for v in values:
        if v &lt; 0:
            break
    return v
print first_negative([1, 3, -1, 2])
<span class="out">-1</span>
</pre>
        When can this approach result in an error,
        and what kind of error does it produce?
      </li>

      <li>
        This functions counts
        how many values from a list must be summed
        in order to reach some limit:
<pre>
def count_to_limit(values, limit):
    current = 0
    number = 0
    for v in values:
        current += v
        number += 1
        if current &gt;= limit:
            return number

print count_to_limit([1, 2, 3, 5, 7], 8)
<span class="out">4</span>
</pre>
        Fix it so that it returns the right answer
        when <code>limit</code> is negative,
        and when the sum of the values in the list
        never reaches <code>limit</code>.
      </li>

    </ol>

  </div>

</section>

    <section id="s:libraries">

      <h2>Libraries</h2>

      <p id="a:copy_library" class="fixme">introduce the copy library</p>

      <div class="understand" id="u:libraries">
        <h3>Understand:</h3>
        <ul>
          <li>How to import code in one Python module for use in another.</li>
          <li>That code is executed as it's imported.</li>
          <li>That each module corresponds to a variable scope.</li>
        </ul>
      </div>

      <p>
        A function is a way to turn a bunch of related statements into a single chunk that can be re-used.
        A <a href="glossary.html#module">module</a>
        or <a href="glossary.html#library">library</a>
        (for our purposes, the terms mean the same thing)
        does for functions what functions do for statements:
        group them together to create more usable chunks.
        This hierarchical organization is similar in spirit to that used in biology:
        instead of family, genus, and species, we have module, function, and statement.
      </p>

      <p>
        Every Python file can be used as a module by other programs.
        <span class="fixme">import has already been introduced</span>
        To load a module into a program,
        we use the <code>import</code> statement.
        For example,
        suppose we have created a Python file called <code>halman.py</code>
        that defines a single function called <code>threshold</code>:
      </p>

<pre src="python/halman.py">
<span class="comment"># halman.py</span>
def threshold(signal):
  return 1.0 / sum(signal)
</pre>

      <p class="continue">
        If we want to call this function in a program stored in another file,
        we use <code>import halman</code> to load the contents of <code>halman.py</code>,
        and then call the function as <code>halman.threshold</code>:
      </p>

<pre src="python/use_halman.py">
import halman
readings = [0.1, 0.4, 0.2]
print 'signal threshold is', halman.threshold(readings)
</pre>

      <p class="continue">
        We can then run the program that does the <code>import</code>
        and calls the function:
      </p>

<pre>
$ <span class="in">python use_halman.py</span>
<span class="out">signal threshold is 1.42857</span>
</pre>

      <p>
        When a module is imported,
        Python executes the statements it contains
        (which are usually function definitions).
        It then creates an object to store references to all the items defined in that module
        and assigns it to a variable with the same name as the module.
        For example,
        let's create a file called <code>noisy.py</code> that prints out a message
        and then defines <code>NOISE_LEVEL</code> to be 1/3:
      </p>

<pre src="python/noisy.py">
<span class="comment"># noisy.py</span>
print 'Is this module being loaded?'
NOISE_LEVEL = 1./3.
</pre>

      <p class="continue">
        When it imports <code>noisy</code>
        Python executes the first statement&mdash;the <code>print</code>&mdash;and
        displays a message on the screen:
      </p>

<pre>
&gt;&gt;&gt; <span class="in">import noisy</span>
<span class="out">Is this module being loaded?</span>
</pre>

      <p class="continue">
        Importing the module also defines the variable <code>NOISE_LEVEL</code>.
        Inside the main program,
        we can access as <code>noisy.NOISE_LEVEL</code>:
      </p>

<pre>
&gt;&gt;&gt; <span class="in">print noisy.NOISE_LEVEL</span>
<span class="out">0.33333333</span>
</pre>

      <p>
        Just like a function,
        each module is a separate scope,
        so that variable names defined inside a module belong to that module
        and don't collide with variable names defined elsewhere.
        When a function wants to a find a variable,
        it actually looks in its own scope,
        then in its module.
        Our earlier rule "function then global" is just a special case of this,
        since the global scope is just the module scope of our main program.
      </p>

      <figure id="f:name_resolution">
        <img src="python/name_resolution.png" alt="Name Resolution" />
        <figcaption>Figure 34: Name Resolution</figcaption>
      </figure>

      <p>
        To see how this works,
        let's create a file called <code>module.py</code>
        that defines both a variable called <code>NAME</code>
        and a function called <code>func</code> that prints it out:
      </p>

<pre src="python/module.py">
<span class="comment"># module.py</span>
NAME = 'Transylvania'

def func(arg):
  return NAME + ' ' + arg
</pre>

      <p class="continue">
        In our main program,
        we also define a variable called <code>NAME</code>,
        then import our module.
        When we call <code>module.func</code>
        it sees the <code>NAME</code> variable that was defined inside the module,
        not the one that was defined globally:
      </p>

<pre src="python/use_module.py">
&gt;&gt;&gt; <span class="in">NAME = 'Hamunaptra'</span>
&gt;&gt;&gt; <span class="in">import module</span>
&gt;&gt;&gt; <span class="in">print module.func('!!!')</span>
<span class="out">Transylvania !!!</span>
</pre>

      <p>
        Once again,
        rules about where and how to look things up might seem arcane,
        but it would be practically impossible to write large programs
        without some kind of scoping them.
        Restricting lookup to the current function,
        its module,
        and the top level of the program makes it easier for people to understand code,
        since there are only three places where the variables used on a particular line might be,
        two of which (the containing function and the file it's in)
        are guaranteed to be nearby.
      </p>

      <div class="box">
        <h3>How Other Languages Do It</h3>

        <p>
          When a dynamic language like Python (or MATLAB, R, Ruby, or Perl) loads a program,
          it actually does two things:
        </p>

        <ol>
          <li>
            translate the statements into instructions the computer can execute,
            and
          </li>
          <li>
            execute those instructions.
          </li>
        </ol>

        <p>
          Compiled languages like Fortran, C++, and Java do these things separately:
          a <a href="glossary.html#compiler">compiler</a> does the translation,
          saving the instructions in a file on disk,
          which a separate <a href="glossary.html#loader">loader</a>
          copies into memory for execution some time later
          (<a class="figref" href="#f:compiling_vs_interpreting">Figure 35</a>).
          In general,
          compiled languages therefore don't execute instructions while loading;
          instead,
          they wait until everything is in memory before running any of it.
        </p>

        <figure id="f:compiling_vs_interpreting">
          <img src="python/compiling_vs_interpreting.png" alt="Compiling vs. Interpreting" />
          <figcaption>Figure 35: Compiling vs. Interpreting</figcaption>
        </figure>

      </div>

      <div class="keypoints" id="k:libraries">
        <h3>Summary</h3>
        <ul>
          <li idea="turing">Any Python file can be imported as a library.</li>
          <li>The code in a file is executed when it is imported.</li>
          <li>Every Python file is a scope, just like every function.</li>
        </ul>
      </div>

    </section>

    <section id="s:stdlib">

      <h2>Standard Libraries</h2>

      <div class="understand" id="u:stdlib">
        <h3>Understand:</h3>
        <ul>
          <li>What is in the standard math library.</li>
          <li>What is in the system library.</li>
          <li>Several ways to import things from libraries.</li>
        </ul>
      </div>

      <p>
        The real power of a language is in its libraries:
        they are the distilled wisdom and effort
        of all the programmers who have come before us.
        Python's standard library contains over a hundred modules,
        and the fastest way to become a more productive programmer
        is to become familiar with them.
        One of the most useful is <code>math</code>,
        which defines <code>sqrt</code> for square roots,
        <code>hypot</code> for calculating x<sup>2</sup>+y<sup>2</sup>,
        and values for <em>e</em> and &pi; that are as accurate as the machine can make them.
      </p>

<pre>
&gt;&gt;&gt; <span class="in">import math</span>
&gt;&gt;&gt; <span class="in">print math.sqrt(2)</span>
<span class="out">1.4142135623730951</span>
&gt;&gt;&gt; <span class="in">print math.hypot(2, 3)</span>  <span class="comment"># sqrt(x**2 + y**2)</span>
<span class="out">3.6055512754639891</span>
&gt;&gt;&gt; <span class="in">print math.e, math.pi</span>   <span class="comment"># as accurate as possible</span>
<span class="out">2.7182818284590451 3.1415926535897931</span>
</pre>

      <p>
        Since <code>math.sqrt</code> is a handful to type,
        and <code>sqrt</code> is probably not ambiguous,
        Python provides several ways to import things.
        For example,
        we can import specific functions from a library and then call them directly,
        rather than using the <code>modulename.functionname</code> syntax:
      </p>

<pre>
&gt;&gt;&gt; <span class="in">from math import sqrt</span>
&gt;&gt;&gt; <span class="in">sqrt(3)</span>
<span class="out">1.7320508075688772</span>
</pre>

      <p class="continue">
        We can also import a function under a different name,
        so that if two modules define functions with the same name,
        we can give one or the other a different name when we want to use them together:
      </p>

<pre>
&gt;&gt;&gt; <span class="in">from math import hypot as euclid</span>
&gt;&gt;&gt; <span class="in">euclid(3, 4)</span>
<span class="out">5.0</span>
</pre>

      <p>
        We can also use <code>import *</code>
        to bring everything in the module into the current scope at once.
        This has the same effect as using <code>from module import a</code>,
        <code>from module import b</code>,
        and so on for every name in the module:
      </p>

<pre>
&gt;&gt;&gt; <span class="in">from math import *</span>
&gt;&gt;&gt; <span class="in">sin(pi)</span>
<span class="out">1.2246063538223773e-16</span>
</pre>

      <p class="continue">
        <code>import *</code> is usually a bad idea:
        if someone adds a new function or variable to the next version of the module,
        your <code>import *</code> could silently overwrite something that you have written,
        or are importing from somewhere else.
        Bugs like this can be extremely hard to find,
        since nothing seemed to change in your program.
      </p>

      <p>
        Another useful library is <code>sys</code> (short for "system").
        It defines constants to tell us what version of Python we're using,
        what operating system we're running on,
        and how large integers are:
      </p>

<pre>
&gt;&gt;&gt; <span class="in">import sys</span>
&gt;&gt;&gt; <span class="in">print sys.version</span>
<span class="out">2.7 (r27:82525, Jul  4 2010, 09:01:59) [MSC v.1500 32 bit (Intel)]</span>
&gt;&gt;&gt; <span class="in">print sys.platform</span>
<span class="out">win32</span>
&gt;&gt;&gt; <span class="in">print sys.maxint</span>
<span class="out">2147483647</span>
&gt;&gt;&gt; <span class="in">print sys.path</span>
<span class="out">['',
 'C:\\WINDOWS\\system32\\python27.zip',
 'C:\\Python27\\DLLs', 'C:\\Python27\\lib',
 'C:\\Python27\\lib\\plat-win',
 'C:\\Python27', 'C:\\Python27\\lib\\site-packages']</span>
</pre>

      <p>
        The most commonly-used element of <code>sys</code>, though, is <code>sys.argv</code>,
        which holds a list of the <a href="glossary.html#command-line-arguments">command-line arguments</a>
        used to run the program.
        The name of the script itself is in <code>sys.argv[0]</code>;
        all the other arguments are put in <code>sys.argv[1]</code>, <code>sys.argv[2]</code>, and so on.
        For example, here's a program that does nothing except print out its command-line arguments:
      </p>

<pre src="python/echo.py">
<span class="comment"># echo.py</span>
import sys
for i in range(len(sys.argv)):
  print i, '"' + sys.argv[i] + '"'
</pre>

      <p class="continue">
        If it is run without any arguments,
        it reports that <code>sys.argv[0]</code> is <code>echo.py</code>:
      </p>

<pre>
$ <span class="in">python echo.py</span>
<span class="out">0 echo.py</span>
</pre>

      <p class="continue">
        When it is run with arguments, though, it displays those as well:
      </p>

<pre>
$ <span class="in">python echo.py first second</span>
<span class="out">0 echo.py</span>
<span class="out">1 first</span>
<span class="out">2 second</span>
</pre>

      <p>
        We can use this to write command-line tools like a simple calculator:
      </p>

<pre src="python/calculator.py">
import sys

total = 0
for value in sys.argv[1:]:
    total += float(value)
print total
$ <span class="in">python calculator.py 1 2 3</span>
<span class="out">6.0</span>
</pre>

      <p class="continue">
        Notice that we loop over <code>sys.argv[1:]</code>,
        i.e.,
        over everything except the first element of <code>sys.argv</code>.
        That first element is always the name of our program
        (in this case, <code>calculator.py</code>),
        which we definitely don't want to try to add to our running total.
      </p>

      <p>
        A more common use of <code>sys.argv</code> is
        to pass the names of a bunch of files into our program.
        Suppose,
        for example,
        that we have a function called <code>summarize</code>
        that opens a file,
        reads the values in it,
        and returns the minimum, average, and maximum:
      </p>

<pre src="summarize.py">
def summarize(filename):
    reader = open(filename, 'r')
    least, greatest, total, count = 0.0, 0.0, 0.0
    for line in reader:
        current = float(line)
        least = min(least, current)
        greatest = max(least, current)
        total += current
        count += 1
    reader.close()
    return least, total / count, greatest
</pre>

      <p class="continue">
        If we want to display summaries for several files at once,
        we can require the user to give them as command-line arguments:
      </p>

<pre>
$ python summarize.py july.dat august.dat september.dat
</pre>

      <p class="continue">
        and connect the command line with the program's internals using <code>sys.argv</code>:
      </p>

<pre src="summarize.py">
all_filenames = sys.argv[1:]  <span class="comment"># Again, don't include the program name</span>
for filename in all_filenames:
    low, ave, high = summarize(filename)
    print filename, low, ave, high
</pre>

      <div class="keypoints" id="k:stdlib">
        <h3>Summary</h3>
        <ul>
          <li>Use <code>from <em>library</em> import <em>something</em></code> to import something under its own name.</li>
          <li>Use <code>from <em>library</em> import <em>something</em> as <em>alias</em></code> to import something under the name <code><em>alias</em></code>.</li>
          <li><code>from <em>library</em> import *</code> imports everything in <code><em>library</em></code> under its own name, which is usually a bad idea.</li>
          <li>The <code>math</code> library defines common mathematical constants and functions.</li>
          <li>The system library <code>sys</code> defines constants and functions used in the interpreter itself.</li>
          <li><code>sys.argv</code> is a list of all the command-line arguments used to run the program.</li>
          <li><code>sys.argv[0]</code> is the program's name.</li>
          <li><code>sys.argv[1:]</code> is everything except the program's name.</li>
        </ul>
      </div>

    </section>

    <section id="s:filter">

      <h2>Building Filters</h2>

      <div class="understand" id="u:filter">
        <h3>Understand:</h3>
        <ul>
          <li>How to build a program that behaves like a Unix filter.</li>
          <li>How to decide what should be done in a function and what should be done by its caller.</li>
          <li>How to get help interactively.</li>
          <li>How to provide interactive help.</li>
          <li>How a file can tell if it's being used as the main program or being loaded as a library.</li>
        </ul>
      </div>

      <p>
        As well as creating a list of a program's command-line arguments,
        <code>sys</code> also connects the program to standard input,
        standard output,
        and standard error
        (which were introduced in the chapter on <a href="shell.html#s:pipefilter">the Unix shell</a>).
        Here's a typical example of how these variables are used together:
      </p>

<pre src="python/count.py">
import sys

def count_lines(reader):
    result = 0
    for line in reader:
        result += 1
    return result

if len(sys.argv) == 1:
    count_lines(sys.stdin)
else:
    for filename in sys.argv[1:]:
        rd = open(filename, 'r')
        count_lines(rd)
        rd.close()
</pre>

      <p class="continue">
        This program looks at <code>sys.argv</code> to see if it was called with any filenames as arguments or not.
        If there were no arguments,
        then <code>sys.argv</code> will only hold the name of the program,
        and its length will be 1.
        In that case, the program reads data from standard input:
      </p>

<pre>
$ <span class="in">python count.py &lt; a.txt</span>
<span class="out">48</span>
</pre>

      <p class="continue">
        Otherwise,
        the program assumes its command-line arguments are the names of files.
        It opens each one in turn,
        counts how many lines are in it,
        and then closes it:
      </p>

<pre>
$ <span class="in">python count.py a.txt b.txt</span>
<span class="out">48
227</span>
</pre>

      <div class="box">
        <h3>Who Opens?</h3>

        <p>
          There's a subtle but important difference between <code>count_lines</code>
          and the <code>summarize</code> function we wrote earlier.
          <code>summarize</code> expects a filename as its sole parameter,
          and opens and closes that file itself.
          <code>count_lines</code>,
          on the other hand,
          expects to be given a handle to an already-open file,
          i.e.,
          it expects whoever is calling it to take care of the opening and closing.
        </p>

        <p>
          Why the difference?
          Because we want to use the same <code>count_lines</code> function
          for both the files whose names we're given on the command line,
          and for <code>sys.stdin</code>.
          Putting it another way,
          we can't call <code>open</code> with <code>sys.stdin</code> as a parameter&mdash;it's
          already an open file, not a string&mdash;so
          we have to do our opening before we call the function.
        </p>

        <p>
          We <em>could</em> push responsibility for opening down into the function if we really wanted to,
          so that our main program was just:
        </p>

<pre src="python/count_2.py">
if len(sys.argv) == 1:
    count_lines(sys.stdin)
else:
    for filename in sys.argv[1:]:
        count(filename)
</pre>

        <p class="continue">
          If we do this,
          though,
          the function has to check whether its parameter is a string
          (which we interpret to mean "the name of a file")
          or something else
          (which we hope is an open file we can read from).
          We have to do the same check at the end of the function as well
          to close the file if we opened it:
        </p>

<pre src="python/count_2.py">
def count_lines(source):
<span class="highlight">    if type(source) == str:
        reader = open(source, 'r')</span>
    result = 0
    for line in reader:
        result += 1
<span class="highlight">    if type(source) == str:
        reader.close()</span>
    return result
</pre>

        <p class="continue">
          Most people find the original easier to understand,
          since it does a better job of separating
          the calculation from the file management.
        </p>

      </div>

      <p>
        Let's go back to our original program
        and write it a little more politely:
      </p>

<pre src="src/polite_count.py">
'''Count lines in files.  If no filename arguments given,
read from standard input.'''

import sys

def count_lines(reader):
  '''Return number of lines in text read from reader.'''
  return len(reader.readlines())

if __name__ == '__main__':
  if len(sys.argv) == 1:
    print count_lines(sys.stdin)
  else:
    r = open(sys.argv[1], 'r')
    print count_lines(r)
    r.close()
</pre>

      <p class="continue">
        The two significant changes are
        the strings at the start of the module and of the function <code>count_lines</code>,
        and the funny-looking line that compares <code>__name__</code> to <code>'__main__'</code>.
        Let's look at them in that order.
      </p>

      <p>
        To help us find our way around libraries,
        Python provides a <code>help</code> function.
        If <code>math</code> has been imported,
        the call <code>help(math)</code> prints out the documentation embedded in the math library:
      </p>

<pre>
&gt;&gt;&gt; <span class="in">import math</span>
&gt;&gt;&gt; <span class="in">help(math)</span>
<span class="out">Help on module math:
NAME
    math
FILE
    /usr/lib/python2.5/lib-dynload/math.so
MODULE DOCS
    http://www.python.org/doc/current/lib/module-math.html
DESCRIPTION
    This module is always available.  It provides access to the
    mathematical functions defined by the C standard.
FUNCTIONS
    acos(...)
        acos(x)
        Return the arc cosine (measured in radians) of x.
    &hellip;        &hellip;        &hellip;</span>
</pre>

      <p>
        Here's how this works.
        If the first thing in a module or function other than blank lines or comments is a string,
        and that string isn't assigned to a variable,
        Python saves it as the documentation string,
        or <a href="glossary.html#docstring">docstring</a>,
        for that module or function.
        These docstrings are what online (and offline) help display.
        For example,
        let's create a file <code>adder.py</code> with a single function <code>add</code>,
        and write docstrings for both the module and the function:
      </p>

<pre src="python/adder.py">
<span class="comment"># adder.py</span>
'''Addition utilities.'''

def add(a, b):
  '''Add arguments.'''
  return a+b
</pre>

      <p class="continue">
        If we import <code>adder</code>,
        <code>help(adder)</code> prints out all of its docstrings,
        i.e., the documentation for the module itself and for all of its functions:
      </p>

<pre>
&gt;&gt;&gt; <span class="in">import adder</span>
&gt;&gt;&gt; <span class="in">help(adder)</span>
<span class="out">NAME
    adder - Addition utilities.
FUNCTIONS
    add(a, b)
        Add arguments.</span>
</pre>

      <p class="continue">
        We can also be more selective,
        and only display the help for a particular function instead:
      </p>

<pre>
&gt;&gt;&gt; help(adder.add)
<span class="out">add(a, b)
       Add arguments.</span>
</pre>

      <p>
        The second part of our more polite program was that odd-looking <code>if</code> statement.
        It depends on a trick to do something useful,
        and that trick needs a bit of explaining.
        When Python reads in a file,
        it assigns a value to a special variable called <code>__name__</code>
        (with two underscores before and after).
        If the file is being run as the main program,
        <code>__name__</code> is assigned the string <code>'__main__'</code>
        (again with two underscores before and after).
        If the file is being loaded as a module by some other program,
        though,
        Python assigns the module's name to <code>__name__</code> instead.
        To show this in action,
        let's create a Python file called <code>my_name.py</code>
        that does nothing but print out the value of <code>__main__</code>:
      </p>

<pre src="my_name.py">
print __name__
</pre>

      <p class="continue">
        If we run it directly from the command line,
        it tells us that <code>__name__</code> has the value <code>'__main__'</code>:
      </p>

<pre>
$ <span class="in">python my_name.py</span>
<span class="out">__name__</span>
</pre>

      <p class="continue">
        If we import this file into an interactive Python session,
        though,
        what's printed out during the import is different:
      </p>

<pre>
$ <span class="in">python</span>
&gt;&gt;&gt; <span class="in">import my_name</span>
<span class="out">my_name</span>
</pre>

      <p class="continue">
        We get the same behavior if we import <code>my_name</code> into another program:
      </p>

<pre>
$ <span class="in">cat test_import.py</span>
<span class="out">import my_name</span>
$ <span class="in">python test_import.py</span>
<span class="out">my_name</span>
</pre>

      <p>
        Now,
        suppose that a file contains the conditional statement
        <code>if __name__ == '__main__'</code>.
        The code inside the <code>if</code> will only run if the file is the main program,
        because that's the only situation in which <code>__name__</code> will be <code>'__main__'</code>.
        Put another way,
        the statements inside the conditional will <em>not</em> be run
        if the file is being loaded as a library by some other program.
        This makes it easy to write modules
        that can be used as both programs in their own right,
        and as libraries by other pieces of code.
      </p>

      <p>
        For example,
        the file <code>stats.py</code> defines a function <code>average</code>,
        and then runs three simple tests&mdash;but
        only if <code>__name__</code> has the value <code>'__main__'</code>:
      </p>

<pre src="src/stats.py">
# stats.py
'''Useful statistical tools.'''

def average(values):
  '''Return average of values or None if no data.'''
  if values:
    return sum(values) / len(values)
  else:
    return None

if __name__ == '__main__':
  print 'test 1 should be None:', average([])
  print 'test 2 should be 1:', average([1])
  print 'test 3 should be 2:', average([1, 2, 3])
</pre>

      <p class="continue">
        If we import this file into an interactive session,
        it doesn't produce any output,
        because <code>stats.__name__</code> has been assigned the value <code>'stats'</code>:
      </p>

<pre>
&gt;&gt;&gt; <span class="in">import stats</span>
&gt;&gt;&gt; <span class="in">print stats.__name__</span>
<span class="out">stats</span>
</pre>

      <p class="continue">
        If we run this file directly, though,
        that same <code>__name__</code> variable will be assigned the value <code>'__main__'</code>,
        so the test <em>will</em> be run:
      </p>

<pre>
$ <span class="in">python stats.py</span>
<span class="out">test 1 should be None: None
test 2 should be 1: 1
test 3 should be 2: 2</span>
</pre>

      <p class="continue">
        This is another common design pattern in Python:
        group related functions into a module,
        then put some tests for those functions in the same module
        under <code>if __name__ == '__main__'</code>,
        so that if the module is run as the main program,
        it will check itself.
      </p>

      <div class="box">
        <h3>How Other Languages Do It</h3>

        <p>          
          The <code>__name__ == 'main'</code> idiom is
          one of the few things that Python got wrong:
          it's economical,
          in that it doesn't introduce any special-purpose machinery that doesn't have to be there anyway,
          but novices have to master several difficult concepts
          before they can understand how it works.
        </p>

        <p>
          Other languages handle the "where do I start?" problem differently.
          C,
          for example,
          expects programs to have a function called <code>main</code>,
          which is automatically invoked to start the program running.
        </p>

      </div>

      <div class="keypoints" id="k:filter">
        <h3>Summary</h3>
        <ul>
          <li>If a program isn't told what files to process, it should process standard input.</li>
          <li idea="paranoia">Programs that explicitly test values' types are more brittle than ones that rely on those values' common properties.</li>
          <li>The variable <code>__name__</code> is assigned the string <code>'__main__'</code> in a module when that module is the main program, and the module's name when it is imported by something else.</li>
          <li>If the first thing in a module or function is a string that isn't assigned to a variable, that string is used as the module or function's documentation.</li>
          <li>Use <code>help(<em>name</em>)</code> to display the documentation for something.</li>
        </ul>
      </div>

    </section>

    <section id="s:summary">

      <h2>Summing Up</h2>

      <p>
        Novices (and people looking for an argument) often ask,
        "What's the best programming language?"
        The answer depends on what we want to do.
        If we want to write small programs quickly,
        and be able to manage the complexity of larger ones,
        then dynamic languages like Python, Ruby, R, and MATLAB are good choices:
        they optimize programming time over execution time.
        If we want to squeeze the last ounce of performance out of our hardware,
        then compiled languages like C++, C#, and modern dialects of Fortran
        are currently better options.
        And if we want a user interface that runs (almost) everywhere,
        Javascript has become a surprisingly strong contender.
      </p>

      <p>
        Functions are a way to divide code up into more comprehensible pieces:
        essentially,
        to replace several pieces of information with one to make the whole easier to understand.
        Functions are therefore not just about eliminating redundancy:
        they are worth writing even if they're only called once.
      </p>

      <p>
        In fact,
        functions are such a powerful idea that
        many people regard programming as the art of defining a mini-language
        in which the solution to the original problem is trivial.
        To close off this chapter,
        let's try to answer a frequently-asked question:
        when should we write functions?
        And what should we put in them?
      </p>

      <p>
        The answers to these questions depend on the fact that
        human short-term memory can only hold a few things at a time.
        If we try to remember more than a double handful of unrelated bits of information
        for more than a few seconds,
        they become jumbled and we start making mistakes.
        In particular,
        if someone has to keep several dozen things straight in their mind
        in order to understand a piece of code,
        that code is too long.
      </p>

      <p>
        Let's consider an example:
      </p>

<pre src="python/cognitive_limits_initial.py">
for x in range(1, GRID_WIDTH-1):
  for y in range(1, GRID_HEIGHT-1):
    if (density[x-1][y] &gt; density_threshold) or \
       (density[x+1][y] &gt; density_threshold):
      if (flow[x][y-1] &lt; flow_threshold) or\
         (flow[x][y+1] &lt; flow_threshold):
        temp = (density[x-1][y] + density[x+1][y]) / 2
        if abs(temp - density[x][y]) &gt; update_threshold:
          density[x][y] = temp
</pre>

      <p class="continue">
        This code uses meaningful variable names,
        and is well structured,
        but it's still a lot to digest in one go.
        Let's replace the loop bounds with function calls
        that give us a bit more context:
      </p>

<pre src="python/cognitive_limits_bounds.py">
for x in grid_interior(GRID_WIDTH):
  for y in grid_interior(GRID_HEIGHT):
    if (density[x-1][y] &gt; density_threshold) or \
       (density[x+1][y] &gt; density_threshold):
      if (flow[x][y-1] &lt; flow_threshold) or\
         (flow[x][y+1] &lt; flow_threshold):
        temp = (density[x-1][y] + density[x+1][y]) / 2
        if abs(temp - density[x][y]) &gt; update_threshold:
          density[x][y] = temp
</pre>

      <p class="continue">
        <code>grid_interior(num)</code> might just return <code>range(1, num-1)</code>,
        but try reading the first two lines of this code aloud,
        and then the first two lines of what it replaced,
        and see which is easier to understand.
      </p>

      <p>
        Now let's replace those two <code>if</code> statements with function calls as well:
      </p>

<pre src="python/cognitive_limits_threshold.py">
for x in grid_interior(GRID_WIDTH):
  for y in grid_interior(GRID_HEIGHT):
    if density_exceeds(density, x, y, density_threshold):
      if flow_exceeds(flow, x, y, flow_threshold):
        temp = (density[x-1][y] + density[x+1][y]) / 2
        if abs(temp - density[x][y]) > tolerance:
          density[x][y] = temp
</pre>

      <p class="continue">
        Again, we've provided more information about what we're actually doing.
        Finally, let's create and call a function
        to handle updates to our data structure:
      </p>

<pre src="python/cognitive_limits_final.py">
for x in grid_interior(GRID_WIDTH):
  for y in grid_interior(GRID_HEIGHT):
    if density_exceeds(density, x, y, density_threshold):
      if flow_exceeds(flow, x, y, flow_threshold):
        update_on_tolerance(density, x, y, tolerance)
</pre>

      <p class="continue">
        Our original nine lines have become five,
        and those five are all at the same mental level.
        It's hard to pin down exactly what that phrase means,
        but most programmers would agree that
        the first version mixed high-level ideas about boundaries and update conditions
        with low-level details of grid access and cell value comparisons.
        In contrast,
        this version only has the high-level stuff;
        the low-level implementation details are hidden in those functions.
      </p>

      <p>
        A conscientious programmer who wrote the code we started with
        would go back and <a href="glossary.html#refactor">refactor</a> it
        to turn it into something like our final version
        before committing it to <a href="svn.html">version control</a>.
        If she did this often enough,
        she would eventually find herself writing the final version first,
        just as mathematicians find themselves skipping more and more "obvious" steps
        as they do more proofs.
        When we see someone "just writing" something elegant,
        the odds are good that they have spent time rewriting their own poor code,
        and in doing so,
        turned conscious decision into unconscious action.
      </p>

    </section>
{% endblock content %}
