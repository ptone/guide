{% extends "templates/_base.html" %}

{% block file_metadata %}
  <meta name="title" content="Basic Programming With Python and Images" />
  <meta name="status" content="Still being written" />
{% endblock file_metadata %}

{% block content %}

<p>
  Valerie Visual is studying human visual processing.
  More specifically,
  she is studying the way the brain interprets missing or noisy information.
  For one of her experiments,
  she wants to introduce successively larger amounts of random noise into a series of pictures
  to see when different people start to notice that something is wrong.
</p>

<p>
  If Valerie only wanted one or two images,
  the simplest way to create them might be
  to use a tool like Photoshop.
  However,
  she wants to show each test subject several hundred images.
  What she <em>doesn't</em> want to do is
  spend more time creating those images
  than actually running her experiments.
  She's going to have to learn how to program,
  and that's what this lesson is about.
</p>

<p>
  We will use a programming language called Python for our examples.
  Python is free,
  reasonably well documented,
  and widely used in science and engineering.
  Our main reason for choosing it,
  though,
  is that newcomers find it easier to read than most other languages.
  It also allows people to do useful things
  without having to master advanced concepts like object-oriented programming.
</p>

<p>
  The particular version of Python we'll use is called IPython.
  It was developed by and for scientists,
  and comes with many extra tools which we'll explore as we go along.
  The most important of these is an electronic lab notebook
  that allows us to view and annotate our work as we go along.
</p>

<p>
  Finally,
  our programs will use two libraries
  that were specifically written for novices.
  Both work on grids of pixels,
  but the first does this directly in the browser,
  so that we can see what we're doing as we go along,
  while the second manipulates photographs and other image files.
</p>

<section id="s:basic">
  <h2>Basic Operations</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Run and use the IPython Notebook.</li>
      <li>Do basic arithmetic in Python.</li>
      <li>Assign values to variables, and use those variables in expressions.</li>
      <li>Explain how variable names should be chosen, and choose appropriate names for variables.</li>
    </ul>
  </div>

  <p>
    The best way to learn how to program is to start programming,
    so open a shell and run the IPython Notebook by typing:
  </p>

<pre>
$ <span class="in">ipython notebook</span>
<span class="out">[NotebookApp] Using existing profile dir: u'/Users/gwilson/.ipython/profile_default'
[NotebookApp] Serving notebooks from /Users/gwilson
[NotebookApp] The IPython Notebook is running at: http://127.0.0.1:8888/
[NotebookApp] Use Control-C to stop this server and shut down all kernels.</span>
</pre>

  <p class="continue">
    If everything has been installed correctly,
    you will see something like the output shown above,
    which tells you that IPython has started running.
    You will also see something like <a href="#f:ipython_welcome">Figure XXX</a>
    in your browser.
  </p>

  <figure id="f:ipython_welcome">
    <img src="pymedia/ipython_welcome.png" alt="IPython Notebook Startup Screen" />
    <figcaption>Figure XXX: IPython Notebook Startup Screen</figcaption>
  </figure>

  <figure id="f:empty_notebook">
    <img src="pymedia/empty_notebook.png" alt="An Empty Notebook" />
    <figcaption>Figure XXX: An Empty Notebook</figcaption>
  </figure>

  <p>
    If you click on the "New Notebook" button,
    a new tab will open in your browser
    with an empty notebook
    (<a href="#f:empty_notebook">Figure XXX</a>).
    At this point, you're ready to go,
    so type the following line into the text box
    and choose "Run" from the "Cell" menu.
    You should get the output shown
    (<a href="#f:first_computation">Figure XXX</a>).
  </p>

<pre>
<span class="in">print 1 + 1</span>
<span class="out">2</span>
</pre>

  <figure id="f:first_computation">
    <img src="pymedia/first_computation.png" alt="Our First Computation" />
    <figcaption>Figure XXX: Our First Computation</figcaption>
  </figure>

  <p>
    <a href="#f:architecture">Figure XXX</a> shows what just happened.
    When we type something into the notebook and run it,
    the browser sends the contents of the cell to IPython,
    which is running in the background.
    IPython runs our commands and sends output back to the browser,
    which displays it
    and gives us another box for input.
  </p>

  <figure id="f:architecture">
    <img src="pymedia/architecture.png" alt="The Architecture of the IPython Notebook" />
    <figcaption>Figure XXX: The Architecture of the IPython Notebook</figcaption>
  </figure>

  <div class="box">
    <h3>Shortcuts</h3>
    <p>
      We can access all of the Notebook's commands through its menus,
      but it's often easier to use keyboard shortcuts.
      Typing Control-M follows by 'h' (for "help") displays a list of these;
      along with the usual copy, paste, and delete,
      the most commonly used are:
    </p>
    <table>
      <tr>
        <td>Shift-Enter</td>
        <td>Run the current cell and move to the next one.</td>
      </tr>
      <tr>
        <td>Control-Enter</td>
        <td>Run the current cell and stay in it.</td>
      </tr>
      <tr>
        <td>Control-M + L</td>
        <td>Turn line numbering on or off.</td>
      </tr>
      <tr>
        <td>Control-M + A</td>
        <td>Insert a new cell above the current one.</td>
      </tr>
      <tr>
        <td>Control-M + B</td>
        <td>Insert a new cell below the current one.</td>
      </tr>
    </table>
  </div>

  <p>
    Now enter and run this:
  </p>

<pre>
<span class="in">x = 1+1</span>
</pre>

  <p class="continue">
    Python doesn't display anything this time
    (except a new cell).
    Instead,
    as <a href="#f:first_variable">Figure XXX</a> shows,
    it creates a <a href="glossary.html#variable">variable</a> called <code>x</code>
    and assigns it the value 2.
    We can then get that variable's value simply by entering its name:
  </p>

<pre>
<span class="in">print x</span>
<span class="out">2</span>
</pre>

  <figure id="f:first_variable">
    <img src="pymedia/first_variable.png" alt="Our First Variable" />
    <figcaption>Figure XXX: Our First Variable</figcaption>
  </figure>

  <div class="box">

    <h3>Statements vs. Expressions</h3>

    <p>
      Python is a fairly relaxed language,
      but there are some things it won't let us do.
      For example,
      this doesn't work:
    </p>

<pre>
print x = 1 + 2
<span class="err">SyntaxError: invalid syntax</span>
</pre>

    <p class="continue">
      The problem is that printing and assignment are both
      <a href="glossary.html#statement">statements</a>,
      and statements cannot be mixed together.
      1+2, on the other hand,
      is an <a href="glossary.html#expression">expression</a>&mdash;something
      that produces a new value&mdash;and expressions can be combined in many ways.
      Except for assignment,
      every statement in Python begins with a keyword like <code>print</code>,
      so it's usually easy to tell them apart.
    </p>

  </div>

  <p>
    We can now use the value of <code>x</code> in new calculations:
  </p>

<pre>
<span class="in">print x * 2</span>
<span class="out">4</span>
</pre>

  <p class="continue">
    including ones that create more variables:
  </p>

<pre>
<span class="in">y = x * 2</span>
<span class="in">print y</span>
<span class="out">4</span>
</pre>

  <p class="continue">
    We can change a variable's value
    by assigning something new to it:
  </p>

<pre>
<span class="in">x = 10</span>
<span class="in">print x</span>
<span class="out">10</span>
</pre>

  <p class="continue">
    As <a href="#f:assign_new_value">Figure XXX</a> shows,
    assigning something to <code>x</code> changes what it points to,
    but does not change anything else.
    In particular,
    <code>y</code> still has the value 4 after this assignment:
    it is not automatically updated when <code>x</code>'s value changes,
    as it would in a spreadsheet.
  </p>

  <figure id="f:assign_new_value">
    <img src="pymedia/assign_new_value.png" alt="Assigning a New Value" />
    <figcaption>Figure XXX: Assigning a New Value</figcaption>
  </figure>

  <p>
    Notice,
    by the way,
    that some of our input cells contain several lines of Python.
    Referring back to <a href="#f:architecture">Figure XXX</a>,
    everything in a cell is sent to IPython for execution at once,
    and all of the output from those lines comes back as a single new output cell.
  </p>

  <div class="box">
    <h3>When to Print</h3>
    <p class="fixme">explain that only the last line of raw input produces output, and recommend print</p>
  </div>

  <p>
    Here's a more complex calculation:
  </p>

<pre>
<span class="in">x = 98.6</span>
<span class="in">y = (x - 32.0) * (5.0 / 9.0) + 273.15</span>
<span class="in">print y</span>
<span class="out">310.15</span>
</pre>

  <p class="continue">
    Its meaning becomes clearer if we rewrite it as:
  </p>

<pre>
<span class="in">temp_fahr = 98.6</span>
<span class="in">temp_kelvin = (temp_fahr - 32.0) * (5.0 / 9.0) + 273.15</span>
<span class="in">print "body temperature in Kelvin:", temp_kelvin</span>
<span class="out">body temperature in Kelvin: 310.15</span>
</pre>

  <p>
    The first line creates a new variable called <code>temp_fahr</code>
    (short for "temperature in Fahrenheit")
    and gives it the value 98.6
    (<a href="#f:first_memory_model">Figure XXX</a>).
    The second line creates another variable to hold the temperature in Kelvin
    (hence its name).
    It calculates a value for this variable
    that depends on the value of <code>temp_fahr</code>.
    The last line prints the result.
    The <a href="glossary.html#string">character string</a>
    (or just "string" for short)
    inside double quotes is printed as-is,
    followed by the value of <code>temp_kelvin</code>.
  </p>

  <figure id="f:first_memory_model">
    <img src="pymedia/first_memory_model.png" alt="First Memory Model" />
    <figcaption>Figure XXX: First Memory Model</figcaption>
  </figure>

  <p>
    Like every program,
    this one stores data and does calculations.
    We use variables to do the first,
    and write instructions that use those variables to do the second.
    And like every <em>good</em> program,
    it is written with human beings in mind.
    Computers get faster every year,
    but our brains don't.
    As a result,
    the biggest bottleneck in scientific computing is often not how fast the program is,
    but how long it takes us to write it.
    This is why we use variable names like <code>temp_fahr</code> and <code>temp_kelvin</code>
    instead of <code>x</code> and <code>y</code>:
    they optimize the performance of the most expensive hardware we have.
  </p>

  <div class="box" id="a:creating-variables">
    <h3>Creating Variables</h3>

    <p>
      Python creates a variable whenever a value is assigned to a name,
      but won't let us get the value of a variable that hasn't been assigned one.
      For example,
      if we try to do this:
    </p>

<pre>
<span class="in">double_temp = temp_celsius * 2</span>
</pre>

    <p class="continue">
      then Python prints an error message:
    </p>

<pre>
<span class="err">NameError                                 Traceback (most recent call last)
&lt;ipython-input-7-0fae4d15df1c&gt; in &lt;module&gt;()
----&gt; 1 double_temp = temp_celsius * 2

NameError: name 'temp_celsius' is not defined</span>
</pre>

    <p class="continue">
      We'll explain what "module" means <a href="funclib.html">later</a>.
      What's important now is that this strictness helps catch a lot of typing mistakes.
      If we mistakenly type <code>temp_far</code> instead of <code>temp_fahr</code>:
    </p>

<pre>
<span class="in">temp_kelvin = (<span class="highlight">temp_far</span> - 32.0) * (5.0 / 9.0) + 273.15</span>
</pre>

    <p class="continue">
      then Python will tell us something's gone wrong.
      It can't help us if we type 3.20 instead of 32.0, though;
      if we want to catch that mistake,
      we'll actually have to <a href="quality.html">test our program</a>.
    </p>

  </div>

  <p>
    Readability is also why we put the temperature in Fahrenheit in a variable,
    then use that variable in line 2,
    rather than just putting 98.6 directly in the calculation.
    If we ever want to convert another temperature,
    it's easier to see and change the value on line 1
    than it would be to find it buried in the middle of a line of arithmetic.
  </p>

  <div class="box">
    <h3>Tab Completion</h3>

    <p>
      Using longer variable names doesn't necessarily mean doing more typing.
      Like the shell,
      IPython supports <a href="shell.html#a:tab-completion">tab completion</a>:
      if we have created variables called <code>temp_fahr</code> and <code>temp_kelvin</code>,
      then type "te" and press tab,
      the notebook will display a list of completions for us to choose from
      (<a href="#f:tab_completion">Figure XXX</a>.
      If we get as far as typing "temp_f" and press tab,
      the rest of the name will be filled in completely
      because there's only one possible choice.
    </p>

    <figure id="f:tab_completion">
      <img src="pymedia/tab_completion.png" alt="Tab Completion" />
      <figcaption>Figure XXX: Tab Completion</figcaption>
    </figure>

    <p>
      After a while,
      some programmers start to choose variable names to optimize tab completion
      (whether they're conscious of doing so or not).
      For example,
      they might use <code>t_fahr</code> and <code>t_kelvin</code> for temperatures
      so that they only have to type three characters and press tab
      to fill in the rest of the variable name.
      Others find that using slightly longer but more comprehensible names
      is a better balance between typing time and reading time.
      The most important thing is to be consistent:
      every inconsistency in naming costs extra time to read.
    </p>
  </div>

  <p>
    Finally,
    our first few programs show how arithmetic is done.
    '+' means addition,
    '*' means multiplication,
    and parentheses group things together,
    just as they do in pen-and-paper arithmetic.
  </p>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>Use '=' to assign a value to a variable.</li>
      <li>Variables are created when values are assigned to them.</li>
      <li>Variables cannot be used until they have been created.</li>
      <li>Assigning to one variable does not change the values associated with other variables.</li>
      <li>Use <code>print</code> to display multiple values at once.</li>
      <li>Addition ('+'), subtraction ('-'), and multiplication ('*') work as usual in Python.</li>
      <li>Using readable names for variables improves programmer performance.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>
    <p class="fixme">write some challenges</p>
  </div>

</section>

<section id="s:types">
  <h2>Types</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Explain what a data type is.</li>
      <li>Identify the types of integers, floating-point numbers, and strings.</li>
      <li>Call simple built-in functions correctly.</li>
    </ul>
  </div>

  <p>
    Let's take another look at the Python we have written so far:
  </p>

<pre>
<span class="in">temp_fahr = 98.6</span>
<span class="in">temp_kelvin = (temp_fahr - 32.0) * (5.0 / 9.0) + 273.15</span>
<span class="in">print "body temperature in Kelvin:", temp_kelvin</span>
<span class="out">body temperature in Kelvin: 310.15</span>
</pre>

  <p>
    Why have we written 5.0/9.0 instead of 5/9?
    Let's see what happens if we take out the .0's:
  </p>

<pre>
<span class="in">temp_fahr = 98.6</span>
<span class="highlight">temp_kelvin = (temp_fahr - 32) * (5 / 9) + 273.15</span>
<span class="in">print "body temperature in Kelvin:", temp_kelvin</span>
<span class="out">body temperature in Kelvin: 273.15</span>
</pre>

  <p>
    That's not right.
    To understand what's gone wrong,
    let's look at 5/9:
  </p>

<pre>
<span class="in">5/9</span>
<span class="out">0</span>
</pre>

  <p>
    The problem is that the computer treats integers and floating point numbers differently.
    If a number doesn't have a decimal point,
    then Python stores its value as an integer
    with no fractional part.
    And when it divides one integer by another,
    it throws away the remainder:
    to a computer,
    5/2 is 2, not 2.5.
  </p>

  <p>
    If a number contains a decimal point,
    though,
    Python stores it as a floating-point number
    (or <a href="glossary.html#float">float</a>).
    When it does division or any other kind of arithmetic,
    the result is a float if either of the values involved is a float:
  </p>

<pre>
<span class="in">10 / 3</span>
<span class="out">3</span>
<span class="in">10.0 / 3</span>
<span class="out">3.3333333333333335</span>
</pre>

  <p class="continue">
    Version 3 of Python changed the rules for division
    so that it creates fractional numbers when it should.
    However,
    we're using Python 2.7,
    so 10/3 is 3 until further notice.
  </p>

  <div class="box">
    <h3>Remainder</h3>
    <p>
      Python has another "division" operator,
      written '%',
      which returns the remainder that integer division throws away:
    </p>
<pre>
<span class="in">10 % 3</span>
<span class="out">1</span>
<span class="in">15 % 6</span>
<span class="out">3</span>
</pre>
  </div>

  <p>
    Integers and floats are two <a href="glossary.html#type">types</a> of data.
    Every value in a program has a specific type
    that determines how it behaves and what can be done to it.
    We can find out what type something is
    using a built-in <a href="glossary.html#function">function</a> called <code>type</code>:
  </p>

<pre>
<span class="in">type(12)</span>
<span class="out">&lt;type 'int&gt;</span>
<span class="in">type(12.0)</span>
<span class="out">&lt;type 'float&gt;</span>
</pre>

  <p>
    Another common data type is the character string.
    We can create one by putting characters inside either single or double quotes
    (as long as we use the same kind at the beginning and end):
  </p>

<pre>
<span class="in">name = "Alan Turing"</span>
<span class="in">born = 'June 23, 1912'</span>
<span class="in">print name, born</span>
<span class="out">Alan Turing June 23, 1912</span>
</pre>

  <p>
    We can also "add" and "multiply" strings:
  </p>

<pre>
<span class="in">full = name + " (" + born + ")"</span>
<span class="in">print full</span>
<span class="out">Alan Turing (June 23, 1912)</span>
<span class="in">print "ho" * 3</span>
<span class="out">hohoho</span>
</pre>

  <p id="a:add-num-str">
    What we <em>can't</em> do is add numbers and strings:
  </p>

<pre>
<span class="in">print 2 + "three"</span>
<span class="err">TypeError                                 Traceback (most recent call last)
&lt;ipython-input-8-f6f99c093ec8&gt; in &lt;module&gt;()
----&gt; 1 print 2 + "three"

TypeError: unsupported operand type(s) for +: 'int' and 'str'</span>
</pre>

  <p>
    The reason we can't is that
    "2three" would be a reasonable result in this case,
    but it's not so clear what <code>2+"3"</code> should do:
    should it produce the integer 5 or the string <code>"23"</code>?
    Rather than guessing at the programmer's intentions,
    Python requires us to tell it
    whether to convert the number to a string or the string to a number
    so that it knows what kind of addition to do.
    We do this using <code>int</code> and <code>str</code>,
    which are two more built-in functions:
  </p>

<pre>
<span class="in">print 2 + int("3")</span>
<span class="out">5</span>
<span class="in">print str(2) + "3"</span>
<span class="out">23</span>
</pre>

  <p>
    Finally,
    it's important to keep in mind that variables don't have types in Python:
    only values do.
    A variable is a just a name for a value;
    it can refer to a string at one point in a program,
    and a float at another:
  </p>

<pre>
<span class="in">temp = 'temperature'</span>
<span class="in">print temp, type(temp)</span>
<span class="out">temperature &lt;type 'str'&gt;</span>
<span class="in">temp = 37.2</span>
<span class="in">print temp, type(temp)</span>
<span class="out">37.2 &lt;type 'float'&gt;</span>
</pre>

  <div class="box">
    <h3>Static vs. Dynamic Typing</h3>
    <p>
      Programmers argue incessantly about whether this is a good idea or not.
      In <a href="glossary.html#static-typing">statically-typed</a> languages like Fortran, C++, Java, and Haskell,
      every variable has a type,
      and can only store values of that type.
      Proponents say that
      this restriction makes it easier for compilers to optimize programs,
      and for other tools (and human readers) to check their correctness,
      but languages designed for interactive use&mdash;like Python,
      Perl, and R&mdash;tend to be
      <a href="glossary.html#dynamic-typing">dynamically typed</a>
      in order to keep typing&mdash;the fingers-on-keyboard kind&mdash;to a minimum.
    </p>
  </div>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>The most commonly used data types in Python are integers (<code>int</code>), floating-point numbers (<code>float</code>), and strings (<code>str</code>).</li>
      <li>Strings can start and end with either single quote (') or double quote (&quot;).</li>
      <li>Division ('/') produces an <code>int</code> result when given <code>int</code> values: one or both arguments must be <code>float</code> to get a <code>float</code> result.</li>
      <li>The modulo operator ('%') produces the remainder from integer division.</li>
      <li>"Adding" strings concatenates them, multiplying strings by numbers repeats them.</li>
      <li>Strings and numbers cannot be added because the behavior is ambiguous: convert one to the other type first.</li>
      <li>Variables in Python do not have types, but values do.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>
    <p class="fixme">write some challenges</p>
  </div>

</section>

<section id="s:lib">
  <h2>Libraries, Blocks, and Colors</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Explain what a library is and why programmers use them.</li>
      <li>Import a library and use its contents.</li>
      <li>Create and manipulate block images using IPythonBlocks.</li>
      <li>Explain how colors are represented in a computer.</li>
      <li>Create specific colors numerically.</li>
    </ul>
  </div>

  <p>
    Now that we can do basic arithmetic,
    let's look at where the real power of most programming languages is.
    Run this in an IPython Notebook cell:
  </p>

<pre>
<span class="in">import math
print "pi is", math.pi
print "square root of 5 is", math.sqrt(5)</span>
<span class="out">pi is 3.14159265359
square root of 5 is 2.2360679775</span>
</pre>

  <p>
    The first line in this cell is the most important.
    It tells Python to find a library called <code>math</code>
    and load it into our program.
    We can then refer to the variables defined inside that library,
    like &pi;,
    as <code><em>library</em>.<em>variable</em></code>,
    and call its functions,
    like square root,
    as <code><em>library</em>.<em>function</em></code>,
  </p>

  <p>
    Two-part names are used because
    many different libraries can define variables or functions with the same names.
    For example,
    <code>math.log</code> returns the natural logarithm of a number,
    while <code>server.log</code>
    (i.e., the <code>log</code> function defined by the <code>server</code> library)
    writes a log message to a file.
    It's exactly like saying "Valerie's paper" rather than just "the paper".
  </p>

  <div class="box">
    <h3>Shortcuts</h3>

    <p>
      Since <code>math.sqrt</code> is a handful to type,
      and <code>sqrt</code> is probably not ambiguous,
      Python provides several ways to import things.
      For example,
      we can import specific functions from a library and then call them directly:
    </p>

<pre>
<span class="in">from math import sqrt
sqrt(3)</span>
<span class="out">1.7320508075688772</span>
</pre>

    <p class="continue">
      We can also import a function under a different name,
      so that if two modules define functions with the same name,
      we can give one or the other a different name when we want to use them together:
    </p>

<pre>
<span class="in">from math import hypot as euclid
euclid(3, 4)</span>
<span class="out">5.0</span>
</pre>

    <p>
      Finally,
      we can use <code>import *</code>
      to bring everything in the module into the current scope at once.
      This has the same effect as using <code>from module import a</code>,
      <code>from module import b</code>,
      and so on for every name in the module:
    </p>

<pre>
<span class="in">from math import *
sin(pi)</span>
<span class="out">1.2246063538223773e-16</span>
</pre>

    <p class="continue">
      <code>import *</code> is usually a bad idea:
      if someone adds a new function or variable to the next version of the module,
      your <code>import *</code> could silently overwrite something that you have written,
      or are importing from somewhere else.
      Bugs like this can be extremely hard to find,
      since nothing seemed to change in your program.
    </p>
  </div>

  <p>
    We now have everything we need to start drawing pictures.
    Let's start with a simple grid of pixels:
  </p>

<pre>
<span class="in">from ipythonblocks import BlockGrid
grid = BlockGrid(10, 5)
grid.show()</span>
FIXME: output
</pre>

  <p class="continue">
    The first line loads something called <code>BlockGrid</code>
    from the <code>ipythonblocks</code> library.
    <code>BlockGrid</code> isn't actually a function&mdash;it's something
    called a <a href="glossary.html#class">class</a> that we'll discuss later&mdash;but
    it works like one for present purposes.
    When we give it two integers,
    it creates a grid of blocks of the specified width and height.
    We can assign that to a variable
    (in this case, called <code>grid</code>),
    and then ask it to show itself.
  </p>

  <p>
    We can ask a grid what it's height and width are
    using the same dotted notation we use
    to ask a library for the things it contains:
  </p>

<pre>
<span class="in">print 'width:', grid.width
print 'height', grid.height</span>
<span class="out">width: 10
height: 5</span>
</pre>

  <p>
    We can't change these values, though:
  </p>

<pre>
<span class="in">grid.width = 100</span>
<span class="err">AttributeError                            Traceback (most recent call last)
&lt;ipython-input-21-38b1940fb9ea&gt; in &lt;module&gt;()
----&gt; 1 grid.width=100

AttributeError: can't set attribute</span>
</pre>

  <p class="continue">
    The reason is the same as the one given <a href="#a:add-num-str">earlier</a>:
    if we enlarged the grid,
    Python would have to guess what colors to use for the new blocks.
    We could tell it,
    but to do that,
    we need a way to define colors.
  </p>

  <p>
    Luckily,
    we have one&mdash;in fact, we have several.
    The most common,
    called "RGB",
    defines colors according to how much red, green, and blue they contain.
    This is an additive color model:
    the color we see is the sum of the individual color values,
    each of which can range between 0 and 255.
    Why 255?
    Because computer memory is organized into 8-bit bytes,
    and 255 (11111111 in base 2) is the largest integer that can be represented in one byte.
  </p>

  <p>
    In RGB,
    black is (0, 0, 0), i.e., nothing of any color.
    White is the maximum value of all three colors, or (255, 255, 255).
    We can think of this color model is as a cube
    (<a href="#f:color_cube">Figure XXX</a>).:
    the three axes represent the primary colors,
    while secondary colors are combinations of maximum values,
    and each actual color is a coordinate in this cube.
  </p>

  <figure id="f:color_cube">
    <img src="pymedia/color_cube.png" alt="A Color Cube" />
    <figcaption>Figure XXX: A Color Cube</figcaption>
  </figure>

  <p>
    The IPythonBlocks library includes a function called <code>show_color</code>
    that we can use to explore the RGB color cube:
  </p>

<pre>
<span class="in">from ipythonblocks import show_color
show_color(255, 0, 0)</span> <span class="comment"># all red</span>
FIXME: output
<span class="in">show_color(0, 255, 0)
show_color(0, 0, 255)</span>
FIXME: output
<span class="in">show_color(128, 255, 64)</span>
FIXME: output
</pre>

  <p>
    Let's change one corner of our grid from black to green:
  </p>

<pre>
<span class="in">grid[0, 0] = (0, 255, 0)
grid.show()</span>
FIXME: output
</pre>

  <p>
    There's a lot going on in that assignment statement:
  </p>

  <ol>
    <li>
      A color is one value,
      but we write it in three parts (red, green, and blue).
      To make it clear that we want those three parts grouped together,
      we put them in parentheses,
      as in <code>(0, 255, 0)</code>.
      This is <em>not</em> a function call,
      though parentheses are used for calling functions.
      Instead,
      this is called a <a href="glossary.html#tuple">tuple</a>.
      We'll see many more tuples as we go along.
    </li>
    <li>
      If we want to refer to a particular block in a grid,
      we use a <a href="glossary.html#subscript">subscript</a>
      or <a href="glossary.html#index">index</a>,
      just as we do when referring to a particular element of a matrix in mathematics.
      Since subscripts and superscripts are hard to type,
      we put the subscript values in square brackets
      instead of typesetting them.
    </li>
    <li id="a:count-from-zero">
      The corner's coordinates are (0, 0), not (1, 1).
      Programming languages derived from C (a family that includes Python and Perl) all count from 0,
      for the same reason that color values run from 0 to 255
      instead of 1 to 256.
      Some other languages (notably Fortran, MATLAB, and R) count from 1.
      The latter is more sensible&mdash;nobody says, "Zero, one, two, three, four," when counting their fingers&mdash;but
      we're stuck with the former for programming.
    </li>
  </ol>

  <p>
    Finally,
    look closely at which pixel turned green.
    A Cartesian grid is typically drawn with the origin in the lower left,
    or in the center,
    but IPythonBlocks' coordinate scheme is like that of tables and spreadsheets:
    the first index counts down the rows,
    while the second counts across the columns.
    To prove this,
    let's make the block at (1, 2) red:
  </p>

<pre>
<span class="in">grid[1, 2] = (255, 0, 0)
grid.show()</span>
FIXME: output
</pre>

  <p>
    Changing the color of one block isn't very useful, though:
    if we wanted to draw a picture that way,
    we'd have to write millions of assignment statements.
    What we need is a way to set the colors of many blocks at once,
    which is the subject of the next section.
  </p>

  <div class="challenges">
    <h3>Challenges</h3>
    <p class="fixme">write challenges</p>
  </div>

</section>

<section id="s:for">
  <h2>Repeating Things</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Repeat operations using a <code>for</code> loop.</li>
      <li>Trace the value of a loop variable.</li>
      <li>Use the <code>range</code> function to loop over a range of integers.</li>
    </ul>
  </div>

  <p>
    Computers are useful because they can do lots of calculations on lots of data,
    which means we need a concise way to represent multiple steps.
    Let's start by printing the vowels in order the hard way:
  </p>

<pre>
<span class="in">print 'a'
print 'e'
print 'i'
print 'o'
print 'u'</span>
<span class="out">a
e
i
o
u</span>
</pre>

  <p>
    Now let's do it the easy way:
  </p>

<pre>
<span class="in">for character in "aeiou":
    print character</span>
<span class="out">a
e
i
o
u</span>
</pre>

  <p>
    The keywords <code>for</code> and <code>in</code> are used to create
    a <a href="glossary.html#for-loop">for loop</a>.
    Just like a <a href="shell.html#loop">loop in the shell</a>,
    a <code>for</code> loop in Python repeats one or more instructions
    for each value in some collection.
    The indented line is called the <a href="glossary.html#loop-body">body</a> of the loop:
    it's what Python executes repeatedly.
    The variable <code>character</code> is the <a href="glossary.html#loop-variable">loop variable</a>:
    each time the loop is executed,
    it is updated to hold the next value from the collection
    (in this case,
    the next character from the string <code>"aeiou"</code>).
    There's nothing magical about its name:
    we could equally well have called it <code>something</code>,
    but using something meaningful makes the program more readable.
  </p>

  <p>
    Here's another loop that updates variables as it goes along:
  </p>

<pre>
<span class="in">result = ""
for character in "aeiou":
    result = result + 2 * character
print result</span>
<span class="out">aaeeiioouu</span>
</pre>

  <p>
    The variable <code>result</code> is initially assigned
    an <a href="glossary.html#empty-string">empty string</a>
    containing no characters.
    The first time the loop executes,
    the program adds "aa" to it;
    the second time,
    it adds "ee",
    and so on to produce the string shown.
  </p>

  <p>
    Notice that Python uses indentation to show what's in the body of a loop.
    In fact,
    it always uses indentation to show what lines of code belong to what.
    To see why this matters,
    try running this program:
  </p>

<pre>
<span class="in">result = ""
for character in "aeiou":
    result = result + 2 * character
<span class="highlight">    print result</span></span>
<span class="out">aa
aaee
aaeeii
aaeeiioo
aaeeiioouu</span>
</pre>

  <p class="continue">
    Since the <code>print</code> statement is inside the loop,
    it is executed once for each <a href="glossary.html#iteration">iteration</a> of the loop,
    so we see five lines of output.
  </p>

  <div class="box">

    <h3>Why Indentation?</h3>

    <p>
      Most other languages use keywords like <code>do</code> and <code>done</code>
      or <code>begin</code> and <code>end</code> to show what's in the body of a loop,
      or the curly braces '{' and '}'.
      Python uses indentation because studies done in the 1970s and 1980s showed
      that's what people actually pay attention to.
      If we write something as:
    </p>

<pre>
for value in data
begin
    print value
print "done"
end
</pre>

    <p class="continue">
      then most people reading the code in a hurry will "see"
      the second <code>print</code> statement as being outside the loop.
    </p>

  </div>

  <p>
    What if we want to do something a certain number of times,
    rather than once for each character in a string?
    Python has a built-in function called <code>range</code>
    that produces the integer 0, 1, 2, and so on up to a certain value:
  <p>

<pre>
<span class="in">for i in range(3):
    print i</span>
<span class="out">0
1
2</span>
</pre>

  <p>
    As discussed <a href="a:count-from-zero">earlier</a>,
    <code>range</code> starts counting at 0,
    not at 1.
    It therefore stops one number short of the argument it's given
    so that it produces the right number of values in total.
  </p>

  <p>
    Using loops,
    it's easy to color in many pixels with just a couple of lines of code:
  </p>

<pre>
<span class="in">grid = BlockGrid(10, 5)
for i in range(10):
    grid[0, i] = (255, 0, 0)
grid.show()</span>
FIXME: output
</pre>

  <p class="fixme">arguments are (X, Y), but coords are (Y, X)</p>

  <p>
    The first line of this little program creates a 10&times;5 grid.
    The next line is a loop that will run 10 times.
    Each time around,
    the next integer in the sequence 0&hellip;9 is assigned to the variable <code>i</code>.
    Inside the loop,
    we use <code>i</code> as the second (column) subscript to <code>grid</code>:
    the first time through the loop,
    we turn the block <code>grid[0, 0]</code> red,
    the next time the block <code>grid[0, 1]</code>,
    then <code>grid[0, 2]</code>
    and so on up to <code>grid[0, 9]</code>
    to fill in the entire row.
  </p>

  <div class="box">
    <h3>When Short Names Are OK</h3>

    <p>
      We said earlier that programs should use meaningful variable names.
      Are we not violating our own rule by using <code>i</code> as a variable in this program?
      The short answer is "yes", but it's a defensible violation.
      Suppose we re-write our loop as:
    </p>

<pre>
<span class="in">for column in range(10):
    grid[0, column] = (255, 0, 0)</span>
</pre>

    <p class="continue">
      The longer name is more meaningful,
      but it also takes longer to read.
      Since the original <code>i</code> is only used for a few lines,
      users will easily be able to keep its meaning in short-term memory
      as long as they need to.
      On balance,
      therefore,
      the short name are better in this case.
    </p>

    <p>
      This is actually a general principle in program design.
      A variable that holds a simple value,
      and is only used in a few adjacent lines of code,
      can (and usually should) have a short name.
      A variable that holds a complex value,
      or one which is used over more than a few lines of code,
      should have a longer name
      in order to optimize the tradeoff between reading speed
      and the limitations of human short-term memory.
    </p>
  </div>

  <p>
    What happens if we use index the grid in the wrong order,
    i.e.,
    run the row coordinate from 0 to 9?
  </p>

<pre>
<span class="in">for i in range(10):
    grid[<span class="highlight">i, 0</span>] = (255, 0, 0)
grid.show()</span>
<span class="err">IndexError                                Traceback (most recent call last)
&lt;ipython-input-36-3a81075e1fb2&gt; in &lt;module&gt;()
      1 for i in range(10):
----&gt; 2     grid[i, 0] = (255, 0, 0)
      3 grid.show()

IndexError: list index out of range</span>
</pre>

  <p>
    Python halts the program with an error because
    we eventually try to change the color of <code>grid[5, 0]</code>,
    which doesn't exist:
    row indices only go as high as 4,
    and trying to access a non-existent block is an error,
    just as trying to access a non-existent variable is.
  </p>

  <p>
    But Python doesn't notice this until we actually get there.
    If we display the grid now,
    we see:
  </p>

<pre>
FIXME: output
</pre>

  <p class="continue">
    which shows that the first five iterations of the loop ran
    before the error occurred.
  </p>

  <p>
    Here's a better way to write this loop:
  </p>

<pre>
<span class="in">for i in range(<span class="highlight">grid.height</span>):
    grid[i, 0] = (255, 0, 0)
grid.show()</span>
FIXME: output
</pre>

  <p>
    What makes this better is
    the change from using 5, 10, or any specific number in the <code>range</code> call
    to using <code>grid.height</code> instead.
    The grid knows how large it is;
    rather than relying on our memory
    (which is often faulty),
    we should rely on the computer's
    (which usually isn't).
    Doing this also makes the program more robust:
    if we come back later and change the grid size to 20&times;30,
    we don't have to re-read every line
    looking for 10's that ought to become 30's.
  </p>

  <div class="box">
    <h3>Don't Repeat Yourself</h3>
    <p>
      Every fact in a program should be represented once and only once,
      so that if the program needs to be changed,
      only one change,
      in one place,
      is needed.
      Putting it another way,
      if most changes to a program can be made
      by changing one thing in one place,
      that program is well designed.
    </p>
  </div>

  <p>
    What if we want to set the color of a sub-rectangle of our grid?
    For example,
    suppose we want to turn the nine pixels in the upper left corner blue.
    We could do this:
  </p>

<pre>
<span class="in">grid[0, 0] = (0, 0, 255)
grid[0, 1] = (0, 0, 255)
grid[0, 2] = (0, 0, 255)
grid[1, 0] = (0, 0, 255)
grid[1, 1] = (0, 0, 255)
grid[1, 2] = (0, 0, 255)
grid[2, 0] = (0, 0, 255)
grid[2, 1] = (0, 0, 255)
grid[2, 2] = (0, 0, 255)</span>
</pre>

  <p class="continue">
    but we already know that's a bad approach.
    We'd be better off using a loop for each row
    to cut our program from nine lines to six:
  </p>

<pre>
<span class="in">for i in range(3):
    grid[<span class="highlight">0</span>, i] = (0, 0, 255)
for i in range(3):
    grid[<span class="highlight">1</span>, i] = (0, 0, 255)
for i in range(3):
    grid[<span class="highlight">2</span>, i] = (0, 0, 255)</span>
</pre>

  <p>
    Look more closely:
    the only difference between the three loops is
    the row index used in each,
    and those indices go in sequence from 0 to 2.
    That means we can use another loop to produce them:
  </p>

<pre>
<span class="in">for row in range(3):
    for col in range(3):
        grid[row, col] = (255, 0, 0)</span>
grid.show()
FIXME: display
</pre>

  <p>
    This is called a <a href="glossary.html#nested-loop">nested loop</a>.
    Each time the <a href="glossary.html#outer-loop">outer loop</a> runs,
    the <a href="glossary.html#inner-loop">inner loop</a> runs three times,
    so that every possible combination of row and column index
    is seen exactly once.
    We get the same result if we turn the loops inside out
    and run over the columns;
    the only difference is the order in which blocks are colored in
    (<a href="#f:nested_loop">Figure XXX</a>).
  </p>

  <figure id="f:nested_loop">
    <img src="pymedia/nested_loop.png" alt="Nested Loops" />
    <figcaption>Figure XXX: Nested Loops</figcaption>
  </figure>

  <p>
    There are cases where the order of the loops matters.
    In the program below,
    the range of the inner loop depends on
    the current value of the outer loop's index:
  </p>

<pre>
<span class="in">grid = BlockGrid(10, 5)
for row in range(col):
    for col in range(5):
        grid[row, col] = (0, 255, 0)
grid.show()</span>
FIXME: output
</pre>

  <p class="continue">
    The first time around the outer loop,
    <code>col</code> is 0,
    so the inner loops doesn't run at all:
    <code>range(0)</code> counts from 0 up to <em>but not including</em> 0,
    so it produces no output.
    The second time around the outer loop,
    <code>col</code> is 0,
    so the inner loop runs once
    and turns <code>grid[1, 0]</code> green.
    The third time,
    <code>col</code> is 1,
    so the inner loop turns <code>grid[2, 0]</code> and <code>grid[2, 1]</code> green,
    and so on.
  </p>

  <p>
    Let's try inverting the loops:
  </p>

<pre>
<span class="in">for <span class="highlight">row</span> in range(5):
    for <span class="highlight">col</span> in range(<span class="highlight">row</span>):
        grid[row, col] = (0, 0, 255)
grid.show()</span>
FIXME: output
</pre>

  <p class="continue">
    <a href="#f:diagonal_loops">Figure XXX</a> shows the order in which
    these nested loops turn cells blue.
    To fill in the cells between the two triangles,
    we can use a single loop like this:
  </p>

<pre>
<span class="in">for diagonal in range(5):
    grid[diagonal, diagonal] = (0, 255, 255)
grid.show()</span>
FIXME: output
</pre>

  <p>
    This program works,
    but it violates our rules about
    making programs readable
    and not repeating information.
    More specifically,
    the number 5 shows up in several places,
    and tuples like (0, 255, 255) aren't exactly meaningful.
    Here's how we should write it instead:
  </p>

<pre>
<span class="in">from ipythonblocks import BlockGrid, colors
grid = BlockGrid(10, 5)
for col in range(grid.height):
    for row in range(col):
        grid[row, col] = colors['Blue']
for row in range(grid.height):
    for col in range(row):
        grid[row, col] = colors['Green']
for diagonal in range(grid.height):
    grid[diagonal, diagonal] = colors['Aqua']
grid.show()</span>
FIXME: output
</pre>

  <p>
    <code>colors</code> defines roughly 140 standard colors
    so that we can use them by name:
    for example,
    <code>colors['Yellow']</code> is the tuple <code>(255, 255, 0)</code>.
    Our loop ranges use <code>grid.height</code>,
    so if we decide to make our grid 20&times;20,
    all we will need to change is the second line of the program,
    and everything else will work.
  </p>

  <div class="challenges">
    <h3>Challenges</h3>
    <p class="fixme">write challenges</p>
  </div>

</section>

<section id="s:index">
  <h2>Indexing, Slicing, and Update Operators</h2>

  <p>
    A <code>for</code> loop is one way to tell the computer to do something many times.
    Another is to tell it where to do things,
    and let it figure out how best to take action.
  </p>

  <p>
    To see how this works,
    let's first revisit indexing.
    We have seen that <code>grid[0, 1]</code> refers to a single block in a grid.
    Many other things in Python can be indexed as well,
    such as strings:
  </p>

<pre>
<span class="in">print "Darwin"[2]</span>
<span class="out">r</span>
</pre>

  <p class="continue">
    and lists:
  </p>

<pre>
<span class="in">names = ["Newton", "Darwin", "Turing"]
print names[1]</span>
<span class="out">Darwin</span>
</pre>

  <p>
    Here's something that <em>doesn't</em> work:
  </p>

<pre>
<span class="in">print names[999]</span>
<span class="err">IndexError                                Traceback (most recent call last)
&lt;ipython-input-6-7359c12a3ca3&gt; in &lt;module&gt;()
      1 names = ["Newton", "Darwin", "Turing"]
----&gt; 2 print names[999]

IndexError: list index out of range</span>
</pre>

  <p>
    The list <code>names</code> only has three entries,
    so <code>names[999]</code> doesn't exist.
    Rather than giving us some default value (such as zero)
    or extending the list and filling in the new values with a default,
    Python considers this an error.
    The reasoning is the same as that given <a href="#a:creating-variables">earlier</a>:
    if we haven't defined a value,
    our program shouldn't guess what we might have wanted.
  </p>

  <p>
    Given that,
    you might be surprised to learn that
    Python actually lets use use negative indices:
  </p>

<pre>
<span class="in">print names[-1]</span>
<span class="out">Turing</span>
</pre>

  <p>
    As <a href="#f:negative_indexing">Figure XXX</a> shows,
    these count backwards from the end of the list or string.
    They're not actually necessary:
    if we want to get the last element of
    the list or string referred to by the variable <code>thing</code>,
    we can always write:
  </p>

<pre>
thing[len(thing) - 1]
</pre>

  <p class="continue">
    However,
    this is harder both to type and to read.
  </p>

  <figure id="f:negative_indexing">
    <img src="pymedia/negative_indexing.png" alt="Negative Indexing" />
    <figcaption>Figure XXX: Negative Indexing</figcaption>
  </figure>

  <p>
    All of the indices we have seen so far have specified single items,
    but that doesn't have to be the case.
    We can instead specify ranges of values,
    also called a <a href="glossary.html#slice">slice</a>:
  </p>

<pre>
<span class="in">name = "Alan Turing"
print name[3:8]</span>
<span class="out">Tur</span>
<span class="in">print name[5:5]</span>
<span class="out"></span>
<span class="in">print name[5:2]</span>
<span class="out"></span>
<span class="in">print name[5:999]</span>
<span class="out">Turing</span>
<span class="in">print name[5:-1]</span>
<span class="out">Turin</span>
<span class="in">print name[1:-1]</span>
<span class="out">lan Turin</span>
<span class="in">print name[:6]</span>
<span class="out">Alan T</span>
<span class="in">print name[6:]</span>
<span class="out">uring</span>
<span class="in">print name[:]</span>
<span class="out">Alan Turing</span>
</pre>

  <p>
    Slices are written as <code>[<em>lower</em>:<em>upper</em>]</code>.
    Python interprets them according to the following rules:
  </p>

  <ul>
    <li>
      A slice runs from its lower bound up to, but not including, its upper bound,
      so that the total number of elements selected is upper-lower.
      (In mathematical terms,
      a slice is either "half open" or "half closed".)
    </li>
    <li>
      This means that a slice whose lower and upper bounds are the same,
      like <code>[5:5]</code>,
      selects nothing.
      It also means that if the upper bound is less than the lower bound,
      as in <code>[5:2]</code>,
      nothing is selected as well.
    </li>
    <li>
      Slices are more lenient than single indices:
      if one of the bounds is out of range,
      it is treated as being 0 or the length of the object,
      so that <code>name[5:999]</code> is legal
      even when there are only 11 characters in <code>name</code>.
      Some of us think this inconsistency is a bug;
      others think it is a useful feature.
    </li>
    <li>
      Negative indices count backward as always,
      so <code>name[5:-1]</code> goes from the fifth character
      up to, but not including,
      the last character.
    </li>
    <li>
      As a result,
      <code>thing[1:-1]</code> is everything in <code>thing</code>
      except the first and last element.
      This is often useful in scientific programming
      when we want to select the interior of a range of values.
    </li>
    <li>
      If we omit the lower bound, it defaults to 0;
      if we omit the upper, it defaults to the length of the thing we're slicing.
      Thus,
      <code>name[:6]</code> is the same as <code>name[0:6]</code>
      and <code>name[6:]</code> is the same as <code>name[6:len(name)]</code>.
    </li>
    <li>
      So by extension,
      if we omit both bounds,
      we simply select the entire thing.
    </li>
  </ul>

  <p>
    Slices work in two dimensions as well as one.
    To see this,
    let's create a grid and then change the color of the upper left corner:
  </p>

<pre>
<span class="in">grid = BlockGrid(5, 5)
grid[0:3, 0:3] = (255, 0, 128)
grid.show()</span>
FIXME: display
</pre>

  <p class="continue">
    As this example shows,
    the slices in each dimension are combined to select a range of elements.
    Assigning to that range then changes the color of all those elements at once.
  </p>

  <p>
    Exactly what happens when we assign to a slice
    depends on the type of thing we're slicing.
    For example,
    if we assign to a slice of a list,
    we replace the values in that range
    with a new sequence of values
    (<a href="#f:slice_assign_1">Figure XXX</a>):
  </p>

<pre>
<span class="in">elements = ['H', 'He', 'Li', 'Be', 'Bo', 'C', 'N']
elements[1:-1] = ['Na', 'Mg']
print elements</span>
<span class="out">['H', 'Na', 'Mg', 'N']</span>
</pre>

  <figure id="f:slice_assign_1">
    <img src="pymedia/slice_assign_1.png" alt="Assigning to Slices" />
    <figcaption>Figure XXX: Assigning to Slices</figcaption>
  </figure>

  <p>
    By default,
    a slice selects every value between its bounds.
    We can optionally provide a <a href="glossary.html#stride">stride</a>
    to select regularly-spaced elements instead:
  </p>

<pre>
<span class="in">grid = BlockGrid(8, 5)
grid = (255, 128, 0) <span class="comment"># Turn all elements orange.</span>
grid[0:8:3, :] = (0, 128, 255) <span class="comment"># Turn every third row blue.</span>
grid[:, ::2] = (255, 0, 128) <span class="comment"># Then turn every second column pink.</span>
grid.show()</span>
FIXME: display
</pre>

  <p>
    Slicing is an example of <a href="glossary.html#declarative-programming">declarative programming</a>.
    Instead of telling the computer <em>how</em> to do something,
    we tell it <em>what</em> to do,
    and let it figure out what steps to take to achieve that goal.
    Behind the scenes,
    the computer might use a <code>for</code> loop to re-color each block in the grid.
    It might also use some of the advanced features of the CPU
    to change several blocks simultaneously,
    or distribute the work between different CPUs if we have a powerful enough machine.
    We don't need to know:
    we just need to know that the right thing will happen,
    and that we can spend our time worrying about more important things.
  </p>

  <div class="challenges">
    <h2>Challenges</h2>

    <ol>
      <li>
        Explain why these three lines of code produce the output shown.
<pre>
<span class="in">elements = ['H', 'He', 'Li', 'Be', 'Bo', 'C', 'N']
elements[1:-1] = 'Xe'
print elements</span>
<span class="out">['H', 'X', 'e', 'N']</span>
</pre>
      </li>
    </ol>

  </div>

</section>

<section id="s:logic">

  <h2>Making Choices</h2>

  <div class="understand" id="u:logic">
    <h3>Understand:</h3>
    <ul>
      <li>How to choose what statements to execute using conditionals.</li>
      <li>How to combine conditional tests.</li>
      <li>What an in-place operator is.</li>
    </ul>
  </div>

  <p>
    Using the <code>min</code> function is one way to clip values.
    Another is to use a <a href="glossary.html#conditional">conditional</a> statement.
    Let's start with a simple example:
  </p>

<pre>
if 5 &gt; 0:
    print '5 is greater than 0'

if 5 &lt; 0:
    print '5 is less than 0'
</pre>

  <p>
    When we run this program,
    it prints:
  </p>

<pre>
<span class="out">5 is greater than 0</span>
</pre>

  <p class="continue">
    The logic is fairly easy to follow.
    The keyword <code>if</code> is followed by an expression.
    If that expression is true,
    Python executes the indented block of code,
    but if the expression is false,
    it doesn't.
    In this case,
    since 5 actually is greater than 0,
    the first <code>print</code> statement is run,
    but not the second.
  </p>

  <p>
    Now let's try this:
  </p>

<pre>
for char in 'GATTACA':
    if char == 'A':
        print 'found an A'
<span class="out">found an A
found an A
found an A</span>
</pre>

  <p>
    Python uses a double equals sign '==' to test for equality
    (because the single equals sign '=' is used for assignment).
    Each time through the loop above,
    it compares the current value of <code>char</code> to the character 'A'.
    When the two are equal,
    it prints a message;
    since the letter appears three times in 'GATTACA',
    the message is printed three times.
  </p>

  <p>
    All right,
    how about this?

<pre>
VOWELS = 'AEIOU'
num_vowels = 0
num_other = 0
for char in 'GATTACA':
    if char in VOWELS:
        num_vowels = num_vowels + 1
    else:
        num_other = num_other + 1
print num_vowels, 'vowels'
print num_other, 'other characters'
<span class="out">3 vowels
4 other characters</span>
</pre>

  <p>
    This little program introduces two new language features.
    The first is the <code>in</code> operator,
    which,
    as its name suggests,
    tests whether one value is in another.
    In this case,
    we're using it to see if the current character is in our list of vowels.
  </p>

  <p>
    The other feature is the keyword <code>else</code>,
    which is used to introduce an alternative to an <code>if</code>.
    Here,
    if a character is a vowel,
    Python increments <code>num_vowels</code>.
    If that test fails&mdash;i.e., if the character <em>isn't</em> in <code>VOWELS</code>&mdash;Python
    executes the both of the <code>else</code>
    and increments <code>num_other</code> instead.
  </p>

  <p>
    We can make this program a bit more readable by writing the body of the loop like this:
  </p>

<pre>
for char in 'GATTACA':
    if char in VOWELS:
        <span class="highlight">num_vowels += 1</span>
    else:
        <span class="highlight">num_other += 1</span>
</pre>

  <p>
    The notation <code>x += 1</code> means, "Add one to the variable <code>x</code>."
    This is called an <a href="glossary.html#in-place-operator">in-place operator</a>;
    we can similarly use <code>x += 5</code> to add 5 to <code>x</code>,
    <code>x *= 3</code> to triple it,
    and so on.
    It may seem like a small saving,
    but it actually prevents a lot of bugs
    by eliminating duplicated code.
  </p>

  <p>
    With conditionals in hand,
    let's go back and rewrite our reddening program:
  </p>

<pre>
picture = novice.open('mac.jpg')
for pixel in picture:
    if pixel.red &lt; 128:
        pixel.red *= 2
    else:
        pixel.red = 255
</pre>

</section>

<section id="s:openshow">
  <h2>Displaying Images</h2>

<pre>
<span class="in">from skimage import novice</span>
<span class="in">flower = novice.open('flower.jpg')</span>
<span class="in">flower.show()</span>
</pre>

  <p>
    This three-line program introduces one new idea per line.
    The first statement asks Python to find a library called <code>skimage</code>
    (the SciKit image processing library)
    and load something called <code>novice</code> from it.
    The second statement asks <code>novice</code> to open a file called <code>flower.jpg</code>;
    the result of that operation is assigned to a variable called <code>flower</code>.
    The final statement asks the thing <code>flower</code> now points at to display itself.
    If all has gone well,
    this should show a picture of the world's cutest child
    (<a href="#f:flower">Figure XXX</a>).
  </p>

  <figure id="f:flower">
    <img src="pymedia/flower.jpg" alt="The World's Cutest Child" />
  </figure>

  <p>
    A <a href="glossary.html#library">library</a>
    (or <a href="glossary.html#module">module</a>&mdash;for our purposes, the terms mean the same thing)
    is one of the most important ideas in all of programming.
    No language could possibly contain every single feature that everyone might ever want.
    Even if it did,
    people's needs evolve over time,
    so an "all inclusive" approach would mean constantly releasing new versions of the language.
    Instead,
    every programming language provides a way for people to define new tools themselves,
    and then load those tools into other programs.
    In this case,
    someone wrote an image processing library called <code>skimage</code>,
    and someone else (a graduate student named Mike Hansen)
    added a sub-library to it called <code>novice</code>
    to provide an easy-to-use interface for people who are just learning to program.
    When we write:
  </p>

<pre>
from skimage import novice
</pre>

  <p class="continue">
    we are asking Python to find the <code>skimage</code> library,
    search inside it for <code>novice</code>,
    and load that into memory for use.
  </p>

  <p>
    To get at the things <code>novice</code> contains,
    we then refer to them as <code>novice.<em>something</em></code>.
    This <a href="glossary.html#dotted-notation">dotted notation</a> was invented
    to deal with the fact that people often choose the same names for different things.
    For example,
    <code>skimage.novice</code>'s <code>open</code> looks for a file on disk and opens that,
    but another library called <code>web</code> might provide something called <code>open</code>
    that opened a connection to a web site.
    Using <code>thing.subthing.subsubthing</code> to name things
    is exactly like using the genus and species names to identify particular organisms.
  </p>

  <div class="box">

    <h3>There's More Than One Way to Name It</h3>

    <p>
      You may have noticed above that we referred to <code>novice</code> as <code>skimage.novice</code>.
      If we want to do this in our program,
      we could rewrite it as:
    </p>

<pre>
import skimage
flower = skimage.novice.open('flower.jpg')
flower.show()
</pre>

    <p class="continue">
      which performs exactly the same operations as the original.
      What we <em>can't</em> do is:
    </p>

<pre>
import skimage
flower = novice.open('flower.jpg')
</pre>

    <p class="continue">
      or:
    </p>

<pre>
from skimage import novice
flower = skimage.novice.open('flower.jpg')
</pre>

    <p class="continue">
      The first (<code>import skimage</code>) doesn't define anything in our program called <code>novice</code>;
      it only defines <code>skimage</code>.
      The second does the reverse:
      it defines <code>novice</code> <em>without</em> defining <code>skimage</code>.
    </p>

    <p>
      And yes,
      we could do this:
    </p>

<pre>
from skimage.novice import open
flower = open('flower.jpg')
</pre>

    <p class="continue">
      but it would be a very bad idea.
      Python actually has a built-in function called <code>open</code>
      that opens arbitrary files so that the bytes in them can be read.
      If we run the code shown immediately above,
      that built-in function will be replaced by
      <code>skimage.novice</code>'s <code>open</code>,
      which will probably break most programs
      (since most files aren't actually images).
    </p>

  </div>

  <p>
    With that out of the way,
    the second statement in:
  </p>

<pre>
from skimage import novice
<span class="highlight">flower = novice.open('flower.jpg')</span>
flower.show()
</pre>

  <p class="continue">
    should be pretty easy to understand.
    It's a function call:
    it just happens that the function being called is contained in the <code>novice</code> library.
    Similarly,
    the expression <code>flower.show()</code> is another call
    that asks whatever the variable <code>flower</code> points at
    to call the <code>show</code> function it contains.
  </p>

  <p>
    Another way to think about this program is shown in <a href="#f:memory_model_image_display">Figure XXX</a>.
    After the first statement,
    Python has created a variable called <code>novice</code>
    that refers to <code>skimage</code>'s <code>novice</code> module.
    After the second statement,
    that module has loaded bytes from an image file on disk into memory,
    wrapped an object around them,
    and creatd a variable called <code>flower</code> to refer to that object.
  </p>

  <figure id="f:memory_model_image_display">
    <img src="pymedia/memory_model_image_display.jpg" alt="Memory Model of Image Display Program" />
  </figure>

  <div class="keypoints" id="k:openshow">
    <h3>Summary</h3>
    <ul>
      <li class="fixme">Write summary</li>
      <li class="fixme">Explain scope of imports: program session</li>
    </ul>
  </div>

</section>

<section id="s:program">
  <h2>Creating Programs</h2>

  <div class="understand" id="u:program">
    <h3>Understand:</h3>
    <ul>
      <li>How to create and run programs.</li>
    </ul>
  </div>

  <p>
    Typing in commands over and over again is tedious and error-prone.
    Just as we saved shell commands in <a href="shell.html#s:scripts">shell scripts</a>,
    we can save Python commands in files
    and then have the Python interpreter run those.
    Using your favorite text editor,
    put the following three lines into a plain text file:
  </p>

<pre src="src/python/greeting.py">
left = "hello"
right = "there"
print left, right
</pre>

  <p class="continue">
    and then save it as <code>greeting.py</code>.
    (By convention,
    Python files end in '.py'
    rather than '.txt'.)
    To run it from the shell,
    type:
  </p>

<pre>
$ <span class="in">python greeting.py</span>
<span class="out">hello there</span>
</pre>

  <p>
    Of course,
    we can do this with our image display program as well:
  </p>

<pre>
import skimage
flower = skimage.novice.open('flower.jpg')
flower.show()
</pre>

  <p>
    When we save this as <code>showflower.py</code>,
    and run it as:
  </p>

<pre>
$ <span class="in">python showflower.py</span>
</pre>

  <p class="continue">
    it displays our picture.
    <span class="fixme">explain how to kill it</span>
  </p>

  <p>
    When the Python interpreter executes a file,
    it runs the commands in that file
    just as if they had been typed in interactively.
    It doesn't wait until the whole file has been read
    to start executing;
    instead,
    as the example below shows,
    it runs each command as soon as it can:
  </p>

    <!-- JK: I think what was intended here was for the first 3 lines to 
         replace the existing 3 lines in greeting.py, then 'python greeting.py' 
         was to be run from the shell? If so, having the first 3 new lines in a 
         separate blue box might be more clear. Also, the text below currently
         references a.py. -->

<pre src="src/python/executing_file.py">
print "before"
1/0
print "after"
<span class="out">before</span>
<span class="err">Traceback (most recent call last):
  File "a.py", line 2, in &lt;module&gt;
    1/0
ZeroDivisionError: integer division or modulo by zero</span>
</pre>

  <p class="continue">
    Note that this can lead to some confusing output.
    For example,
    if we change the example above to:
  </p>

<pre>
print "before", 1/0, "after"
</pre>

  <p class="continue">
    then the output is:
  </p>

<pre><span class="out">before</span>
<span class="err">Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ZeroDivisionError: integer division or modulo by zero</span>
</pre>

  <div class="keypoints" id="k:program">
    <h3>Summary</h3>
    <ul>
      <li>Store programs in files whose names end in <code>.py</code>.</li>
      <li>Run programs using <code>python <em>name.py</em></code>.</li>
    </ul>
  </div>

</section>

<section id="s:properties">
  <h2>Image Properties</h2>

  <div class="understand" id="u:properties">
    <h3>Understand:</h3>
    <ul>
      <li>How to inspect and modify the properties of images.</li>
      <li>How to save images to files.</li>
    </ul>
  </div>

  <p>
    Let's take another look at the world's cutest child:
  </p>

<pre>
<span class="in">from skimage import novice</span>
<span class="in">flower = novice.open('flower.jpg')</span>
<span class="in">flower.show()</span>
</pre>

  <p class="continue">
    What else can we do besides display this image?
  </p>

<pre>
<span class="in">print flower.format</span>
<span class="out">JPEG</span>
<span class="in">print flower.path</span>
<span class="out">/home/gvwilson/examples/flower.jpg</span>
<span class="in">print flower.height</span>
<span class="out">180</span>
<span class="in">print flower.width</span>
<span class="out">240</span>
</pre>

  <p>
    As this example shows,
    a picture object has <a href="glossary.html#property">properties</a>:
    its format (JPEG, PNG, and so on),
    the path to the file it was loaded from,
    and its height and width in pixels.
    Some of these are unchangeable,
    so that we can confuse our program
    by fooling it into thinking that a JPEG image is actually stored as a PNG,
    or that it was loaded from a different file than it actually was:
  </p>

<pre>
<span class="in">flower.format = 'PNG'</span>
<span class="err">Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: can't set attribute</span>
<span class="in">flower.path = '/profiles/alan-turing.jpg'</span>
<span class="err">Traceback (most recent call last):
  File "&lt;stdin&gt;", line 2, in &lt;module&gt;
AttributeError: can't set attribute</span>
</pre>

  <p>
    Others,
    however,
    are changeable.
    For example,
    we can squish the image by altering its height
    (<a href="#f:flower_squished">Figure XXX</a>).
  </p>

<pre>
<span class="in">flower.height = 90</span>
<span class="in">flower.show()</span>
</pre>

  <figure id="f:flower_squished">
    <img src="pymedia/flower_squished.jpg" alt="Squishing a Picture" />
  </figure>

  <p>
    We can now save this picture to a new file if we want:
  </p>

<pre>
<span class="in">flower.save('squished.jpg')</span>
</pre>

  <p>
    When we do this,
    the object's <code>path</code> property is automatically updated
    to reflect its new location:
  </p>

<pre>
<span class="in">print flower.path</span>
<span class="out">/home/gvwilson/examples/squished.jpg</span>
</pre>

  <p>
    And if we want to change its format,
    we can do that by saving it to a file with the appropriate suffix:
  </p>

<pre>
<span class="in">flower.save('squished.<span class="highlight">png</span>')</span>
<span class="in">print flower.path</span>
<span class="out">/home/gvwilson/examples/squished.png</span>
</pre>

  <p>
    Now,
    suppose we want to create a thumbnail of a picture to put on a web page.
    We want the thumbnail to be exactly 30 pixels wide to fit into a table,
    and we want its height scaled proportionally.
    Here's what we could do:
  </p>

<pre>
from skimage import novice
picture = novice.open('mac.jpg')
new_height = picture.height * 30 / picture.width
picture.height = new_height
picture.width = 30
picture.save('thumb-mac.jpg')
</pre>

</section>

<section id="s:pixels">
  <h2>Manipulating Pixels</h2>

  <p>
    Changing the color of the entire image at once is useful for creating backgrounds,
    but most pictures have more detail than that.
    If we want to change the color of a single pixel,
    we need a way to refer to it.
    In Python and most other languages,
    we do that by providing an <a href="glossary.html#index">index</a>,
    which is just the coordinates of the pixel we want to access.
    To create a red image with a single white pixel in the lower-left corner,
    we would do this:
  </p>

<pre>
from skimage import novice
block = novice.new((10, 10), (255, 0, 0))
block[0, 0] = (255, 255, 255)
block.show()
</pre>

  <p>
    The first thing to notice about this example is that the lower-left corner is at (0, 0),
    not at (1, 1).
    Programming languages derived from C (which includes C++, Java, Python, Perl, and Ruby)
    count from 0:
    the first five indices into anything are 0, 1, 2, 3, and 4.
    Some other languages (notably Fortran, MATLAB, and R) count from 1.
    The latter is more sensible&mdash;nobody says, "Zero, one, two, three, four," when counting their fingers&mdash;but
    we're stuck with the former for programming.
  </p>

  <p>
    The second thing to notice about this example is that a 10&times;10 image is hard to see,
    and a single white pixel is almost invisible.
    Let's try this:
  </p>

<pre>
from skimage import novice
block = novice.new((10, 10), (255, 0, 0))
block[0, 0] = (255, 255, 255)
<span class="highlight">block.inflation = 10</span>
block.show()
</pre>

  <p>
    An image's <code>inflation</code> property tells the library how large to make each pixel
    when displaying or saving the image.
    This doesn't change how many pixels there actually are,
    or how they're indexed;
    it's purely a convenience to help us see what we're doing.
  </p>

  <p>
    What if we want to make the upper-right pixel white instead?
    We happen to know that our image is 10&times;10,
    so we could do this:
  </p>

<pre>
block[9, 9] = (255, 255, 255)
</pre>

  <p class="continue">
    The upper-right index is (9, 9) because we're counting from 0:
    if the image is ten pixels across,
    its X coordinates are 0..9.
    This works in this specific case,
    but it's a bad long-term solution:
    if someone changes the size of the image,
    the upper-right pixel probably won't be at (9, 9) any longer,
    and we don't want to have to check our program line-by-line to find things like this.
  </p>

  <p>
    Here's one better solution:
  </p>

<pre>
block_width = 10
block_height = 10
block = novice.new((block_width, block_height), (255, 0, 0))
block[block_width - 1, block_height - 1] = (255, 255, 255)
</pre>

  <p>
    If someone changes the block's height or width now,
    the index expression in the last line will automatically adjust.
    This version of the program also makes the image's size a lot easier to find:
    instead of being buried inside a function call,
    <code>block</code>'s height and width are identified by name.
  </p>

  <p>
    We can improve this program even further like this:
  </p>

<pre>
block_width = 10
block_height = 10
<span class="highlight">red = (255, 0, 0)
white = (255, 255, 255)</span>
block = novice.new((block_width, block_height), <span class="highlight">red</span>)
block[block_width - 1, block_height - 1] = <span class="highlight">white</span>
</pre>

  <p class="continue">
    and then go one step further like this:
  </p>

<pre>
block_width = 10
block_height = 10
red = (255, 0, 0)
white = (255, 255, 255)
block = novice.new((block_width, block_height), red)
block[<span class="highlight">-1, -1</span>] = white
</pre>

  <p>
    Unlike most languages,
    Python is happy with negative indices:
    it uses them to count backward from the ends of things,
    rather than forward from the start
    (<a href="#f:negative_indices">Figure XXX</a>).
    Once you get used to it,
    it makes programs much easier to read&mdash;as the examples above show,
    the <code>-1</code> can be easy to miss when it's tacked onto the end of a long expression.
  </p>

  <figure id="f:negative_indices">
    <img src="pymedia/negative_indices.png" alt="Negative Indices" />
  </figure>

  <p>
    Now,
    what if we want to put a white border around our image?
    We could do this:
  </p>

<pre>
block[0, 0] = white
block[0, 1] = white
block[0, 2] = white
...
block[0, 9] = white
</pre>

  <p class="continue">
    and then repeat it for the other three sides
    but that would be a lot of work to type in,
    we'd probably make mistakes along the way,
    and if the image size changes,
    we'll have to add or remove dozens or hundreds of lines.
    Here's a better way:
  </p>

<pre>
block[0, :]  = white
block[-1, :] = white
block[:, 0]  = white
block[:, -1] = white
</pre>

  <p>
    As you can probably guess,
    ':' on its own means "all indices"&mdash;it's a <a href="shell.html#pipefilter">wildcard</a>,
    just like '*' in filenames in the shell.
    Behind the scenes,
    the computer is still executing something like our original code&mdash;after all,
    each of the pixels on the border does need to be modified somehow&mdash;but:
  </p>

  <ol>
    <li>
      this code is much faster to write,
    </li>
    <li>
      much more likely to be correct,
      and
    </li>
    <li>
      once the computer knows it's supposed to update all the pixels in a row or column,
      it can probably do it faster than we could by hand.
    <li>
  </ol>

  <p>
    ':' on its own is actually a special case of something much more general
    called a <a href="glossary.html#slice">slice</a>.
    Let's modify the program like this:
  </p>

<pre>
from skimage import novice
block_width = 200
block_height = 200
green = (0, 255, 0)
white = (255, 255, 255)
block = novice.new((block_width, block_height), green)
block[<span class="highlight">0:40, 0:40</span>] = white
</pre>

  <p class="continue">
    When we display the image that this program creates,
    it is a single white tile in the lower-left of a green background
    (<a href="#f:single_tile">Figure XXX</a>):
  </p>

  <figure id="f:single_tile">
    <img src="pymedia/single_tile.png" alt="A Single Tile" />
  </figure>

  <p>
    You can probably guess that the expression <code>0:40</code> refers to
    a range of pixels.
    What you might not guess is that the range goes from index 0 to index 39 inclusive,
    i.e.,
    from the lower limit up to, but not including, the upper limit.
    It may seem odd not to include the upper limit;
    the usual justifications are:
  </p>

  <ol>
    <li>
      When the ranges <code>lower:middle</code> and <code>middle:upper</code> are joined together,
      the pixel at coordinate <code>middle</code> is only included once.
    </li>
    <li>
      If the axis in question has <code>length</code> pixels,
      the expression <code>0:length</code> refers to each pixel exactly once.
    </li>
  </ol>

</section>

<section id="s:argv">

  <h2>Command-Line Arguments</h2>

  <div class="understand" id="u:argv">
    <h3>Understand:</h3>
    <ul>
      <li>How to work with command-line arguments.</li>
      <li>That slicing works in many places.</li>
    </ul>
  </div>

  <p>
    Let's go back to our thumbnail creation program for a moment.
    It would be much more useful if we could create a thumbnail of any image we wanted
    without having to edit the program each time to change the name of the file.
    What we want is something like this:
  </p>

<pre>
$ <span class="in">ls *.jpg</span>
<span class="out">mac.jpg</span>
$ <span class="in">python thumbnail mac.jpg</span>
$ <span class="in">ls *.jpg</span>
<span class="out">mac.jpg    thumb-mac.jpg</span>
</pre>

  <p>
    To make this work,
    we need a way to get filenames from the command line into our program.
    To do that,
    we need to use another library called <code>sys</code>
    (short for "system").
    It defines constants to tell us what version of Python we're using,
    what operating system we're running on,
    and so on:
  </p>

<pre>
<span class="in">import sys</span>
<span class="in">print sys.version</span>
<span class="out">2.7 (r27:82525, Jul  4 2010, 09:01:59) [MSC v.1500 32 bit (Intel)]</span>
<span class="in">print sys.platform</span>
<span class="out">win32</span>
</pre>

  <p>
    The most commonly-used element of <code>sys</code>, though, is <code>sys.argv</code>,
    which holds the <a href="glossary.html#command-line-arguments">command-line arguments</a>
    used to run the program.
    These are accessed using indices,
    just like individual pixels;
    the biggest differences are that
    <code>sys.argv</code> is one-dimensional instead of two-dimensional,
    and that its values are strings rather than pixels.
    The name of the script itself is in <code>sys.argv[0]</code>;
    all the other arguments are put in <code>sys.argv[1]</code>, <code>sys.argv[2]</code>, and so on.
    For example, here's a program that does nothing except
    print its first three command-line arguments:
  </p>

<pre>
import sys
print 'location 0:', sys.argv[0]
print 'location 1:', sys.argv[1]
print 'location 2:', sys.argv[2]
</pre>

  <p>
    If we run save this code in a file called <code>three.py</code>,
    and run it like this:
  </p>

<pre>
$ <span class="in">python three.py alpha beta</span>
</pre>

  <p class="continue">
    it prints:
  </p>

<pre>
<span class="out">location 0: three.py
location 1: alpha
location 2: beta</span>
</pre>

  <p>
    However,
    if we run it with no arguments,
    or only one,
    we get this:
  </p>

<pre>
$ <span class="in">python three.py</span>
<span class="out">location 0: /Users/gwilson/three.py
location 1:</span>
<span class="err">Traceback (most recent call last):
  File "/Users/gwilson/three.py", line 3, in &lt;module&gt;
    print 'location 1:', sys.argv[1]
IndexError: list index out of range</span>
</pre>

  <p>
    The problem is that <code>sys.argv[1]</code> doesn't exist,
    and Python won't let us read a value that isn't there.
    It's exactly like the undefined variables we encountered at the start of this chapter.
  </p>

  <p>
    Let's ignore that problem for now
    and go back to our thumbnail creator.
    Here's how we can make it work for an arbitrary file:
  </p>

<pre>
import sys
from skimage import novice

FIXED_WIDTH = 30

filename = sys.argv[1]
picture = novice.open(filename)
new_height = picture.height * fixed_width / picture.width
picture.height = new_height
picture.width = fixed_width
picture.save('thumb-' + filename)
</pre>

  <p>
    Let's walk through it piece by piece:
  </p>

  <ul>
    <li>
      We start by importing the libraries we need.
      <code>import</code> statements can actually be anywhere in the program,
      but it's considered good style to put them at the top,
      as it makes it easy for people to see what the program depends on.
    </li>
    <li>
      We give the fixed width we want thumbnails to have a name,
      so that we don't have to scatter the number 30 throughout the program.
      Values that are meant to be constants are usually written in UPPER CASE;
      again,
      it's not a requirement,
      but it's what most people do,
      so by sticking to this convention you will make it easier for other people to understand your code.
    </li>
    <li>
      The name of the image to be thumbnailed is supposed to be the program's single command-line argument,
      which means it will be in <code>sys.argv[1]</code>.
      (Remember, the program's name is in <code>sys.argv[0]</code>.)
      We could just use <code>sys.argv[1]</code> everywhere,
      but assigning the value to the variable <code>filename</code> makes our program easier to follow.
    </li>
    <li>
      We calculate the picture's new size
      and resize the picture as before.
    </li>
    <li>
      Finally,
      we create the new filename by concatenating <code>'thumb-'</code> and the original filename,
      and save the thumbnail to that file.
    </li>
  </ul>

</section>

<section id="s:lists">

  <h2>Lists</h2>

  <div class="understand" id="u:lists">
    <h3>Understand:</h3>
    <ul>
      <li>How to store many related values in a list.</li>
      <li>How to use a loop to operate on the values in a list.</li>
      <li>That programs should be tested on small, simple cases.</li>
    </ul>
  </div>

  <p>
    It's time to double back and have a closer look at <code>sys.argv</code>.
    It's obviously not an image;
    instead,
    it's a <a href="glossary.html#list">list</a>.
    To start our exploration of lists,
    let's run an interpreter and try this:
  </p>

<pre src="src/python/sum_values.py">
<span class="in">data = [1, 3, 5]</span>
<span class="in">for value in data:</span>
... <span class="in">    print value</span>
...
<span class="out">1
3
5</span>
</pre>

  <p>
    <code>[1, 3, 5]</code> is a list:
    a single object that stores multiple values
    (<a href="#f:simple_list">Figure XXX</a>).
    Just as a <code>for</code> loop over an open file
    reads lines from that file one by one
    and assigns them to the loop variable,
    a <code>for</code> loop over a list assigns each value in the list
    to the loop variable in turn.
  </p>

  <figure id="f:simple_list">
    <img src="pymedia/simple_list.png" alt="A Simple List" />
  </figure>

  <p>
    Let's do something a bit more useful:
  </p>

<pre src="src/python/first_mean.py">
data = [1, 4, 2, 3, 3, 4, 3, 4, 1]
total = 0
for n in data:
    total += n
mean = total / len(data)
print "mean is", mean
<span class="out">mean is 2</span>
</pre>

  <p class="continue">
    This loop adds each value in the list to <code>total</code>.
    Once the loop is over,
    we divide <code>total</code> by the length of the list,
    which we find using the built-in function <code>len</code>.
  </p>

  <p>
    Unfortunately,
    the result in the example above is wrong:
    The total of the numbers in the list is 25,
    but we're printing 2 instead of 25/9
    (which is 2.7777&hellip;).
    The problem once again is that we're dividing one integer by another,
    which throws away the remainder.
    We can fix this by initializing <code>total</code> to 0.0
    (so that all the additions involve a floating-point number and an integer,
    which produces a floating-point number),
    or by using the <code>float</code> function to do the conversion explicitly:
  </p>

<pre src="src/python/second_mean.py">
data = [1, 4, 2, 3, 3, 4, 3, 4, 1]
total = 0
for n in data:
    total += n
mean = <span class="highlight">float(total)</span> / len(data)
print "mean is", mean
<span class="out">mean is 2.77777777778</span>
</pre>

  <p>
    The <em>real</em> problem isn't a matter of integers versus floats, though.
    The real problem with this program is that
    we didn't know whether the answer was right or wrong,
    so we couldn't tell if the program was correct or not.
    After all,
    the average of these nine numbers might well have been 2.
  </p>

  <p>
    The fact that a program runs without crashing doesn't mean it's correct.
    One way to make programs easier to check
    is to run them on smaller or more regular data.
    For example,
    If we ran the program on <code>[1, 4]</code>,
    we'd probably notice that we were getting 2 instead of 2.5.
    Writing programs so that they're checkable is another idea
    that we'll explore in detail <a href="quality.html">later</a>.
  </p>

  <div class="box">

    <h3>Even Simpler</h3>

    <p>
      Python actually has a built-in function called <code>sum</code>,
      so we can get rid of the loop entirely:
    </p>

<pre src="src/python/loopless.py">
total = sum(data)
print "mean is", float(total) / len(data)
</pre>

    <p class="continue">
      and shorten this even further by calling <code>float</code>
      directly on the result of <code>sum</code>:
    </p>

<pre src="src/python/one_liner.py">
print "mean is", float(sum(data)) / len(data)
</pre>

    <p>
      <code>float(sum(data))</code> is like <em>sin(log(x))</em>:
      the inner function is evaluated first,
      and its result is used as the input to the outer function.
      It's important to get the parentheses in the right place,
      since the expressions:
    </p>

<pre src="src/python/one_liner.py">
float(sum(data)) / len(data)
</pre>

    <p class="continue">
      and
    </p>

<pre src="src/python/incorrect_one_liner.py">
float(sum(data) / len(data))
</pre>

    <p class="continue">
      calculate different things.
      In the first,
      <code>float</code> is applied to <code>sum(data)</code>,
      i.e.,
      Python adds up all the numbers,
      then converts the result to a floating-point value
      before dividing by <code>len(data)</code>
      to get the mean.
    </p>

    <p>
      In the second,
      Python adds up the numbers,
      divides by <code>len(data)</code> to get an integer result,
      and then converts that integer to a floating point number.
      This is just our original bug in a more compact form.
      Once again,
      the only way to guard against it is to test the program.
    </p>

  </div>

  <div class="keypoints" id="k:lists">
    <h3>Summary</h3>
    <ul>
      <li>Use <code>[<em>value</em>, <em>value</em>, ...]</code> to create a list of values.</li>
      <li><code>for</code> loops process the elements of a list, in order.</li>
      <li><code>len(<em>list</em>)</code> returns the length of a list.</li>
      <li><code>[]</code> is an empty list with no values.</li>
    </ul>
  </div>

</section>

<section id="s:morelist">

  <h2>More About Lists</h2>

  <div class="understand" id="u:morelist">
    <h3>Understand:</h3>
    <ul>
      <li>That lists can be modified in place.</li>
      <li>How to access arbitrary elements in a list.</li>
      <li>What an out-of-bounds error is.</li>
      <li>How to generate a list of legal indices for a list.</li>
      <li>When to use short or long variable names.</li>
    </ul>
  </div>

  <p>
    Lists (and their equivalents in other languages)
    are used more than any other data structure,
    so let's have a closer look at them.
    First,
    lists are <a href="glossary.html#mutable">mutable</a>,
    i.e.,
    they can be changed after they are created:
  </p>

<pre src="src/python/appending.py">
data = [1, 4, 2, 3]
result = []
current = 0
for n in data:
    current = current + n
    result.append(current)
print "running total:", result
<span class="out">[1, 5, 7, 10]</span>
</pre>

  <p class="continue">
    <code>result</code> starts off as an <a href="glossary.html#empty-list">empty list</a>,
    and <code>current</code> starts off as zero
    (<a href="#f:running_total">Figure XXX</a>).
    Each time the loop executes&mdash;i.e.,
    for each number in <code>values</code>&mdash;Python
    adds the next value in the list to <code>current</code>
    to calculate the running total.
    It then append this value to <code>result</code>,
    so that when the program finishes,
    we have a complete list of partial sums.
  </p>

  <figure id="f:running_total">
    <img src="pymedia/running_total.png" alt="Running Total" />
  </figure>

  <p>
    What if we want to double the values in <code>data</code> in place?
    We could try this:
  </p>

<pre src="src/python/incorrect_doubling_in_place.py">
data = [1, 4, 2, 3]
for n in data:
    n = 2 * n
print "doubled data is:", data
<span class="out">doubled data is [1, 4, 2, 3]</span>
</pre>

  <p class="continue">
    but as we can see,
    it doesn't work.
    When Python calculates <code>2*n</code>,
    it creates a new value in memory
    (<a href="#f:doubling_list">Figure XXX</a>).
    It then makes the variable <code>n</code> point at the value for a few microseconds
    before going around the loop again
    and pointing <code>n</code> at the next value from the list instead.
    Since nothing is pointing to the temporary value we just created any longer,
    Python throws it away.
  </p>

  <figure id="f:doubling_list">
    <img src="pymedia/doubling_list.png" alt="Failed Attempt to Double Values in a List" />
  </figure>

  <p>
    The solution to our problem is,
    not surprisingly,
    to index the list.
    Here are some examples:
  </p>

<pre src="src/python/modify_list.py">
scientists = ["Newton", "Darwing", "Turing"]
print "length:", len(scientists)
<span class="out">length: 3</span>
print "first element:", scientists[0]
<span class="out">first element: Newton</span>
print "second element:", scientists[1]
<span class="out">second element: Darwing</span>
print "third element:", scientists[2]
<span class="out">third element: Turing</span>
</pre>

  <p>
    How does indexing help us?
    Well,
    after noticing that we have misspelled Darwin's name as "Darwing",
    we can fix it by assigning a new value to that location in the list:
  </p>

<pre src="src/python/modify_list_continued.py">
scientists[1] = "Darwin"
print scientists
<span class="out">["Newton", "Darwin", "Turing"]</span>
</pre>

  <p class="continue">
    <a href="#f:update_list">Figure XXX</a> shows
    the list before and after the change.
    Again,
    once we've made the update,
    nothing is pointing to the string "Darwing" with a "g" on the end,
    so the memory it's using is recycled.
  </p>

  <figure id="f:update_list">
    <img src="pymedia/update_list.png" alt="Successfully Doubling Values in a List" />
  </figure>

  <p>
    Now, back to our original problem of doubling values in place.
    We now know that we can do this:
  </p>

<pre src="src/python/explicit_doubling.py">
data = [1, 4, 2]
data[0] = 2 * data[0]
data[1] = 2 * data[1]
data[2] = 2 * data[2]
print "doubled data is:", data
<span class="out">doubled data is [2, 8, 4]</span>
</pre>

  <p class="continue">
    but it clearly doesn't scale:
    we're not going to write a million statements
    to update a list of a million values.
    We need to use a loop,
    but instead of looping over the values in the list,
    we want to loop over the allowed indices of the list.
    To do this,
    we will rely on a function called <code>range</code>
    which creates a list of the first N integers:
  </p>

<pre src="src/python/range_5.py">
print range(5)
<span class="out">[0, 1, 2, 3, 4]</span>
</pre>

  <p>
    Once again,
    the values go from 0 to one less than the number given to <code>range</code>,
    which just happens to be exactly the indices of a list of that length.
    Let's try it out:
  </p>

<pre src="src/python/range_loop.py">
data = [1, 4, 2]
indices = range(3)
for i in indices:
    print i, data[i]
<span class="out">0 1
1 4
2 2</span>
</pre>

  <p class="continue">
    then fold the call to <code>range</code> into the loop:
  </p>

<pre src="src/python/range_loop_2.py">
data = [1, 4, 2]
for i in <span class="highlight">range(3)</span>:
    print i, data[i]
<span class="out">0 1
1 4
2 2</span>
</pre>

  <p>
    This program is correct, but fragile:
    if we add more values to the list,
    Python will still only execute the loop three times,
    so we'll still only print the first three values in the list:
  </p>

<pre src="src/python/incorrect_range_loop.py">
data = [1, 4, 2<span class="highlight">, 5, 1, 3</span>]
for i in range(3):
    print i, data[i]
<span class="out">0 1
1 4
2 2</span>
</pre>

  <p>
    What we want is for the loop to automatically adjust itself
    based on the length of the list:
  </p>

<pre src="src/python/data_length_loop.py">
data = [1, 4, 2, 5, 1, 3]
<span class="highlight">data_length = len(data)</span>
for i in range(<span class="highlight">data_length</span>):
    print i, data[i]
<span class="out">0 1
1 4
2 2
3 5
4 1
5 3</span>
</pre>

  <p>
    We can get rid of the variable <code>data_length</code>
    by putting the call to <code>len(data)</code>
    inside the call to <code>range</code>:
  </p>

<pre src="src/python/idiomatic_range_loop.py">
data = [1, 4, 2, 5, 1, 3]
for i in range(<span class="highlight">len(data)</span>):
    print i, data[i]
<span class="out">0 1
1 4
2 2
3 5
4 1
5 3</span>
</pre>

  <p class="continue">
    Again,
    <code>range(len(data))</code> is like <em>sin(log(x))</em>:
    the inner function is evaluated first,
    and its result becomes the input to the outer function.
    Put together like this,
    they are a common <a href="glossary.html#idiom">idiom</a> in Python,
    i.e.,
    a way of saying something that everyone recognizes and uses.
    When an experienced programmer sees:
  </p>

<pre>
for i in range(len(something)):
</pre>

  <p class="continue">
    what she "hears" is:
  </p>

<pre>
for each legal index of something:
</pre>

  <p>
    The reason this idiom is better than what we started with is that
    there is no duplicated information.
    Instead of having a list of length 3,
    and looping from 0 up to 3,
    we have a list of any length whatever,
    and loop from 0 up to that length.
    In general,
    anything that is repeated two or more times in a program
    will eventually be wrong in at least one.
    Putting it another way,
    any piece of information should appear exactly once in a program,
    so that if it needs to change,
    it only needs to be changed in one place.
  </p>
  
  <div class="box">

    <h3>Short and Long Variable Names</h3>

    <p>
      We have said several times that programs should use meaningful variable names.
      Are we not violating our own rule by using <code>i</code> as a variable in this program?
      The short answer is "yes", but it's a defensible violation.
      Suppose we re-write our loop as:
    </p>

<pre>
data = [1, 4, 2, 5, 1, 3]
for location in range(len(data)):
    print location, data[location]
</pre>

    <p class="continue">
      The longer name are more meaningful,
      but it also takes longer to read.
      Since the original <code>i</code> is only used for a few lines,
      users will easily be able to keep its meaning in short-term memory
      as long as they need to.
      On balance,
      therefore,
      the short name are better in this case.
    </p>

    <p>
      This is actually a general principle in program design.
      A variable that holds a simple value,
      and is only used in a few adjacent lines of code,
      can (and usually should) have a short name.
      A variable that holds a complex value,
      or one which is used over more than a few lines of code,
      should have a longer name
      in order to optimize the tradeoff between reading speed
      and the limitations of human short-term memory.
    </p>

  </div>

    <!-- JK: Also, to hearken back to the previous paragraph, the use of i as a 
         counter in a for loop is arguably another common idiom that 
         experienced programmers will recognize right away as a counter. At 
         least if they're not also mathematicians who read it as an imaginary 
         number... -->

  <p>
    Let's finally go back and double the values in place:
  </p>

<pre src="src/python/doubling_in_place.py">
data = [1, 4, 2, 5, 3, 4, 5]
for i in range(len(data)):
    data[i] = 2 * data[i]
print data
<span class="out">[2, 8, 4, 10, 6, 8, 10]</span>
</pre>

<div class="box">

  <h3>Left and Right</h3>

  <p>
    Seeing the expression <em>x = 2x</em>,
    most mathematicians would say,
    "Right&mdash;so <em>x</em> is zero."
    Seeing the same expression,
    most programmers would say,
    "Right&mdash;you're doubling the value of <em>x</em>."
    <a href="#f:double_in_place">Figure XXX</a> shows
    how that actually works:
  </p>

  <ol>

    <li>
      Python reads the current value of <code>x</code> from memory.
    </li>

    <li>
      It multiplies that value by 2,
      storing the result in a temporary location&hellip;
    </li>

    <li>
      &hellip;and then modifies <code>x</code> to point at the new value.
    </li>

  </ol>

  <figure id="f:double_in_place">
    <img src="pymedia/double_in_place.png" alt="Doubling in Place" />
  </figure>

  <p>
    Now look at what happens when Python execute the statements:
  </p>

<pre>
x = 5
y = x
x = 2 * x
</pre>

<ol>

  <li>
    The variable <code>x</code> is created,
    and set to point at the value 5
    (<a href="#f:new_values_for_variables">Figure XXX</a>).
  </li>

  <li>
    The variable <code>y</code> is created,
    and set to point at the same value.
  </li>

  <li>
    The value 10 (i.e., 2&times;5) is created and stored in a temporary location.
  </li>

  <li>
    <code>x</code> is altered to point at that value.
  </li>

</ol>

<figure id="f:new_values_for_variables">
  <img src="pymedia/new_values_for_variables.png" alt="New Values for Variables" />
</figure>

  <p>
    After these operations are complete,
    <code>y</code> is left pointing at the original value, 5.
    It does <em>not</em> point at the same thing <code>x</code> does any longer,
    and its value is <em>not</em> automatically recalculated
    to keep it twice the value of <code>x</code>.
  </p>

</div>

<div class="keypoints" id="k:morelist">
  <h3>Summary</h3>
  <ul>
    <li>Lists are mutable: they can be changed in place.</li>
    <li>Use <code><em>list</em>.append(<em>value</em>)</code> to append something to the end of a list.</li>
    <li>Use <code><em>list</em>[<em>index</em>]</code> to access a list element by location.</li>
    <li>The index of the first element of a list is 0; the index of the last element is <code>len(<em>list</em>)-1</code>.</li>
    <li>Negative indices count backward from the end of the list, so <code><em>list</em>[-1]</code> is the last element.</li>
    <li>Trying to access an element with an out-of-bounds index is an error.</li>
    <li><code>range(<em>number</em>)</code> produces the list of numbers <code>[0, 1, ..., <em>number</em>-1]</code>.</li>
    <li><code>range(len(<em>list</em>))</code> produces the list of legal indices for <code><em>list</em></code>.</li>
  </ul>
</div>

</section>

<section id="s:coords">

  <h2>Coordinates</h2>

  <div class="understand" id="u:coords">
    <h3>Understand:</h3>
    <ul>
      <li class="fixme">Write something</li>
    </ul>
  </div>

  <p>
    Let's try an experiment in two parts.
    First,
    run this program and look at the image files it creates:
  </p>

<pre>
from skimage import novice

BASE    = 128
STEP    = 4
SPACING = 4
NUMBER  = 6
GRAY    = (BASE, BASE, BASE)
SIZE    = 200

for color in range(BASE + STEP, BASE + NUMBER * STEP, STEP):
    image = novice.new((SIZE, SIZE), GRAY)
    image[::SPACING, ::SPACING] = (color, color, color)
    filename = 'step-' + str(color) + '.png'
    image.save(filename)
</pre>

  <p>
    These files have named like <code>step-132.png</code>,
    <code>step-136.png</code>,
    and so on.
    Each one has white pixels spaced evenly across a gray background,
    with the white slowly getting whiter.
    Images like these are sometimes used in vision tests,
    since different spacings and colorings are noticeable to different people.
  </p>

  <p>
    Having told you that,
    we've spoiled the second part of our experiment,
    which is to see how much knowing what a program does
    helps you figure out how it works.
    As you might suspect,
    the answer is, "A lot."
    Let's go through this one.
  </p>

  <p>
    The constants at the top don't tell us much,
    although <code>GRAY</code> is obviously an RGB color value
    and <code>SIZE</code> is (probably) an image size.
    Next is our loop:
    given the name of its index variable,
    <code>color</code>,
    we can guess that we're looping over colors,
    and sure enough,
    two lines down,
    we see <code>(color, color, color)</code>,
    which is creating a shade of gray defined by the current value of <code>color</code>.
  </p>

  <p>
    Backing up a line,
    we're creating a <code>SIZE</code>&times;<code>SIZE</code> image using <code>novice.new</code>
    and setting all its pixels to the fixed color <code>GRAY</code>.
    We're then&mdash;hm.
    What does <code>::SPACING</code> do?
    If it was <code>:SPACING</code> (with a single colon),
    it would mean,
    "From the start up to <code>SPACING</code>,"
    but there's a double colon there.
  </p>

  <p>
    The answer is that Python ranges can actually have three parts:
    the start,
    the end,
    and the <a href="glossary.html#stride">stride</a>,
    which is the separation between each entry.
    We can find out more about this inside the interpreter
    using the built-in <code>help</code> function:
  </p>

<pre>
<span class="in">help(range)</span>
<span class="out">range(...)
    range([start,] stop[, step]) -> list of integers
    
    Return a list containing an arithmetic progression of integers.
    range(i, j) returns [i, i+1, i+2, ..., j-1]; start (!) defaults to 0.
    When step is given, it specifies the increment (or decrement).
    For example, range(4) returns [0, 1, 2, 3].  The end point is omitted!
    These are exactly the valid indices for a list of 4 elements.</span>
</pre>

  <p class="continue">
    However,
    that doesn't tell us that strides also work in indices:
    that's something we just have to know.
  </p>

  <p>
    So,
    going back to our program,
    the key lines are:
  </p>

<pre>
for color in range(BASE + STEP, BASE + NUMBER * STEP, STEP):
    ...create image...
    image[::SPACING, ::SPACING] = (color, color, color)
</pre>

  <p class="continue">
    The loop is going from <code>BASE + STEP</code> up to <code>BASE + NUMBER * STEP</code>
    in increments of <code>STEP</code>.
    <code>BASE</code> is 128&mdash;our initial shade of gray.
    <code>STEP</code> is 4:
    that's the increment each time we go around the loop.
    And <code>NUMBER</code> is how many we're doing,
    so this loop is creating a bunch of images with the same gray background,
    but whiter and whiter points spaced at equal intervals across them.
  </p>

  <div class="keypoints" id="k:coords">
    <h3>Summary</h3>
    <ul>
      <li class="fixme">Write something</li>
    </ul>
  </div>

</section>

<section id="s:nestloop">

  <h2>Nesting Loops</h2>

  <div class="understand" id="u:nestloop">
    <h3>Understand:</h3>
    <ul>
      <li>That loops can be nested to operate on combinations of items.</li>
      <li>That the range of inner loops can depend on the state of outer loops.</li>
      <li>That doing this allows programs to handle more cases without changes.</li>
    </ul>
  </div>

  <p class="fixme">
    Explain nested loops in terms of triangles on images.
  </p>

</section>

<section id="s:puzzle">

  <h2>Cutting Up Images</h2>

  <p>
    We now have everything we need to solve Valerie's original problem,
    which is to cut an image into pieces
    and colorize those pieces in different ways.
    First,
    let's figure out what our input file is,
    and how many pieces we want along the X and Y axes:
  </p>

<pre>
import sys
from skimage import novice

if len(sys.argv) != 4:
    print 'Expected source filename and number of tiles on X and Y'
    sys.exit(1)

original_filename = sys.argv[1]
tile_x = int(sys.argv[2])
tile_y = int(sys.argv[3])
</pre>

  <p>
    After importing our libraries,
    this program checks that it has the right number of arguments.
    (Once again,
    the number is 4 because <code>sys.argv[0]</code> is the name of the program.)
    If something is wrong,
    the program prints an error message and exits.
    <span class="fixme">explain why 1</span>
    It then stores the name of the source file in <code>original_filename</code>,
    and converts the other two arguments to integers.
  </p>

<pre>
original = novice.open(original_filename)
size_x = original.width / tile_x
size_y = original.height / tile_y
if (size_x == 0) or (size_y == 0):
    print 'Cannot create that many tiles.'
    sys.exit(1)
</pre>

  <p>
    Here,
    the program opens the source file
    and figures out how large each tile is going to be along the X and Y axes.
    Once again,
    it checks to make sure the answer is reasonable:
    if,
    for example,
    we ask for 2000 tiles along an axis that's 200 pixels large,
    the integer-over-integer division will set the size to zero,
    and we should exit right away.
  </p>

<pre>
for x in range(0, size_x * tile_x, size_x):
    for y in range(0, size_y * tile_y, size_y):
        tile = novice.new((size_x, size_y))
        tile[:, :] = original[x:x+size_x, y:y+size_y]
        tile_filename = str(x) + '-' + str(y) + '-' + original_filename
        tile.save(tile_filename)
</pre>

  <p>
    This nested loop creates our slices.
    The loop variables <code>x</code> and <code>y</code> are coordinates of
    the lower-left corners of the slices;
    for each combination of their values,
    we create a new blank image
    (which we assign to <code>tile</code>),
    then copy over a section of the original image.
    We then construct a filename like
    <code>100-140-bicycle.jpg</code>
    and save that tile.
  </p>

</section>

{% endblock content %}
